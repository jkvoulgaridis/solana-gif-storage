{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.map = exports.array = exports.rustEnum = exports.str = exports.vecU8 = exports.tagged = exports.vec = exports.bool = exports.option = exports.publicKey = exports.i128 = exports.u128 = exports.i64 = exports.u64 = exports.struct = exports.f64 = exports.f32 = exports.i32 = exports.u32 = exports.i16 = exports.u16 = exports.i8 = exports.u8 = void 0;\n\nconst buffer_layout_1 = require(\"buffer-layout\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar buffer_layout_2 = require(\"buffer-layout\");\n\nObject.defineProperty(exports, \"u8\", {\n  enumerable: true,\n  get: function () {\n    return buffer_layout_2.u8;\n  }\n});\nObject.defineProperty(exports, \"i8\", {\n  enumerable: true,\n  get: function () {\n    return buffer_layout_2.s8;\n  }\n});\nObject.defineProperty(exports, \"u16\", {\n  enumerable: true,\n  get: function () {\n    return buffer_layout_2.u16;\n  }\n});\nObject.defineProperty(exports, \"i16\", {\n  enumerable: true,\n  get: function () {\n    return buffer_layout_2.s16;\n  }\n});\nObject.defineProperty(exports, \"u32\", {\n  enumerable: true,\n  get: function () {\n    return buffer_layout_2.u32;\n  }\n});\nObject.defineProperty(exports, \"i32\", {\n  enumerable: true,\n  get: function () {\n    return buffer_layout_2.s32;\n  }\n});\nObject.defineProperty(exports, \"f32\", {\n  enumerable: true,\n  get: function () {\n    return buffer_layout_2.f32;\n  }\n});\nObject.defineProperty(exports, \"f64\", {\n  enumerable: true,\n  get: function () {\n    return buffer_layout_2.f64;\n  }\n});\nObject.defineProperty(exports, \"struct\", {\n  enumerable: true,\n  get: function () {\n    return buffer_layout_2.struct;\n  }\n});\n\nclass BNLayout extends buffer_layout_1.Layout {\n  constructor(span, signed, property) {\n    super(span, property);\n    this.blob = buffer_layout_1.blob(span);\n    this.signed = signed;\n  }\n\n  decode(b) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const num = new bn_js_1.default(this.blob.decode(b, offset), 10, 'le');\n\n    if (this.signed) {\n      return num.fromTwos(this.span * 8).clone();\n    }\n\n    return num;\n  }\n\n  encode(src, b) {\n    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (this.signed) {\n      src = src.toTwos(this.span * 8);\n    }\n\n    return this.blob.encode(src.toArrayLike(Buffer, 'le', this.span), b, offset);\n  }\n\n}\n\nfunction u64(property) {\n  return new BNLayout(8, false, property);\n}\n\nexports.u64 = u64;\n\nfunction i64(property) {\n  return new BNLayout(8, true, property);\n}\n\nexports.i64 = i64;\n\nfunction u128(property) {\n  return new BNLayout(16, false, property);\n}\n\nexports.u128 = u128;\n\nfunction i128(property) {\n  return new BNLayout(16, true, property);\n}\n\nexports.i128 = i128;\n\nclass WrappedLayout extends buffer_layout_1.Layout {\n  constructor(layout, decoder, encoder, property) {\n    super(layout.span, property);\n    this.layout = layout;\n    this.decoder = decoder;\n    this.encoder = encoder;\n  }\n\n  decode(b, offset) {\n    return this.decoder(this.layout.decode(b, offset));\n  }\n\n  encode(src, b, offset) {\n    return this.layout.encode(this.encoder(src), b, offset);\n  }\n\n  getSpan(b, offset) {\n    return this.layout.getSpan(b, offset);\n  }\n\n}\n\nfunction publicKey(property) {\n  return new WrappedLayout(buffer_layout_1.blob(32), b => new web3_js_1.PublicKey(b), key => key.toBuffer(), property);\n}\n\nexports.publicKey = publicKey;\n\nclass OptionLayout extends buffer_layout_1.Layout {\n  constructor(layout, property) {\n    super(-1, property);\n    this.layout = layout;\n    this.discriminator = buffer_layout_1.u8();\n  }\n\n  encode(src, b) {\n    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (src === null || src === undefined) {\n      return this.discriminator.encode(0, b, offset);\n    }\n\n    this.discriminator.encode(1, b, offset);\n    return this.layout.encode(src, b, offset + 1) + 1;\n  }\n\n  decode(b) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const discriminator = this.discriminator.decode(b, offset);\n\n    if (discriminator === 0) {\n      return null;\n    } else if (discriminator === 1) {\n      return this.layout.decode(b, offset + 1);\n    }\n\n    throw new Error('Invalid option ' + this.property);\n  }\n\n  getSpan(b) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const discriminator = this.discriminator.decode(b, offset);\n\n    if (discriminator === 0) {\n      return 1;\n    } else if (discriminator === 1) {\n      return this.layout.getSpan(b, offset + 1) + 1;\n    }\n\n    throw new Error('Invalid option ' + this.property);\n  }\n\n}\n\nfunction option(layout, property) {\n  return new OptionLayout(layout, property);\n}\n\nexports.option = option;\n\nfunction bool(property) {\n  return new WrappedLayout(buffer_layout_1.u8(), decodeBool, encodeBool, property);\n}\n\nexports.bool = bool;\n\nfunction decodeBool(value) {\n  if (value === 0) {\n    return false;\n  } else if (value === 1) {\n    return true;\n  }\n\n  throw new Error('Invalid bool: ' + value);\n}\n\nfunction encodeBool(value) {\n  return value ? 1 : 0;\n}\n\nfunction vec(elementLayout, property) {\n  const length = buffer_layout_1.u32('length');\n  const layout = buffer_layout_1.struct([length, buffer_layout_1.seq(elementLayout, buffer_layout_1.offset(length, -length.span), 'values')]);\n  return new WrappedLayout(layout, _ref => {\n    let {\n      values\n    } = _ref;\n    return values;\n  }, values => ({\n    values\n  }), property);\n}\n\nexports.vec = vec;\n\nfunction tagged(tag, layout, property) {\n  const wrappedLayout = buffer_layout_1.struct([u64('tag'), layout.replicate('data')]);\n\n  function decodeTag(_ref2) {\n    let {\n      tag: receivedTag,\n      data\n    } = _ref2;\n\n    if (!receivedTag.eq(tag)) {\n      throw new Error('Invalid tag, expected: ' + tag.toString('hex') + ', got: ' + receivedTag.toString('hex'));\n    }\n\n    return data;\n  }\n\n  return new WrappedLayout(wrappedLayout, decodeTag, data => ({\n    tag,\n    data\n  }), property);\n}\n\nexports.tagged = tagged;\n\nfunction vecU8(property) {\n  const length = buffer_layout_1.u32('length');\n  const layout = buffer_layout_1.struct([length, buffer_layout_1.blob(buffer_layout_1.offset(length, -length.span), 'data')]);\n  return new WrappedLayout(layout, _ref3 => {\n    let {\n      data\n    } = _ref3;\n    return data;\n  }, data => ({\n    data\n  }), property);\n}\n\nexports.vecU8 = vecU8;\n\nfunction str(property) {\n  return new WrappedLayout(vecU8(), data => data.toString('utf-8'), s => Buffer.from(s, 'utf-8'), property);\n}\n\nexports.str = str;\n\nfunction rustEnum(variants, property, discriminant) {\n  const unionLayout = buffer_layout_1.union(discriminant !== null && discriminant !== void 0 ? discriminant : buffer_layout_1.u8(), property);\n  variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));\n  return unionLayout;\n}\n\nexports.rustEnum = rustEnum;\n\nfunction array(elementLayout, length, property) {\n  const layout = buffer_layout_1.struct([buffer_layout_1.seq(elementLayout, length, 'values')]);\n  return new WrappedLayout(layout, _ref4 => {\n    let {\n      values\n    } = _ref4;\n    return values;\n  }, values => ({\n    values\n  }), property);\n}\n\nexports.array = array;\n\nclass MapEntryLayout extends buffer_layout_1.Layout {\n  constructor(keyLayout, valueLayout, property) {\n    super(keyLayout.span + valueLayout.span, property);\n    this.keyLayout = keyLayout;\n    this.valueLayout = valueLayout;\n  }\n\n  decode(b, offset) {\n    offset = offset || 0;\n    const key = this.keyLayout.decode(b, offset);\n    const value = this.valueLayout.decode(b, offset + this.keyLayout.getSpan(b, offset));\n    return [key, value];\n  }\n\n  encode(src, b, offset) {\n    offset = offset || 0;\n    const keyBytes = this.keyLayout.encode(src[0], b, offset);\n    const valueBytes = this.valueLayout.encode(src[1], b, offset + keyBytes);\n    return keyBytes + valueBytes;\n  }\n\n  getSpan(b, offset) {\n    return this.keyLayout.getSpan(b, offset) + this.valueLayout.getSpan(b, offset);\n  }\n\n}\n\nfunction map(keyLayout, valueLayout, property) {\n  const length = buffer_layout_1.u32('length');\n  const layout = buffer_layout_1.struct([length, buffer_layout_1.seq(new MapEntryLayout(keyLayout, valueLayout), buffer_layout_1.offset(length, -length.span), 'values')]);\n  return new WrappedLayout(layout, _ref5 => {\n    let {\n      values\n    } = _ref5;\n    return new Map(values);\n  }, values => ({\n    values: Array.from(values.entries())\n  }), property);\n}\n\nexports.map = map; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script"}