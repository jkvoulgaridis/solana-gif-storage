{"ast":null,"code":"import _objectWithoutProperties from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _wrapNativeSuper from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _slicedToArray from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _possibleConstructorReturn from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/john/personal/solana-learnings/frontend-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nimport nacl from 'tweetnacl';\nimport { Buffer } from 'buffer';\nimport BN from 'bn.js';\nimport bs58 from 'bs58';\nimport { serialize, deserialize, deserializeUnchecked } from 'borsh';\nimport * as BufferLayout from '@solana/buffer-layout';\nimport { blob } from '@solana/buffer-layout';\nimport { toBigIntLE, toBufferLE } from 'bigint-buffer';\nimport { coerce, instance, string, tuple, literal, unknown, union, type, optional, any, number, array, nullable, create, boolean, record, assert as assert$7 } from 'superstruct';\nimport { Client } from 'rpc-websockets';\nimport RpcClient from 'jayson/lib/client/browser';\nimport secp256k1 from 'secp256k1';\nimport sha3 from 'js-sha3';\n\nvar toBuffer = function toBuffer(arr) {\n  if (Buffer.isBuffer(arr)) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return Buffer.from(arr);\n  }\n};\n\nvar hash$1 = {};\nvar utils$9 = {};\nvar minimalisticAssert = assert$6;\n\nfunction assert$6(val, msg) {\n  if (!val) throw new Error(msg || 'Assertion failed');\n}\n\nassert$6.equal = function assertEqual(l, r, msg) {\n  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);\n};\n\nvar inherits_browser = {\n  exports: {}\n};\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  inherits_browser.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n  };\n} else {\n  // old school shim for old browsers\n  inherits_browser.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n\n      var TempCtor = function TempCtor() {};\n\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    }\n  };\n}\n\nvar assert$5 = minimalisticAssert;\nvar inherits = inherits_browser.exports;\nutils$9.inherits = inherits;\n\nfunction isSurrogatePair(msg, i) {\n  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {\n    return false;\n  }\n\n  if (i < 0 || i + 1 >= msg.length) {\n    return false;\n  }\n\n  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;\n}\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg)) return msg.slice();\n  if (!msg) return [];\n  var res = [];\n\n  if (typeof msg === 'string') {\n    if (!enc) {\n      // Inspired by stringToUtf8ByteArray() in closure-library by Google\n      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n      // Apache License 2.0\n      // https://github.com/google/closure-library/blob/master/LICENSE\n      var p = 0;\n\n      for (var i = 0; i < msg.length; i++) {\n        var c = msg.charCodeAt(i);\n\n        if (c < 128) {\n          res[p++] = c;\n        } else if (c < 2048) {\n          res[p++] = c >> 6 | 192;\n          res[p++] = c & 63 | 128;\n        } else if (isSurrogatePair(msg, i)) {\n          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);\n          res[p++] = c >> 18 | 240;\n          res[p++] = c >> 12 & 63 | 128;\n          res[p++] = c >> 6 & 63 | 128;\n          res[p++] = c & 63 | 128;\n        } else {\n          res[p++] = c >> 12 | 224;\n          res[p++] = c >> 6 & 63 | 128;\n          res[p++] = c & 63 | 128;\n        }\n      }\n    } else if (enc === 'hex') {\n      msg = msg.replace(/[^a-z0-9]+/ig, '');\n      if (msg.length % 2 !== 0) msg = '0' + msg;\n\n      for (i = 0; i < msg.length; i += 2) {\n        res.push(parseInt(msg[i] + msg[i + 1], 16));\n      }\n    }\n  } else {\n    for (i = 0; i < msg.length; i++) {\n      res[i] = msg[i] | 0;\n    }\n  }\n\n  return res;\n}\n\nutils$9.toArray = toArray;\n\nfunction toHex(msg) {\n  var res = '';\n\n  for (var i = 0; i < msg.length; i++) {\n    res += zero2(msg[i].toString(16));\n  }\n\n  return res;\n}\n\nutils$9.toHex = toHex;\n\nfunction htonl(w) {\n  var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;\n  return res >>> 0;\n}\n\nutils$9.htonl = htonl;\n\nfunction toHex32(msg, endian) {\n  var res = '';\n\n  for (var i = 0; i < msg.length; i++) {\n    var w = msg[i];\n    if (endian === 'little') w = htonl(w);\n    res += zero8(w.toString(16));\n  }\n\n  return res;\n}\n\nutils$9.toHex32 = toHex32;\n\nfunction zero2(word) {\n  if (word.length === 1) return '0' + word;else return word;\n}\n\nutils$9.zero2 = zero2;\n\nfunction zero8(word) {\n  if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;\n}\n\nutils$9.zero8 = zero8;\n\nfunction join32(msg, start, end, endian) {\n  var len = end - start;\n  assert$5(len % 4 === 0);\n  var res = new Array(len / 4);\n\n  for (var i = 0, k = start; i < res.length; i++, k += 4) {\n    var w;\n    if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];\n    res[i] = w >>> 0;\n  }\n\n  return res;\n}\n\nutils$9.join32 = join32;\n\nfunction split32(msg, endian) {\n  var res = new Array(msg.length * 4);\n\n  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n    var m = msg[i];\n\n    if (endian === 'big') {\n      res[k] = m >>> 24;\n      res[k + 1] = m >>> 16 & 0xff;\n      res[k + 2] = m >>> 8 & 0xff;\n      res[k + 3] = m & 0xff;\n    } else {\n      res[k + 3] = m >>> 24;\n      res[k + 2] = m >>> 16 & 0xff;\n      res[k + 1] = m >>> 8 & 0xff;\n      res[k] = m & 0xff;\n    }\n  }\n\n  return res;\n}\n\nutils$9.split32 = split32;\n\nfunction rotr32$1(w, b) {\n  return w >>> b | w << 32 - b;\n}\n\nutils$9.rotr32 = rotr32$1;\n\nfunction rotl32$2(w, b) {\n  return w << b | w >>> 32 - b;\n}\n\nutils$9.rotl32 = rotl32$2;\n\nfunction sum32$3(a, b) {\n  return a + b >>> 0;\n}\n\nutils$9.sum32 = sum32$3;\n\nfunction sum32_3$1(a, b, c) {\n  return a + b + c >>> 0;\n}\n\nutils$9.sum32_3 = sum32_3$1;\n\nfunction sum32_4$2(a, b, c, d) {\n  return a + b + c + d >>> 0;\n}\n\nutils$9.sum32_4 = sum32_4$2;\n\nfunction sum32_5$2(a, b, c, d, e) {\n  return a + b + c + d + e >>> 0;\n}\n\nutils$9.sum32_5 = sum32_5$2;\n\nfunction sum64$1(buf, pos, ah, al) {\n  var bh = buf[pos];\n  var bl = buf[pos + 1];\n  var lo = al + bl >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  buf[pos] = hi >>> 0;\n  buf[pos + 1] = lo;\n}\n\nutils$9.sum64 = sum64$1;\n\nfunction sum64_hi$1(ah, al, bh, bl) {\n  var lo = al + bl >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  return hi >>> 0;\n}\n\nutils$9.sum64_hi = sum64_hi$1;\n\nfunction sum64_lo$1(ah, al, bh, bl) {\n  var lo = al + bl;\n  return lo >>> 0;\n}\n\nutils$9.sum64_lo = sum64_lo$1;\n\nfunction sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {\n  var carry = 0;\n  var lo = al;\n  lo = lo + bl >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = lo + cl >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = lo + dl >>> 0;\n  carry += lo < dl ? 1 : 0;\n  var hi = ah + bh + ch + dh + carry;\n  return hi >>> 0;\n}\n\nutils$9.sum64_4_hi = sum64_4_hi$1;\n\nfunction sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {\n  var lo = al + bl + cl + dl;\n  return lo >>> 0;\n}\n\nutils$9.sum64_4_lo = sum64_4_lo$1;\n\nfunction sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var carry = 0;\n  var lo = al;\n  lo = lo + bl >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = lo + cl >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = lo + dl >>> 0;\n  carry += lo < dl ? 1 : 0;\n  lo = lo + el >>> 0;\n  carry += lo < el ? 1 : 0;\n  var hi = ah + bh + ch + dh + eh + carry;\n  return hi >>> 0;\n}\n\nutils$9.sum64_5_hi = sum64_5_hi$1;\n\nfunction sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var lo = al + bl + cl + dl + el;\n  return lo >>> 0;\n}\n\nutils$9.sum64_5_lo = sum64_5_lo$1;\n\nfunction rotr64_hi$1(ah, al, num) {\n  var r = al << 32 - num | ah >>> num;\n  return r >>> 0;\n}\n\nutils$9.rotr64_hi = rotr64_hi$1;\n\nfunction rotr64_lo$1(ah, al, num) {\n  var r = ah << 32 - num | al >>> num;\n  return r >>> 0;\n}\n\nutils$9.rotr64_lo = rotr64_lo$1;\n\nfunction shr64_hi$1(ah, al, num) {\n  return ah >>> num;\n}\n\nutils$9.shr64_hi = shr64_hi$1;\n\nfunction shr64_lo$1(ah, al, num) {\n  var r = ah << 32 - num | al >>> num;\n  return r >>> 0;\n}\n\nutils$9.shr64_lo = shr64_lo$1;\nvar common$5 = {};\nvar utils$8 = utils$9;\nvar assert$4 = minimalisticAssert;\n\nfunction BlockHash$4() {\n  this.pending = null;\n  this.pendingTotal = 0;\n  this.blockSize = this.constructor.blockSize;\n  this.outSize = this.constructor.outSize;\n  this.hmacStrength = this.constructor.hmacStrength;\n  this.padLength = this.constructor.padLength / 8;\n  this.endian = 'big';\n  this._delta8 = this.blockSize / 8;\n  this._delta32 = this.blockSize / 32;\n}\n\ncommon$5.BlockHash = BlockHash$4;\n\nBlockHash$4.prototype.update = function update(msg, enc) {\n  // Convert message to array, pad it, and join into 32bit blocks\n  msg = utils$8.toArray(msg, enc);\n  if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);\n  this.pendingTotal += msg.length; // Enough data, try updating\n\n  if (this.pending.length >= this._delta8) {\n    msg = this.pending; // Process pending data in blocks\n\n    var r = msg.length % this._delta8;\n    this.pending = msg.slice(msg.length - r, msg.length);\n    if (this.pending.length === 0) this.pending = null;\n    msg = utils$8.join32(msg, 0, msg.length - r, this.endian);\n\n    for (var i = 0; i < msg.length; i += this._delta32) {\n      this._update(msg, i, i + this._delta32);\n    }\n  }\n\n  return this;\n};\n\nBlockHash$4.prototype.digest = function digest(enc) {\n  this.update(this._pad());\n  assert$4(this.pending === null);\n  return this._digest(enc);\n};\n\nBlockHash$4.prototype._pad = function pad() {\n  var len = this.pendingTotal;\n  var bytes = this._delta8;\n  var k = bytes - (len + this.padLength) % bytes;\n  var res = new Array(k + this.padLength);\n  res[0] = 0x80;\n\n  for (var i = 1; i < k; i++) {\n    res[i] = 0;\n  } // Append length\n\n\n  len <<= 3;\n\n  if (this.endian === 'big') {\n    for (var t = 8; t < this.padLength; t++) {\n      res[i++] = 0;\n    }\n\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = len >>> 24 & 0xff;\n    res[i++] = len >>> 16 & 0xff;\n    res[i++] = len >>> 8 & 0xff;\n    res[i++] = len & 0xff;\n  } else {\n    res[i++] = len & 0xff;\n    res[i++] = len >>> 8 & 0xff;\n    res[i++] = len >>> 16 & 0xff;\n    res[i++] = len >>> 24 & 0xff;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n\n    for (t = 8; t < this.padLength; t++) {\n      res[i++] = 0;\n    }\n  }\n\n  return res;\n};\n\nvar sha = {};\nvar common$4 = {};\nvar utils$7 = utils$9;\nvar rotr32 = utils$7.rotr32;\n\nfunction ft_1$1(s, x, y, z) {\n  if (s === 0) return ch32$1(x, y, z);\n  if (s === 1 || s === 3) return p32(x, y, z);\n  if (s === 2) return maj32$1(x, y, z);\n}\n\ncommon$4.ft_1 = ft_1$1;\n\nfunction ch32$1(x, y, z) {\n  return x & y ^ ~x & z;\n}\n\ncommon$4.ch32 = ch32$1;\n\nfunction maj32$1(x, y, z) {\n  return x & y ^ x & z ^ y & z;\n}\n\ncommon$4.maj32 = maj32$1;\n\nfunction p32(x, y, z) {\n  return x ^ y ^ z;\n}\n\ncommon$4.p32 = p32;\n\nfunction s0_256$1(x) {\n  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n}\n\ncommon$4.s0_256 = s0_256$1;\n\nfunction s1_256$1(x) {\n  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n}\n\ncommon$4.s1_256 = s1_256$1;\n\nfunction g0_256$1(x) {\n  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;\n}\n\ncommon$4.g0_256 = g0_256$1;\n\nfunction g1_256$1(x) {\n  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;\n}\n\ncommon$4.g1_256 = g1_256$1;\nvar utils$6 = utils$9;\nvar common$3 = common$5;\nvar shaCommon$1 = common$4;\nvar rotl32$1 = utils$6.rotl32;\nvar sum32$2 = utils$6.sum32;\nvar sum32_5$1 = utils$6.sum32_5;\nvar ft_1 = shaCommon$1.ft_1;\nvar BlockHash$3 = common$3.BlockHash;\nvar sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];\n\nfunction SHA1() {\n  if (!(this instanceof SHA1)) return new SHA1();\n  BlockHash$3.call(this);\n  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n  this.W = new Array(80);\n}\n\nutils$6.inherits(SHA1, BlockHash$3);\nvar _1 = SHA1;\nSHA1.blockSize = 512;\nSHA1.outSize = 160;\nSHA1.hmacStrength = 80;\nSHA1.padLength = 64;\n\nSHA1.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++) {\n    W[i] = msg[start + i];\n  }\n\n  for (; i < W.length; i++) {\n    W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n  }\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n\n  for (i = 0; i < W.length; i++) {\n    var s = ~~(i / 20);\n    var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\n    e = d;\n    d = c;\n    c = rotl32$1(b, 30);\n    b = a;\n    a = t;\n  }\n\n  this.h[0] = sum32$2(this.h[0], a);\n  this.h[1] = sum32$2(this.h[1], b);\n  this.h[2] = sum32$2(this.h[2], c);\n  this.h[3] = sum32$2(this.h[3], d);\n  this.h[4] = sum32$2(this.h[4], e);\n};\n\nSHA1.prototype._digest = function digest(enc) {\n  if (enc === 'hex') return utils$6.toHex32(this.h, 'big');else return utils$6.split32(this.h, 'big');\n};\n\nvar utils$5 = utils$9;\nvar common$2 = common$5;\nvar shaCommon = common$4;\nvar assert$3 = minimalisticAssert;\nvar sum32$1 = utils$5.sum32;\nvar sum32_4$1 = utils$5.sum32_4;\nvar sum32_5 = utils$5.sum32_5;\nvar ch32 = shaCommon.ch32;\nvar maj32 = shaCommon.maj32;\nvar s0_256 = shaCommon.s0_256;\nvar s1_256 = shaCommon.s1_256;\nvar g0_256 = shaCommon.g0_256;\nvar g1_256 = shaCommon.g1_256;\nvar BlockHash$2 = common$2.BlockHash;\nvar sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n\nfunction SHA256$1() {\n  if (!(this instanceof SHA256$1)) return new SHA256$1();\n  BlockHash$2.call(this);\n  this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n  this.k = sha256_K;\n  this.W = new Array(64);\n}\n\nutils$5.inherits(SHA256$1, BlockHash$2);\nvar _256 = SHA256$1;\nSHA256$1.blockSize = 512;\nSHA256$1.outSize = 256;\nSHA256$1.hmacStrength = 192;\nSHA256$1.padLength = 64;\n\nSHA256$1.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++) {\n    W[i] = msg[start + i];\n  }\n\n  for (; i < W.length; i++) {\n    W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\n  }\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n  var f = this.h[5];\n  var g = this.h[6];\n  var h = this.h[7];\n  assert$3(this.k.length === W.length);\n\n  for (i = 0; i < W.length; i++) {\n    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);\n    var T2 = sum32$1(s0_256(a), maj32(a, b, c));\n    h = g;\n    g = f;\n    f = e;\n    e = sum32$1(d, T1);\n    d = c;\n    c = b;\n    b = a;\n    a = sum32$1(T1, T2);\n  }\n\n  this.h[0] = sum32$1(this.h[0], a);\n  this.h[1] = sum32$1(this.h[1], b);\n  this.h[2] = sum32$1(this.h[2], c);\n  this.h[3] = sum32$1(this.h[3], d);\n  this.h[4] = sum32$1(this.h[4], e);\n  this.h[5] = sum32$1(this.h[5], f);\n  this.h[6] = sum32$1(this.h[6], g);\n  this.h[7] = sum32$1(this.h[7], h);\n};\n\nSHA256$1.prototype._digest = function digest(enc) {\n  if (enc === 'hex') return utils$5.toHex32(this.h, 'big');else return utils$5.split32(this.h, 'big');\n};\n\nvar utils$4 = utils$9;\nvar SHA256 = _256;\n\nfunction SHA224() {\n  if (!(this instanceof SHA224)) return new SHA224();\n  SHA256.call(this);\n  this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];\n}\n\nutils$4.inherits(SHA224, SHA256);\nvar _224 = SHA224;\nSHA224.blockSize = 512;\nSHA224.outSize = 224;\nSHA224.hmacStrength = 192;\nSHA224.padLength = 64;\n\nSHA224.prototype._digest = function digest(enc) {\n  // Just truncate output\n  if (enc === 'hex') return utils$4.toHex32(this.h.slice(0, 7), 'big');else return utils$4.split32(this.h.slice(0, 7), 'big');\n};\n\nvar utils$3 = utils$9;\nvar common$1 = common$5;\nvar assert$2 = minimalisticAssert;\nvar rotr64_hi = utils$3.rotr64_hi;\nvar rotr64_lo = utils$3.rotr64_lo;\nvar shr64_hi = utils$3.shr64_hi;\nvar shr64_lo = utils$3.shr64_lo;\nvar sum64 = utils$3.sum64;\nvar sum64_hi = utils$3.sum64_hi;\nvar sum64_lo = utils$3.sum64_lo;\nvar sum64_4_hi = utils$3.sum64_4_hi;\nvar sum64_4_lo = utils$3.sum64_4_lo;\nvar sum64_5_hi = utils$3.sum64_5_hi;\nvar sum64_5_lo = utils$3.sum64_5_lo;\nvar BlockHash$1 = common$1.BlockHash;\nvar sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];\n\nfunction SHA512$1() {\n  if (!(this instanceof SHA512$1)) return new SHA512$1();\n  BlockHash$1.call(this);\n  this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];\n  this.k = sha512_K;\n  this.W = new Array(160);\n}\n\nutils$3.inherits(SHA512$1, BlockHash$1);\nvar _512 = SHA512$1;\nSHA512$1.blockSize = 1024;\nSHA512$1.outSize = 512;\nSHA512$1.hmacStrength = 192;\nSHA512$1.padLength = 128;\n\nSHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {\n  var W = this.W; // 32 x 32bit words\n\n  for (var i = 0; i < 32; i++) {\n    W[i] = msg[start + i];\n  }\n\n  for (; i < W.length; i += 2) {\n    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2\n\n    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n    var c1_hi = W[i - 14]; // i - 7\n\n    var c1_lo = W[i - 13];\n    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15\n\n    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n    var c3_hi = W[i - 32]; // i - 16\n\n    var c3_lo = W[i - 31];\n    W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n    W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n  }\n};\n\nSHA512$1.prototype._update = function _update(msg, start) {\n  this._prepareBlock(msg, start);\n\n  var W = this.W;\n  var ah = this.h[0];\n  var al = this.h[1];\n  var bh = this.h[2];\n  var bl = this.h[3];\n  var ch = this.h[4];\n  var cl = this.h[5];\n  var dh = this.h[6];\n  var dl = this.h[7];\n  var eh = this.h[8];\n  var el = this.h[9];\n  var fh = this.h[10];\n  var fl = this.h[11];\n  var gh = this.h[12];\n  var gl = this.h[13];\n  var hh = this.h[14];\n  var hl = this.h[15];\n  assert$2(this.k.length === W.length);\n\n  for (var i = 0; i < W.length; i += 2) {\n    var c0_hi = hh;\n    var c0_lo = hl;\n    var c1_hi = s1_512_hi(eh, el);\n    var c1_lo = s1_512_lo(eh, el);\n    var c2_hi = ch64_hi(eh, el, fh, fl, gh);\n    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n    var c3_hi = this.k[i];\n    var c3_lo = this.k[i + 1];\n    var c4_hi = W[i];\n    var c4_lo = W[i + 1];\n    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n    c0_hi = s0_512_hi(ah, al);\n    c0_lo = s0_512_lo(ah, al);\n    c1_hi = maj64_hi(ah, al, bh, bl, ch);\n    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);\n    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n    hh = gh;\n    hl = gl;\n    gh = fh;\n    gl = fl;\n    fh = eh;\n    fl = el;\n    eh = sum64_hi(dh, dl, T1_hi, T1_lo);\n    el = sum64_lo(dl, dl, T1_hi, T1_lo);\n    dh = ch;\n    dl = cl;\n    ch = bh;\n    cl = bl;\n    bh = ah;\n    bl = al;\n    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);\n    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n  }\n\n  sum64(this.h, 0, ah, al);\n  sum64(this.h, 2, bh, bl);\n  sum64(this.h, 4, ch, cl);\n  sum64(this.h, 6, dh, dl);\n  sum64(this.h, 8, eh, el);\n  sum64(this.h, 10, fh, fl);\n  sum64(this.h, 12, gh, gl);\n  sum64(this.h, 14, hh, hl);\n};\n\nSHA512$1.prototype._digest = function digest(enc) {\n  if (enc === 'hex') return utils$3.toHex32(this.h, 'big');else return utils$3.split32(this.h, 'big');\n};\n\nfunction ch64_hi(xh, xl, yh, yl, zh) {\n  var r = xh & yh ^ ~xh & zh;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction ch64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = xl & yl ^ ~xl & zl;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction maj64_hi(xh, xl, yh, yl, zh) {\n  var r = xh & yh ^ xh & zh ^ yh & zh;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction maj64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = xl & yl ^ xl & zl ^ yl & zl;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 28);\n  var c1_hi = rotr64_hi(xl, xh, 2); // 34\n\n  var c2_hi = rotr64_hi(xl, xh, 7); // 39\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 28);\n  var c1_lo = rotr64_lo(xl, xh, 2); // 34\n\n  var c2_lo = rotr64_lo(xl, xh, 7); // 39\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 14);\n  var c1_hi = rotr64_hi(xh, xl, 18);\n  var c2_hi = rotr64_hi(xl, xh, 9); // 41\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 14);\n  var c1_lo = rotr64_lo(xh, xl, 18);\n  var c2_lo = rotr64_lo(xl, xh, 9); // 41\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 1);\n  var c1_hi = rotr64_hi(xh, xl, 8);\n  var c2_hi = shr64_hi(xh, xl, 7);\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 1);\n  var c1_lo = rotr64_lo(xh, xl, 8);\n  var c2_lo = shr64_lo(xh, xl, 7);\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 19);\n  var c1_hi = rotr64_hi(xl, xh, 29); // 61\n\n  var c2_hi = shr64_hi(xh, xl, 6);\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 19);\n  var c1_lo = rotr64_lo(xl, xh, 29); // 61\n\n  var c2_lo = shr64_lo(xh, xl, 6);\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0) r += 0x100000000;\n  return r;\n}\n\nvar utils$2 = utils$9;\nvar SHA512 = _512;\n\nfunction SHA384() {\n  if (!(this instanceof SHA384)) return new SHA384();\n  SHA512.call(this);\n  this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];\n}\n\nutils$2.inherits(SHA384, SHA512);\nvar _384 = SHA384;\nSHA384.blockSize = 1024;\nSHA384.outSize = 384;\nSHA384.hmacStrength = 192;\nSHA384.padLength = 128;\n\nSHA384.prototype._digest = function digest(enc) {\n  if (enc === 'hex') return utils$2.toHex32(this.h.slice(0, 12), 'big');else return utils$2.split32(this.h.slice(0, 12), 'big');\n};\n\nsha.sha1 = _1;\nsha.sha224 = _224;\nsha.sha256 = _256;\nsha.sha384 = _384;\nsha.sha512 = _512;\nvar ripemd = {};\nvar utils$1 = utils$9;\nvar common = common$5;\nvar rotl32 = utils$1.rotl32;\nvar sum32 = utils$1.sum32;\nvar sum32_3 = utils$1.sum32_3;\nvar sum32_4 = utils$1.sum32_4;\nvar BlockHash = common.BlockHash;\n\nfunction RIPEMD160() {\n  if (!(this instanceof RIPEMD160)) return new RIPEMD160();\n  BlockHash.call(this);\n  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n  this.endian = 'little';\n}\n\nutils$1.inherits(RIPEMD160, BlockHash);\nripemd.ripemd160 = RIPEMD160;\nRIPEMD160.blockSize = 512;\nRIPEMD160.outSize = 160;\nRIPEMD160.hmacStrength = 192;\nRIPEMD160.padLength = 64;\n\nRIPEMD160.prototype._update = function update(msg, start) {\n  var A = this.h[0];\n  var B = this.h[1];\n  var C = this.h[2];\n  var D = this.h[3];\n  var E = this.h[4];\n  var Ah = A;\n  var Bh = B;\n  var Ch = C;\n  var Dh = D;\n  var Eh = E;\n\n  for (var j = 0; j < 80; j++) {\n    var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);\n    A = E;\n    E = D;\n    D = rotl32(C, 10);\n    C = B;\n    B = T;\n    T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);\n    Ah = Eh;\n    Eh = Dh;\n    Dh = rotl32(Ch, 10);\n    Ch = Bh;\n    Bh = T;\n  }\n\n  T = sum32_3(this.h[1], C, Dh);\n  this.h[1] = sum32_3(this.h[2], D, Eh);\n  this.h[2] = sum32_3(this.h[3], E, Ah);\n  this.h[3] = sum32_3(this.h[4], A, Bh);\n  this.h[4] = sum32_3(this.h[0], B, Ch);\n  this.h[0] = T;\n};\n\nRIPEMD160.prototype._digest = function digest(enc) {\n  if (enc === 'hex') return utils$1.toHex32(this.h, 'little');else return utils$1.split32(this.h, 'little');\n};\n\nfunction f(j, x, y, z) {\n  if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);\n}\n\nfunction K(j) {\n  if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;\n}\n\nfunction Kh(j) {\n  if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;\n}\n\nvar r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];\nvar rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];\nvar s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];\nvar sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];\nvar utils = utils$9;\nvar assert$1 = minimalisticAssert;\n\nfunction Hmac(hash, key, enc) {\n  if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);\n  this.Hash = hash;\n  this.blockSize = hash.blockSize / 8;\n  this.outSize = hash.outSize / 8;\n  this.inner = null;\n  this.outer = null;\n\n  this._init(utils.toArray(key, enc));\n}\n\nvar hmac = Hmac;\n\nHmac.prototype._init = function init(key) {\n  // Shorten key, if needed\n  if (key.length > this.blockSize) key = new this.Hash().update(key).digest();\n  assert$1(key.length <= this.blockSize); // Add padding to key\n\n  for (var i = key.length; i < this.blockSize; i++) {\n    key.push(0);\n  }\n\n  for (i = 0; i < key.length; i++) {\n    key[i] ^= 0x36;\n  }\n\n  this.inner = new this.Hash().update(key); // 0x36 ^ 0x5c = 0x6a\n\n  for (i = 0; i < key.length; i++) {\n    key[i] ^= 0x6a;\n  }\n\n  this.outer = new this.Hash().update(key);\n};\n\nHmac.prototype.update = function update(msg, enc) {\n  this.inner.update(msg, enc);\n  return this;\n};\n\nHmac.prototype.digest = function digest(enc) {\n  this.outer.update(this.inner.digest());\n  return this.outer.digest(enc);\n};\n\n(function (exports) {\n  var hash = exports;\n  hash.utils = utils$9;\n  hash.common = common$5;\n  hash.sha = sha;\n  hash.ripemd = ripemd;\n  hash.hmac = hmac; // Proxy hash functions to the main object\n\n  hash.sha1 = hash.sha.sha1;\n  hash.sha256 = hash.sha.sha256;\n  hash.sha224 = hash.sha.sha224;\n  hash.sha384 = hash.sha.sha384;\n  hash.sha512 = hash.sha.sha512;\n  hash.ripemd160 = hash.ripemd.ripemd160;\n})(hash$1);\n\nvar hash = hash$1;\nvar version$2 = \"logger/5.6.0\";\nvar _permanentCensorErrors = false;\nvar _censorErrors = false;\nvar LogLevels = {\n  debug: 1,\n  \"default\": 2,\n  info: 2,\n  warning: 3,\n  error: 4,\n  off: 5\n};\nvar _logLevel = LogLevels[\"default\"];\nvar _globalLogger = null;\n\nfunction _checkNormalize() {\n  try {\n    var missing = []; // Make sure all forms of normalization are supported\n\n    [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach(function (form) {\n      try {\n        if (\"test\".normalize(form) !== \"test\") {\n          throw new Error(\"bad normalize\");\n        }\n\n        ;\n      } catch (error) {\n        missing.push(form);\n      }\n    });\n\n    if (missing.length) {\n      throw new Error(\"missing \" + missing.join(\", \"));\n    }\n\n    if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n      throw new Error(\"broken implementation\");\n    }\n  } catch (error) {\n    return error.message;\n  }\n\n  return null;\n}\n\nvar _normalizeError = _checkNormalize();\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[\"DEBUG\"] = \"DEBUG\";\n  LogLevel[\"INFO\"] = \"INFO\";\n  LogLevel[\"WARNING\"] = \"WARNING\";\n  LogLevel[\"ERROR\"] = \"ERROR\";\n  LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\n\nvar ErrorCode;\n\n(function (ErrorCode) {\n  ///////////////////\n  // Generic Errors\n  // Unknown Error\n  ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\"; // Not Implemented\n\n  ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\"; // Unsupported Operation\n  //   - operation\n\n  ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\"; // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n  //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n\n  ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\"; // Some sort of bad response from the server\n\n  ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\"; // Timeout\n\n  ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\"; ///////////////////\n  // Operational  Errors\n  // Buffer Overrun\n\n  ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\"; // Numeric Fault\n  //   - operation: the operation being executed\n  //   - fault: the reason this faulted\n\n  ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\"; ///////////////////\n  // Argument Errors\n  // Missing new operator to an object\n  //  - name: The name of the class\n\n  ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\"; // Invalid argument (e.g. value is incompatible with type) to a function:\n  //   - argument: The argument name that was invalid\n  //   - value: The value of the argument\n\n  ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\"; // Missing argument to a function:\n  //   - count: The number of arguments received\n  //   - expectedCount: The number of arguments expected\n\n  ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\"; // Too many arguments\n  //   - count: The number of arguments received\n  //   - expectedCount: The number of arguments expected\n\n  ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\"; ///////////////////\n  // Blockchain Errors\n  // Call exception\n  //  - transaction: the transaction\n  //  - address?: the contract address\n  //  - args?: The arguments passed into the function\n  //  - method?: The Solidity method signature\n  //  - errorSignature?: The EIP848 error signature\n  //  - errorArgs?: The EIP848 error parameters\n  //  - reason: The reason (only for EIP848 \"Error(string)\")\n\n  ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\"; // Insufficient funds (< value + gasLimit * gasPrice)\n  //   - transaction: the transaction attempted\n\n  ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\"; // Nonce has already been used\n  //   - transaction: the transaction attempted\n\n  ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\"; // The replacement fee for the transaction is too low\n  //   - transaction: the transaction attempted\n\n  ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\"; // The gas limit could not be estimated\n  //   - transaction: the transaction passed to estimateGas\n\n  ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\"; // The transaction was replaced by one with a higher gas price\n  //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n  //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n  //   - hash: original transaction hash\n  //   - replacement: the full TransactionsResponse for the replacement\n  //   - receipt: the receipt of the replacement\n\n  ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n})(ErrorCode || (ErrorCode = {}));\n\nvar HEX = \"0123456789abcdef\";\n\nvar Logger = /*#__PURE__*/function () {\n  function Logger(version) {\n    _classCallCheck(this, Logger);\n\n    Object.defineProperty(this, \"version\", {\n      enumerable: true,\n      value: version,\n      writable: false\n    });\n  }\n\n  _createClass(Logger, [{\n    key: \"_log\",\n    value: function _log(logLevel, args) {\n      var level = logLevel.toLowerCase();\n\n      if (LogLevels[level] == null) {\n        this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n      }\n\n      if (_logLevel > LogLevels[level]) {\n        return;\n      }\n\n      console.log.apply(console, args);\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      this._log(Logger.levels.DEBUG, args);\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      this._log(Logger.levels.INFO, args);\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      this._log(Logger.levels.WARNING, args);\n    }\n  }, {\n    key: \"makeError\",\n    value: function makeError(message, code, params) {\n      // Errors are being censored\n      if (_censorErrors) {\n        return this.makeError(\"censored error\", code, {});\n      }\n\n      if (!code) {\n        code = Logger.errors.UNKNOWN_ERROR;\n      }\n\n      if (!params) {\n        params = {};\n      }\n\n      var messageDetails = [];\n      Object.keys(params).forEach(function (key) {\n        var value = params[key];\n\n        try {\n          if (value instanceof Uint8Array) {\n            var hex = \"\";\n\n            for (var i = 0; i < value.length; i++) {\n              hex += HEX[value[i] >> 4];\n              hex += HEX[value[i] & 0x0f];\n            }\n\n            messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n          } else {\n            messageDetails.push(key + \"=\" + JSON.stringify(value));\n          }\n        } catch (error) {\n          messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n        }\n      });\n      messageDetails.push(\"code=\".concat(code));\n      messageDetails.push(\"version=\".concat(this.version));\n      var reason = message;\n      var url = \"\";\n\n      switch (code) {\n        case ErrorCode.NUMERIC_FAULT:\n          {\n            url = \"NUMERIC_FAULT\";\n            var fault = message;\n\n            switch (fault) {\n              case \"overflow\":\n              case \"underflow\":\n              case \"division-by-zero\":\n                url += \"-\" + fault;\n                break;\n\n              case \"negative-power\":\n              case \"negative-width\":\n                url += \"-unsupported\";\n                break;\n\n              case \"unbound-bitwise-result\":\n                url += \"-unbound-result\";\n                break;\n            }\n\n            break;\n          }\n\n        case ErrorCode.CALL_EXCEPTION:\n        case ErrorCode.INSUFFICIENT_FUNDS:\n        case ErrorCode.MISSING_NEW:\n        case ErrorCode.NONCE_EXPIRED:\n        case ErrorCode.REPLACEMENT_UNDERPRICED:\n        case ErrorCode.TRANSACTION_REPLACED:\n        case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n          url = code;\n          break;\n      }\n\n      if (url) {\n        message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n      }\n\n      if (messageDetails.length) {\n        message += \" (\" + messageDetails.join(\", \") + \")\";\n      } // @TODO: Any??\n\n\n      var error = new Error(message);\n      error.reason = reason;\n      error.code = code;\n      Object.keys(params).forEach(function (key) {\n        error[key] = params[key];\n      });\n      return error;\n    }\n  }, {\n    key: \"throwError\",\n    value: function throwError(message, code, params) {\n      throw this.makeError(message, code, params);\n    }\n  }, {\n    key: \"throwArgumentError\",\n    value: function throwArgumentError(message, name, value) {\n      return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n        argument: name,\n        value: value\n      });\n    }\n  }, {\n    key: \"assert\",\n    value: function assert(condition, message, code, params) {\n      if (!!condition) {\n        return;\n      }\n\n      this.throwError(message, code, params);\n    }\n  }, {\n    key: \"assertArgument\",\n    value: function assertArgument(condition, message, name, value) {\n      if (!!condition) {\n        return;\n      }\n\n      this.throwArgumentError(message, name, value);\n    }\n  }, {\n    key: \"checkNormalize\",\n    value: function checkNormalize(message) {\n      if (_normalizeError) {\n        this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"String.prototype.normalize\",\n          form: _normalizeError\n        });\n      }\n    }\n  }, {\n    key: \"checkSafeUint53\",\n    value: function checkSafeUint53(value, message) {\n      if (typeof value !== \"number\") {\n        return;\n      }\n\n      if (message == null) {\n        message = \"value not safe\";\n      }\n\n      if (value < 0 || value >= 0x1fffffffffffff) {\n        this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n          operation: \"checkSafeInteger\",\n          fault: \"out-of-safe-range\",\n          value: value\n        });\n      }\n\n      if (value % 1) {\n        this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n          operation: \"checkSafeInteger\",\n          fault: \"non-integer\",\n          value: value\n        });\n      }\n    }\n  }, {\n    key: \"checkArgumentCount\",\n    value: function checkArgumentCount(count, expectedCount, message) {\n      if (message) {\n        message = \": \" + message;\n      } else {\n        message = \"\";\n      }\n\n      if (count < expectedCount) {\n        this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n          count: count,\n          expectedCount: expectedCount\n        });\n      }\n\n      if (count > expectedCount) {\n        this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n          count: count,\n          expectedCount: expectedCount\n        });\n      }\n    }\n  }, {\n    key: \"checkNew\",\n    value: function checkNew(target, kind) {\n      if (target === Object || target == null) {\n        this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n          name: kind.name\n        });\n      }\n    }\n  }, {\n    key: \"checkAbstract\",\n    value: function checkAbstract(target, kind) {\n      if (target === kind) {\n        this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, {\n          name: target.name,\n          operation: \"new\"\n        });\n      } else if (target === Object || target == null) {\n        this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n          name: kind.name\n        });\n      }\n    }\n  }], [{\n    key: \"globalLogger\",\n    value: function globalLogger() {\n      if (!_globalLogger) {\n        _globalLogger = new Logger(version$2);\n      }\n\n      return _globalLogger;\n    }\n  }, {\n    key: \"setCensorship\",\n    value: function setCensorship(censorship, permanent) {\n      if (!censorship && permanent) {\n        this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"setCensorship\"\n        });\n      }\n\n      if (_permanentCensorErrors) {\n        if (!censorship) {\n          return;\n        }\n\n        this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"setCensorship\"\n        });\n      }\n\n      _censorErrors = !!censorship;\n      _permanentCensorErrors = !!permanent;\n    }\n  }, {\n    key: \"setLogLevel\",\n    value: function setLogLevel(logLevel) {\n      var level = LogLevels[logLevel.toLowerCase()];\n\n      if (level == null) {\n        Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n        return;\n      }\n\n      _logLevel = level;\n    }\n  }, {\n    key: \"from\",\n    value: function from(version) {\n      return new Logger(version);\n    }\n  }]);\n\n  return Logger;\n}();\n\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\nvar version$1 = \"bytes/5.6.0\";\nvar logger = new Logger(version$1); ///////////////////////////////\n\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\n\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n  };\n\n  return array;\n}\n\nfunction isInteger(value) {\n  return typeof value === \"number\" && value == value && value % 1 === 0;\n}\n\nfunction isBytes(value) {\n  if (value == null) {\n    return false;\n  }\n\n  if (value.constructor === Uint8Array) {\n    return true;\n  }\n\n  if (typeof value === \"string\") {\n    return false;\n  }\n\n  if (!isInteger(value.length) || value.length < 0) {\n    return false;\n  }\n\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n\n    if (!isInteger(v) || v < 0 || v >= 256) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction arrayify(value, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid arrayify value\");\n    var result = [];\n\n    while (value) {\n      result.unshift(value & 0xff);\n      value = parseInt(String(value / 256));\n    }\n\n    if (result.length === 0) {\n      result.push(0);\n    }\n\n    return addSlice(new Uint8Array(result));\n  }\n\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n\n  if (isHexString(value)) {\n    var hex = value.substring(2);\n\n    if (hex.length % 2) {\n      if (options.hexPad === \"left\") {\n        hex = \"0x0\" + hex.substring(2);\n      } else if (options.hexPad === \"right\") {\n        hex += \"0\";\n      } else {\n        logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n      }\n    }\n\n    var _result = [];\n\n    for (var i = 0; i < hex.length; i += 2) {\n      _result.push(parseInt(hex.substring(i, i + 2), 16));\n    }\n\n    return addSlice(new Uint8Array(_result));\n  }\n\n  if (isBytes(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n\n  return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nfunction isHexString(value, length) {\n  if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  return true;\n}\n\nvar version = \"sha2/5.6.0\";\nnew Logger(version);\n\nfunction sha256(data) {\n  return \"0x\" + hash.sha256().update(arrayify(data)).digest(\"hex\");\n}\n\nvar Struct = /*#__PURE__*/function () {\n  function Struct(properties) {\n    _classCallCheck(this, Struct);\n\n    Object.assign(this, properties);\n  }\n\n  _createClass(Struct, [{\n    key: \"encode\",\n    value: function encode() {\n      return Buffer.from(serialize(SOLANA_SCHEMA, this));\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(data) {\n      return deserialize(SOLANA_SCHEMA, this, data);\n    }\n  }, {\n    key: \"decodeUnchecked\",\n    value: function decodeUnchecked(data) {\n      return deserializeUnchecked(SOLANA_SCHEMA, this, data);\n    }\n  }]);\n\n  return Struct;\n}(); // Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\n\n\nvar Enum = /*#__PURE__*/function (_Struct) {\n  _inherits(Enum, _Struct);\n\n  function Enum(properties) {\n    var _this;\n\n    _classCallCheck(this, Enum);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Enum).call(this, properties));\n    _this.enum = '';\n\n    if (Object.keys(properties).length !== 1) {\n      throw new Error('Enum can only take single value');\n    }\n\n    Object.keys(properties).map(function (key) {\n      _this.enum = key;\n    });\n    return _this;\n  }\n\n  return Enum;\n}(Struct);\n\nvar SOLANA_SCHEMA = new Map();\n/**\n * Maximum length of derived pubkey seed\n */\n\nvar MAX_SEED_LENGTH = 32;\n/**\n * Value to be converted into public key\n */\n\nfunction isPublicKeyData(value) {\n  return value._bn !== undefined;\n}\n/**\n * A public key\n */\n\n\nvar PublicKey = /*#__PURE__*/function (_Struct2) {\n  _inherits(PublicKey, _Struct2);\n\n  /** @internal */\n\n  /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */\n  function PublicKey(value) {\n    var _this2;\n\n    _classCallCheck(this, PublicKey);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PublicKey).call(this, {}));\n    _this2._bn = void 0;\n\n    if (isPublicKeyData(value)) {\n      _this2._bn = value._bn;\n    } else {\n      if (typeof value === 'string') {\n        // assume base 58 encoding by default\n        var decoded = bs58.decode(value);\n\n        if (decoded.length != 32) {\n          throw new Error(\"Invalid public key input\");\n        }\n\n        _this2._bn = new BN(decoded);\n      } else {\n        _this2._bn = new BN(value);\n      }\n\n      if (_this2._bn.byteLength() > 32) {\n        throw new Error(\"Invalid public key input\");\n      }\n    }\n\n    return _this2;\n  }\n  /**\n   * Default public key value. (All zeros)\n   */\n\n  /**\n   * Checks if two publicKeys are equal\n   */\n\n\n  _createClass(PublicKey, [{\n    key: \"equals\",\n    value: function equals(publicKey) {\n      return this._bn.eq(publicKey._bn);\n    }\n    /**\n     * Return the base-58 representation of the public key\n     */\n\n  }, {\n    key: \"toBase58\",\n    value: function toBase58() {\n      return bs58.encode(this.toBytes());\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toBase58();\n    }\n    /**\n     * Return the byte array representation of the public key\n     */\n\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      return this.toBuffer();\n    }\n    /**\n     * Return the Buffer representation of the public key\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      var b = this._bn.toArrayLike(Buffer);\n\n      if (b.length === 32) {\n        return b;\n      }\n\n      var zeroPad = Buffer.alloc(32);\n      b.copy(zeroPad, 32 - b.length);\n      return zeroPad;\n    }\n    /**\n     * Return the base-58 representation of the public key\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toBase58();\n    }\n    /**\n     * Derive a public key from another key, a seed, and a program ID.\n     * The program ID will also serve as the owner of the public key, giving\n     * it permission to write data to the account.\n     */\n\n    /* eslint-disable require-await */\n\n  }], [{\n    key: \"createWithSeed\",\n    value: function () {\n      var _createWithSeed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fromPublicKey, seed, programId) {\n        var buffer, hash;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);\n                hash = sha256(new Uint8Array(buffer)).slice(2);\n                return _context.abrupt(\"return\", new PublicKey(Buffer.from(hash, 'hex')));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function createWithSeed(_x, _x2, _x3) {\n        return _createWithSeed.apply(this, arguments);\n      }\n\n      return createWithSeed;\n    }()\n    /**\n     * Derive a program address from seeds and a program ID.\n     */\n\n    /* eslint-disable require-await */\n\n  }, {\n    key: \"createProgramAddressSync\",\n    value: function createProgramAddressSync(seeds, programId) {\n      var buffer = Buffer.alloc(0);\n      seeds.forEach(function (seed) {\n        if (seed.length > MAX_SEED_LENGTH) {\n          throw new TypeError(\"Max seed length exceeded\");\n        }\n\n        buffer = Buffer.concat([buffer, toBuffer(seed)]);\n      });\n      buffer = Buffer.concat([buffer, programId.toBuffer(), Buffer.from('ProgramDerivedAddress')]);\n      var hash = sha256(new Uint8Array(buffer)).slice(2);\n      var publicKeyBytes = new BN(hash, 16).toArray(undefined, 32);\n\n      if (is_on_curve(publicKeyBytes)) {\n        throw new Error(\"Invalid seeds, address must fall off the curve\");\n      }\n\n      return new PublicKey(publicKeyBytes);\n    }\n    /**\n     * Async version of createProgramAddressSync\n     * For backwards compatibility\n     */\n\n    /* eslint-disable require-await */\n\n  }, {\n    key: \"createProgramAddress\",\n    value: function () {\n      var _createProgramAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(seeds, programId) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.createProgramAddressSync(seeds, programId));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function createProgramAddress(_x4, _x5) {\n        return _createProgramAddress.apply(this, arguments);\n      }\n\n      return createProgramAddress;\n    }()\n    /**\n     * Find a valid program address\n     *\n     * Valid program addresses must fall off the ed25519 curve.  This function\n     * iterates a nonce until it finds one that when combined with the seeds\n     * results in a valid program address.\n     */\n\n  }, {\n    key: \"findProgramAddressSync\",\n    value: function findProgramAddressSync(seeds, programId) {\n      var nonce = 255;\n      var address;\n\n      while (nonce != 0) {\n        try {\n          var seedsWithNonce = seeds.concat(Buffer.from([nonce]));\n          address = this.createProgramAddressSync(seedsWithNonce, programId);\n        } catch (err) {\n          if (err instanceof TypeError) {\n            throw err;\n          }\n\n          nonce--;\n          continue;\n        }\n\n        return [address, nonce];\n      }\n\n      throw new Error(\"Unable to find a viable program address nonce\");\n    }\n    /**\n     * Async version of findProgramAddressSync\n     * For backwards compatibility\n     */\n\n  }, {\n    key: \"findProgramAddress\",\n    value: function () {\n      var _findProgramAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(seeds, programId) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.findProgramAddressSync(seeds, programId));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function findProgramAddress(_x6, _x7) {\n        return _findProgramAddress.apply(this, arguments);\n      }\n\n      return findProgramAddress;\n    }()\n    /**\n     * Check that a pubkey is on the ed25519 curve.\n     */\n\n  }, {\n    key: \"isOnCurve\",\n    value: function isOnCurve(pubkeyData) {\n      var pubkey = new PublicKey(pubkeyData);\n      return is_on_curve(pubkey.toBytes()) == 1;\n    }\n  }]);\n\n  return PublicKey;\n}(Struct);\n\nPublicKey.default = new PublicKey('11111111111111111111111111111111');\nSOLANA_SCHEMA.set(PublicKey, {\n  kind: 'struct',\n  fields: [['_bn', 'u256']]\n}); // @ts-ignore\n\nvar naclLowLevel = nacl.lowlevel; // Check that a pubkey is on the curve.\n// This function and its dependents were sourced from:\n// https://github.com/dchest/tweetnacl-js/blob/f1ec050ceae0861f34280e62498b1d3ed9c350c6/nacl.js#L792\n\nfunction is_on_curve(p) {\n  var r = [naclLowLevel.gf(), naclLowLevel.gf(), naclLowLevel.gf(), naclLowLevel.gf()];\n  var t = naclLowLevel.gf(),\n      chk = naclLowLevel.gf(),\n      num = naclLowLevel.gf(),\n      den = naclLowLevel.gf(),\n      den2 = naclLowLevel.gf(),\n      den4 = naclLowLevel.gf(),\n      den6 = naclLowLevel.gf();\n  naclLowLevel.set25519(r[2], gf1);\n  naclLowLevel.unpack25519(r[1], p);\n  naclLowLevel.S(num, r[1]);\n  naclLowLevel.M(den, num, naclLowLevel.D);\n  naclLowLevel.Z(num, num, r[2]);\n  naclLowLevel.A(den, r[2], den);\n  naclLowLevel.S(den2, den);\n  naclLowLevel.S(den4, den2);\n  naclLowLevel.M(den6, den4, den2);\n  naclLowLevel.M(t, den6, num);\n  naclLowLevel.M(t, t, den);\n  naclLowLevel.pow2523(t, t);\n  naclLowLevel.M(t, t, num);\n  naclLowLevel.M(t, t, den);\n  naclLowLevel.M(t, t, den);\n  naclLowLevel.M(r[0], t, den);\n  naclLowLevel.S(chk, r[0]);\n  naclLowLevel.M(chk, chk, den);\n  if (neq25519(chk, num)) naclLowLevel.M(r[0], r[0], I);\n  naclLowLevel.S(chk, r[0]);\n  naclLowLevel.M(chk, chk, den);\n  if (neq25519(chk, num)) return 0;\n  return 1;\n}\n\nvar gf1 = naclLowLevel.gf([1]);\nvar I = naclLowLevel.gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction neq25519(a, b) {\n  var c = new Uint8Array(32),\n      d = new Uint8Array(32);\n  naclLowLevel.pack25519(c, a);\n  naclLowLevel.pack25519(d, b);\n  return naclLowLevel.crypto_verify_32(c, 0, d, 0);\n}\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */\n\n\nvar Account = /*#__PURE__*/function () {\n  /** @internal */\n\n  /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */\n  function Account(secretKey) {\n    _classCallCheck(this, Account);\n\n    this._keypair = void 0;\n\n    if (secretKey) {\n      this._keypair = nacl.sign.keyPair.fromSecretKey(toBuffer(secretKey));\n    } else {\n      this._keypair = nacl.sign.keyPair();\n    }\n  }\n  /**\n   * The public key for this account\n   */\n\n\n  _createClass(Account, [{\n    key: \"publicKey\",\n    get: function get() {\n      return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n     * The **unencrypted** secret key for this account\n     */\n\n  }, {\n    key: \"secretKey\",\n    get: function get() {\n      return toBuffer(this._keypair.secretKey);\n    }\n  }]);\n\n  return Account;\n}();\n\nvar BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */\n\nvar PACKET_DATA_SIZE = 1280 - 40 - 8;\nvar SIGNATURE_LENGTH_IN_BYTES = 64;\n/**\n * Layout for a public key\n */\n\nvar publicKey = function publicKey() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';\n  return BufferLayout.blob(32, property);\n};\n/**\n * Layout for a Rust String type\n */\n\n\nvar rustString = function rustString() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'string';\n  var rsl = BufferLayout.struct([BufferLayout.u32('length'), BufferLayout.u32('lengthPadding'), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars')], property);\n\n  var _decode = rsl.decode.bind(rsl);\n\n  var _encode = rsl.encode.bind(rsl);\n\n  var rslShim = rsl;\n\n  rslShim.decode = function (b, offset) {\n    var data = _decode(b, offset);\n\n    return data['chars'].toString();\n  };\n\n  rslShim.encode = function (str, b, offset) {\n    var data = {\n      chars: Buffer.from(str, 'utf8')\n    };\n    return _encode(data, b, offset);\n  };\n\n  rslShim.alloc = function (str) {\n    return BufferLayout.u32().span + BufferLayout.u32().span + Buffer.from(str, 'utf8').length;\n  };\n\n  return rslShim;\n};\n/**\n * Layout for an Authorized object\n */\n\n\nvar authorized = function authorized() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'authorized';\n  return BufferLayout.struct([publicKey('staker'), publicKey('withdrawer')], property);\n};\n/**\n * Layout for a Lockup object\n */\n\n\nvar lockup = function lockup() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'lockup';\n  return BufferLayout.struct([BufferLayout.ns64('unixTimestamp'), BufferLayout.ns64('epoch'), publicKey('custodian')], property);\n};\n/**\n *  Layout for a VoteInit object\n */\n\n\nvar voteInit = function voteInit() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteInit';\n  return BufferLayout.struct([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), BufferLayout.u8('commission')], property);\n};\n\nfunction getAlloc(type, fields) {\n  var alloc = 0;\n  type.layout.fields.forEach(function (item) {\n    if (item.span >= 0) {\n      alloc += item.span;\n    } else if (typeof item.alloc === 'function') {\n      alloc += item.alloc(fields[item.property]);\n    }\n  });\n  return alloc;\n}\n\nfunction decodeLength(bytes) {\n  var len = 0;\n  var size = 0;\n\n  for (;;) {\n    var elem = bytes.shift();\n    len |= (elem & 0x7f) << size * 7;\n    size += 1;\n\n    if ((elem & 0x80) === 0) {\n      break;\n    }\n  }\n\n  return len;\n}\n\nfunction encodeLength(bytes, len) {\n  var rem_len = len;\n\n  for (;;) {\n    var elem = rem_len & 0x7f;\n    rem_len >>= 7;\n\n    if (rem_len == 0) {\n      bytes.push(elem);\n      break;\n    } else {\n      elem |= 0x80;\n      bytes.push(elem);\n    }\n  }\n}\n/**\n * The message header, identifying signed and read-only account\n */\n\n\nvar PUBKEY_LENGTH = 32;\n/**\n * List of instructions to be processed atomically\n */\n\nvar Message = /*#__PURE__*/function () {\n  function Message(args) {\n    var _this3 = this;\n\n    _classCallCheck(this, Message);\n\n    this.header = void 0;\n    this.accountKeys = void 0;\n    this.recentBlockhash = void 0;\n    this.instructions = void 0;\n    this.indexToProgramIds = new Map();\n    this.header = args.header;\n    this.accountKeys = args.accountKeys.map(function (account) {\n      return new PublicKey(account);\n    });\n    this.recentBlockhash = args.recentBlockhash;\n    this.instructions = args.instructions;\n    this.instructions.forEach(function (ix) {\n      return _this3.indexToProgramIds.set(ix.programIdIndex, _this3.accountKeys[ix.programIdIndex]);\n    });\n  }\n\n  _createClass(Message, [{\n    key: \"isAccountSigner\",\n    value: function isAccountSigner(index) {\n      return index < this.header.numRequiredSignatures;\n    }\n  }, {\n    key: \"isAccountWritable\",\n    value: function isAccountWritable(index) {\n      return index < this.header.numRequiredSignatures - this.header.numReadonlySignedAccounts || index >= this.header.numRequiredSignatures && index < this.accountKeys.length - this.header.numReadonlyUnsignedAccounts;\n    }\n  }, {\n    key: \"isProgramId\",\n    value: function isProgramId(index) {\n      return this.indexToProgramIds.has(index);\n    }\n  }, {\n    key: \"programIds\",\n    value: function programIds() {\n      return _toConsumableArray(this.indexToProgramIds.values());\n    }\n  }, {\n    key: \"nonProgramIds\",\n    value: function nonProgramIds() {\n      var _this4 = this;\n\n      return this.accountKeys.filter(function (_, index) {\n        return !_this4.isProgramId(index);\n      });\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var numKeys = this.accountKeys.length;\n      var keyCount = [];\n      encodeLength(keyCount, numKeys);\n      var instructions = this.instructions.map(function (instruction) {\n        var accounts = instruction.accounts,\n            programIdIndex = instruction.programIdIndex;\n        var data = Array.from(bs58.decode(instruction.data));\n        var keyIndicesCount = [];\n        encodeLength(keyIndicesCount, accounts.length);\n        var dataCount = [];\n        encodeLength(dataCount, data.length);\n        return {\n          programIdIndex: programIdIndex,\n          keyIndicesCount: Buffer.from(keyIndicesCount),\n          keyIndices: accounts,\n          dataLength: Buffer.from(dataCount),\n          data: data\n        };\n      });\n      var instructionCount = [];\n      encodeLength(instructionCount, instructions.length);\n      var instructionBuffer = Buffer.alloc(PACKET_DATA_SIZE);\n      Buffer.from(instructionCount).copy(instructionBuffer);\n      var instructionBufferLength = instructionCount.length;\n      instructions.forEach(function (instruction) {\n        var instructionLayout = BufferLayout.struct([BufferLayout.u8('programIdIndex'), BufferLayout.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), BufferLayout.seq(BufferLayout.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), BufferLayout.blob(instruction.dataLength.length, 'dataLength'), BufferLayout.seq(BufferLayout.u8('userdatum'), instruction.data.length, 'data')]);\n        var length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n        instructionBufferLength += length;\n      });\n      instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n      var signDataLayout = BufferLayout.struct([BufferLayout.blob(1, 'numRequiredSignatures'), BufferLayout.blob(1, 'numReadonlySignedAccounts'), BufferLayout.blob(1, 'numReadonlyUnsignedAccounts'), BufferLayout.blob(keyCount.length, 'keyCount'), BufferLayout.seq(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);\n      var transaction = {\n        numRequiredSignatures: Buffer.from([this.header.numRequiredSignatures]),\n        numReadonlySignedAccounts: Buffer.from([this.header.numReadonlySignedAccounts]),\n        numReadonlyUnsignedAccounts: Buffer.from([this.header.numReadonlyUnsignedAccounts]),\n        keyCount: Buffer.from(keyCount),\n        keys: this.accountKeys.map(function (key) {\n          return toBuffer(key.toBytes());\n        }),\n        recentBlockhash: bs58.decode(this.recentBlockhash)\n      };\n      var signData = Buffer.alloc(2048);\n      var length = signDataLayout.encode(transaction, signData);\n      instructionBuffer.copy(signData, length);\n      return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n     * Decode a compiled message into a Message object.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(buffer) {\n      // Slice up wire data\n      var byteArray = _toConsumableArray(buffer);\n\n      var numRequiredSignatures = byteArray.shift();\n      var numReadonlySignedAccounts = byteArray.shift();\n      var numReadonlyUnsignedAccounts = byteArray.shift();\n      var accountCount = decodeLength(byteArray);\n      var accountKeys = [];\n\n      for (var i = 0; i < accountCount; i++) {\n        var account = byteArray.slice(0, PUBKEY_LENGTH);\n        byteArray = byteArray.slice(PUBKEY_LENGTH);\n        accountKeys.push(bs58.encode(Buffer.from(account)));\n      }\n\n      var recentBlockhash = byteArray.slice(0, PUBKEY_LENGTH);\n      byteArray = byteArray.slice(PUBKEY_LENGTH);\n      var instructionCount = decodeLength(byteArray);\n      var instructions = [];\n\n      for (var _i = 0; _i < instructionCount; _i++) {\n        var programIdIndex = byteArray.shift();\n\n        var _accountCount = decodeLength(byteArray);\n\n        var accounts = byteArray.slice(0, _accountCount);\n        byteArray = byteArray.slice(_accountCount);\n        var dataLength = decodeLength(byteArray);\n        var dataSlice = byteArray.slice(0, dataLength);\n        var data = bs58.encode(Buffer.from(dataSlice));\n        byteArray = byteArray.slice(dataLength);\n        instructions.push({\n          programIdIndex: programIdIndex,\n          accounts: accounts,\n          data: data\n        });\n      }\n\n      var messageArgs = {\n        header: {\n          numRequiredSignatures: numRequiredSignatures,\n          numReadonlySignedAccounts: numReadonlySignedAccounts,\n          numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts\n        },\n        recentBlockhash: bs58.encode(Buffer.from(recentBlockhash)),\n        accountKeys: accountKeys,\n        instructions: instructions\n      };\n      return new Message(messageArgs);\n    }\n  }]);\n\n  return Message;\n}();\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\nvar TransactionStatus;\n/**\n * Default (empty) signature\n */\n\n(function (TransactionStatus) {\n  TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n  TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n  TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n})(TransactionStatus || (TransactionStatus = {}));\n\nvar DEFAULT_SIGNATURE = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n/**\n * Account metadata used to define instructions\n */\n\n/**\n * Transaction Instruction class\n */\n\nvar TransactionInstruction = /*#__PURE__*/function () {\n  /**\n   * Public keys to include in this transaction\n   * Boolean represents whether this pubkey needs to sign the transaction\n   */\n\n  /**\n   * Program Id to execute\n   */\n\n  /**\n   * Program input\n   */\n  function TransactionInstruction(opts) {\n    _classCallCheck(this, TransactionInstruction);\n\n    this.keys = void 0;\n    this.programId = void 0;\n    this.data = Buffer.alloc(0);\n    this.programId = opts.programId;\n    this.keys = opts.keys;\n\n    if (opts.data) {\n      this.data = opts.data;\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  _createClass(TransactionInstruction, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        keys: this.keys.map(function (_ref) {\n          var pubkey = _ref.pubkey,\n              isSigner = _ref.isSigner,\n              isWritable = _ref.isWritable;\n          return {\n            pubkey: pubkey.toJSON(),\n            isSigner: isSigner,\n            isWritable: isWritable\n          };\n        }),\n        programId: this.programId.toJSON(),\n        data: _toConsumableArray(this.data)\n      };\n    }\n  }]);\n\n  return TransactionInstruction;\n}();\n/**\n * Pair of signature and corresponding public key\n */\n\n/**\n * Transaction class\n */\n\n\nvar Transaction = /*#__PURE__*/function () {\n  _createClass(Transaction, [{\n    key: \"signature\",\n\n    /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */\n\n    /**\n     * The first (payer) Transaction signature\n     */\n    get: function get() {\n      if (this.signatures.length > 0) {\n        return this.signatures[0].signature;\n      }\n\n      return null;\n    }\n    /**\n     * The transaction fee payer\n     */\n\n    /**\n     * Construct an empty Transaction\n     */\n\n  }]);\n\n  function Transaction(opts) {\n    _classCallCheck(this, Transaction);\n\n    this.signatures = [];\n    this.feePayer = void 0;\n    this.instructions = [];\n    this.recentBlockhash = void 0;\n    this.lastValidBlockHeight = void 0;\n    this.nonceInfo = void 0;\n    this._message = void 0;\n    this._json = void 0;\n\n    if (!opts) {\n      return;\n    } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {\n      var newOpts = opts;\n      Object.assign(this, newOpts);\n      this.recentBlockhash = newOpts.blockhash;\n      this.lastValidBlockHeight = newOpts.lastValidBlockHeight;\n    } else {\n      var oldOpts = opts;\n      Object.assign(this, oldOpts);\n      this.recentBlockhash = oldOpts.recentBlockhash;\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  _createClass(Transaction, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        recentBlockhash: this.recentBlockhash || null,\n        feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n        nonceInfo: this.nonceInfo ? {\n          nonce: this.nonceInfo.nonce,\n          nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n        } : null,\n        instructions: this.instructions.map(function (instruction) {\n          return instruction.toJSON();\n        }),\n        signers: this.signatures.map(function (_ref2) {\n          var publicKey = _ref2.publicKey;\n          return publicKey.toJSON();\n        })\n      };\n    }\n    /**\n     * Add one or more instructions to this Transaction\n     */\n\n  }, {\n    key: \"add\",\n    value: function add() {\n      var _this5 = this;\n\n      for (var _len4 = arguments.length, items = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        items[_key4] = arguments[_key4];\n      }\n\n      if (items.length === 0) {\n        throw new Error('No instructions');\n      }\n\n      items.forEach(function (item) {\n        if ('instructions' in item) {\n          _this5.instructions = _this5.instructions.concat(item.instructions);\n        } else if ('data' in item && 'programId' in item && 'keys' in item) {\n          _this5.instructions.push(item);\n        } else {\n          _this5.instructions.push(new TransactionInstruction(item));\n        }\n      });\n      return this;\n    }\n    /**\n     * Compile transaction data\n     */\n\n  }, {\n    key: \"compileMessage\",\n    value: function compileMessage() {\n      if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n        return this._message;\n      }\n\n      var recentBlockhash;\n      var instructions;\n\n      if (this.nonceInfo) {\n        recentBlockhash = this.nonceInfo.nonce;\n\n        if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n          instructions = [this.nonceInfo.nonceInstruction].concat(_toConsumableArray(this.instructions));\n        } else {\n          instructions = this.instructions;\n        }\n      } else {\n        recentBlockhash = this.recentBlockhash;\n        instructions = this.instructions;\n      }\n\n      if (!recentBlockhash) {\n        throw new Error('Transaction recentBlockhash required');\n      }\n\n      if (instructions.length < 1) {\n        console.warn('No instructions provided');\n      }\n\n      var feePayer;\n\n      if (this.feePayer) {\n        feePayer = this.feePayer;\n      } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n        // Use implicit fee payer\n        feePayer = this.signatures[0].publicKey;\n      } else {\n        throw new Error('Transaction fee payer required');\n      }\n\n      for (var i = 0; i < instructions.length; i++) {\n        if (instructions[i].programId === undefined) {\n          throw new Error(\"Transaction instruction index \".concat(i, \" has undefined program id\"));\n        }\n      }\n\n      var programIds = [];\n      var accountMetas = [];\n      instructions.forEach(function (instruction) {\n        instruction.keys.forEach(function (accountMeta) {\n          accountMetas.push(_objectSpread({}, accountMeta));\n        });\n        var programId = instruction.programId.toString();\n\n        if (!programIds.includes(programId)) {\n          programIds.push(programId);\n        }\n      }); // Append programID account metas\n\n      programIds.forEach(function (programId) {\n        accountMetas.push({\n          pubkey: new PublicKey(programId),\n          isSigner: false,\n          isWritable: false\n        });\n      }); // Cull duplicate account metas\n\n      var uniqueMetas = [];\n      accountMetas.forEach(function (accountMeta) {\n        var pubkeyString = accountMeta.pubkey.toString();\n        var uniqueIndex = uniqueMetas.findIndex(function (x) {\n          return x.pubkey.toString() === pubkeyString;\n        });\n\n        if (uniqueIndex > -1) {\n          uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n          uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n        } else {\n          uniqueMetas.push(accountMeta);\n        }\n      }); // Sort. Prioritizing first by signer, then by writable\n\n      uniqueMetas.sort(function (x, y) {\n        if (x.isSigner !== y.isSigner) {\n          // Signers always come before non-signers\n          return x.isSigner ? -1 : 1;\n        }\n\n        if (x.isWritable !== y.isWritable) {\n          // Writable accounts always come before read-only accounts\n          return x.isWritable ? -1 : 1;\n        } // Otherwise, sort by pubkey, stringwise.\n\n\n        return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58());\n      }); // Move fee payer to the front\n\n      var feePayerIndex = uniqueMetas.findIndex(function (x) {\n        return x.pubkey.equals(feePayer);\n      });\n\n      if (feePayerIndex > -1) {\n        var _uniqueMetas$splice = uniqueMetas.splice(feePayerIndex, 1),\n            _uniqueMetas$splice2 = _slicedToArray(_uniqueMetas$splice, 1),\n            payerMeta = _uniqueMetas$splice2[0];\n\n        payerMeta.isSigner = true;\n        payerMeta.isWritable = true;\n        uniqueMetas.unshift(payerMeta);\n      } else {\n        uniqueMetas.unshift({\n          pubkey: feePayer,\n          isSigner: true,\n          isWritable: true\n        });\n      } // Disallow unknown signers\n\n\n      var _iterator = _createForOfIteratorHelper(this.signatures),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var signature = _step.value;\n          var uniqueIndex = uniqueMetas.findIndex(function (x) {\n            return x.pubkey.equals(signature.publicKey);\n          });\n\n          if (uniqueIndex > -1) {\n            if (!uniqueMetas[uniqueIndex].isSigner) {\n              uniqueMetas[uniqueIndex].isSigner = true;\n              console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');\n            }\n          } else {\n            throw new Error(\"unknown signer: \".concat(signature.publicKey.toString()));\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var numRequiredSignatures = 0;\n      var numReadonlySignedAccounts = 0;\n      var numReadonlyUnsignedAccounts = 0; // Split out signing from non-signing keys and count header values\n\n      var signedKeys = [];\n      var unsignedKeys = [];\n      uniqueMetas.forEach(function (_ref3) {\n        var pubkey = _ref3.pubkey,\n            isSigner = _ref3.isSigner,\n            isWritable = _ref3.isWritable;\n\n        if (isSigner) {\n          signedKeys.push(pubkey.toString());\n          numRequiredSignatures += 1;\n\n          if (!isWritable) {\n            numReadonlySignedAccounts += 1;\n          }\n        } else {\n          unsignedKeys.push(pubkey.toString());\n\n          if (!isWritable) {\n            numReadonlyUnsignedAccounts += 1;\n          }\n        }\n      });\n      var accountKeys = signedKeys.concat(unsignedKeys);\n      var compiledInstructions = instructions.map(function (instruction) {\n        var data = instruction.data,\n            programId = instruction.programId;\n        return {\n          programIdIndex: accountKeys.indexOf(programId.toString()),\n          accounts: instruction.keys.map(function (meta) {\n            return accountKeys.indexOf(meta.pubkey.toString());\n          }),\n          data: bs58.encode(data)\n        };\n      });\n      compiledInstructions.forEach(function (instruction) {\n        assert(instruction.programIdIndex >= 0);\n        instruction.accounts.forEach(function (keyIndex) {\n          return assert(keyIndex >= 0);\n        });\n      });\n      return new Message({\n        header: {\n          numRequiredSignatures: numRequiredSignatures,\n          numReadonlySignedAccounts: numReadonlySignedAccounts,\n          numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts\n        },\n        accountKeys: accountKeys,\n        recentBlockhash: recentBlockhash,\n        instructions: compiledInstructions\n      });\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_compile\",\n    value: function _compile() {\n      var message = this.compileMessage();\n      var signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n\n      if (this.signatures.length === signedKeys.length) {\n        var valid = this.signatures.every(function (pair, index) {\n          return signedKeys[index].equals(pair.publicKey);\n        });\n        if (valid) return message;\n      }\n\n      this.signatures = signedKeys.map(function (publicKey) {\n        return {\n          signature: null,\n          publicKey: publicKey\n        };\n      });\n      return message;\n    }\n    /**\n     * Get a buffer of the Transaction data that need to be covered by signatures\n     */\n\n  }, {\n    key: \"serializeMessage\",\n    value: function serializeMessage() {\n      return this._compile().serialize();\n    }\n    /**\n     * Get the estimated fee associated with a transaction\n     */\n\n  }, {\n    key: \"getEstimatedFee\",\n    value: function () {\n      var _getEstimatedFee = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(connection) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return connection.getFeeForMessage(this.compileMessage());\n\n              case 2:\n                return _context4.abrupt(\"return\", _context4.sent.value);\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getEstimatedFee(_x8) {\n        return _getEstimatedFee.apply(this, arguments);\n      }\n\n      return getEstimatedFee;\n    }()\n    /**\n     * Specify the public keys which will be used to sign the Transaction.\n     * The first signer will be used as the transaction fee payer account.\n     *\n     * Signatures can be added with either `partialSign` or `addSignature`\n     *\n     * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n     * specified and it can be set in the Transaction constructor or with the\n     * `feePayer` property.\n     */\n\n  }, {\n    key: \"setSigners\",\n    value: function setSigners() {\n      for (var _len5 = arguments.length, signers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        signers[_key5] = arguments[_key5];\n      }\n\n      if (signers.length === 0) {\n        throw new Error('No signers');\n      }\n\n      var seen = new Set();\n      this.signatures = signers.filter(function (publicKey) {\n        var key = publicKey.toString();\n\n        if (seen.has(key)) {\n          return false;\n        } else {\n          seen.add(key);\n          return true;\n        }\n      }).map(function (publicKey) {\n        return {\n          signature: null,\n          publicKey: publicKey\n        };\n      });\n    }\n    /**\n     * Sign the Transaction with the specified signers. Multiple signatures may\n     * be applied to a Transaction. The first signature is considered \"primary\"\n     * and is used identify and confirm transactions.\n     *\n     * If the Transaction `feePayer` is not set, the first signer will be used\n     * as the transaction fee payer account.\n     *\n     * Transaction fields should not be modified after the first call to `sign`,\n     * as doing so may invalidate the signature and cause the Transaction to be\n     * rejected.\n     *\n     * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign() {\n      for (var _len6 = arguments.length, signers = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        signers[_key6] = arguments[_key6];\n      }\n\n      if (signers.length === 0) {\n        throw new Error('No signers');\n      } // Dedupe signers\n\n\n      var seen = new Set();\n      var uniqueSigners = [];\n\n      for (var _i2 = 0, _signers = signers; _i2 < _signers.length; _i2++) {\n        var signer = _signers[_i2];\n        var key = signer.publicKey.toString();\n\n        if (seen.has(key)) {\n          continue;\n        } else {\n          seen.add(key);\n          uniqueSigners.push(signer);\n        }\n      }\n\n      this.signatures = uniqueSigners.map(function (signer) {\n        return {\n          signature: null,\n          publicKey: signer.publicKey\n        };\n      });\n\n      var message = this._compile();\n\n      this._partialSign.apply(this, [message].concat(uniqueSigners));\n    }\n    /**\n     * Partially sign a transaction with the specified accounts. All accounts must\n     * correspond to either the fee payer or a signer account in the transaction\n     * instructions.\n     *\n     * All the caveats from the `sign` method apply to `partialSign`\n     */\n\n  }, {\n    key: \"partialSign\",\n    value: function partialSign() {\n      for (var _len7 = arguments.length, signers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        signers[_key7] = arguments[_key7];\n      }\n\n      if (signers.length === 0) {\n        throw new Error('No signers');\n      } // Dedupe signers\n\n\n      var seen = new Set();\n      var uniqueSigners = [];\n\n      for (var _i3 = 0, _signers2 = signers; _i3 < _signers2.length; _i3++) {\n        var signer = _signers2[_i3];\n        var key = signer.publicKey.toString();\n\n        if (seen.has(key)) {\n          continue;\n        } else {\n          seen.add(key);\n          uniqueSigners.push(signer);\n        }\n      }\n\n      var message = this._compile();\n\n      this._partialSign.apply(this, [message].concat(uniqueSigners));\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_partialSign\",\n    value: function _partialSign(message) {\n      var _this6 = this;\n\n      var signData = message.serialize();\n\n      for (var _len8 = arguments.length, signers = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        signers[_key8 - 1] = arguments[_key8];\n      }\n\n      signers.forEach(function (signer) {\n        var signature = nacl.sign.detached(signData, signer.secretKey);\n\n        _this6._addSignature(signer.publicKey, toBuffer(signature));\n      });\n    }\n    /**\n     * Add an externally created signature to a transaction. The public key\n     * must correspond to either the fee payer or a signer account in the transaction\n     * instructions.\n     */\n\n  }, {\n    key: \"addSignature\",\n    value: function addSignature(pubkey, signature) {\n      this._compile(); // Ensure signatures array is populated\n\n\n      this._addSignature(pubkey, signature);\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_addSignature\",\n    value: function _addSignature(pubkey, signature) {\n      assert(signature.length === 64);\n      var index = this.signatures.findIndex(function (sigpair) {\n        return pubkey.equals(sigpair.publicKey);\n      });\n\n      if (index < 0) {\n        throw new Error(\"unknown signer: \".concat(pubkey.toString()));\n      }\n\n      this.signatures[index].signature = Buffer.from(signature);\n    }\n    /**\n     * Verify signatures of a complete, signed Transaction\n     */\n\n  }, {\n    key: \"verifySignatures\",\n    value: function verifySignatures() {\n      return this._verifySignatures(this.serializeMessage(), true);\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_verifySignatures\",\n    value: function _verifySignatures(signData, requireAllSignatures) {\n      var _iterator2 = _createForOfIteratorHelper(this.signatures),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _step2.value,\n              signature = _step2$value.signature,\n              _publicKey = _step2$value.publicKey;\n\n          if (signature === null) {\n            if (requireAllSignatures) {\n              return false;\n            }\n          } else {\n            if (!nacl.sign.detached.verify(signData, signature, _publicKey.toBuffer())) {\n              return false;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return true;\n    }\n    /**\n     * Serialize the Transaction in the wire format.\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize(config) {\n      var _Object$assign = Object.assign({\n        requireAllSignatures: true,\n        verifySignatures: true\n      }, config),\n          requireAllSignatures = _Object$assign.requireAllSignatures,\n          verifySignatures = _Object$assign.verifySignatures;\n\n      var signData = this.serializeMessage();\n\n      if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {\n        throw new Error('Signature verification failed');\n      }\n\n      return this._serialize(signData);\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_serialize\",\n    value: function _serialize(signData) {\n      var signatures = this.signatures;\n      var signatureCount = [];\n      encodeLength(signatureCount, signatures.length);\n      var transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n      var wireTransaction = Buffer.alloc(transactionLength);\n      assert(signatures.length < 256);\n      Buffer.from(signatureCount).copy(wireTransaction, 0);\n      signatures.forEach(function (_ref4, index) {\n        var signature = _ref4.signature;\n\n        if (signature !== null) {\n          assert(signature.length === 64, \"signature has invalid length\");\n          Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n        }\n      });\n      signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n      assert(wireTransaction.length <= PACKET_DATA_SIZE, \"Transaction too large: \".concat(wireTransaction.length, \" > \").concat(PACKET_DATA_SIZE));\n      return wireTransaction;\n    }\n    /**\n     * Deprecated method\n     * @internal\n     */\n\n  }, {\n    key: \"keys\",\n    get: function get() {\n      assert(this.instructions.length === 1);\n      return this.instructions[0].keys.map(function (keyObj) {\n        return keyObj.pubkey;\n      });\n    }\n    /**\n     * Deprecated method\n     * @internal\n     */\n\n  }, {\n    key: \"programId\",\n    get: function get() {\n      assert(this.instructions.length === 1);\n      return this.instructions[0].programId;\n    }\n    /**\n     * Deprecated method\n     * @internal\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      assert(this.instructions.length === 1);\n      return this.instructions[0].data;\n    }\n    /**\n     * Parse a wire transaction into a Transaction object.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(buffer) {\n      // Slice up wire data\n      var byteArray = _toConsumableArray(buffer);\n\n      var signatureCount = decodeLength(byteArray);\n      var signatures = [];\n\n      for (var i = 0; i < signatureCount; i++) {\n        var signature = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);\n        byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);\n        signatures.push(bs58.encode(Buffer.from(signature)));\n      }\n\n      return Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n     * Populate Transaction object from message and signatures\n     */\n\n  }, {\n    key: \"populate\",\n    value: function populate(message) {\n      var signatures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var transaction = new Transaction();\n      transaction.recentBlockhash = message.recentBlockhash;\n\n      if (message.header.numRequiredSignatures > 0) {\n        transaction.feePayer = message.accountKeys[0];\n      }\n\n      signatures.forEach(function (signature, index) {\n        var sigPubkeyPair = {\n          signature: signature == bs58.encode(DEFAULT_SIGNATURE) ? null : bs58.decode(signature),\n          publicKey: message.accountKeys[index]\n        };\n        transaction.signatures.push(sigPubkeyPair);\n      });\n      message.instructions.forEach(function (instruction) {\n        var keys = instruction.accounts.map(function (account) {\n          var pubkey = message.accountKeys[account];\n          return {\n            pubkey: pubkey,\n            isSigner: transaction.signatures.some(function (keyObj) {\n              return keyObj.publicKey.toString() === pubkey.toString();\n            }) || message.isAccountSigner(account),\n            isWritable: message.isAccountWritable(account)\n          };\n        });\n        transaction.instructions.push(new TransactionInstruction({\n          keys: keys,\n          programId: message.accountKeys[instruction.programIdIndex],\n          data: bs58.decode(instruction.data)\n        }));\n      });\n      transaction._message = message;\n      transaction._json = transaction.toJSON();\n      return transaction;\n    }\n  }]);\n\n  return Transaction;\n}();\n\nvar SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\nvar SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');\nvar SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');\nvar SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');\nvar SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');\nvar SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');\nvar SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');\nvar SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');\nvar SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\n\nfunction sendAndConfirmTransaction(_x9, _x10, _x11, _x12) {\n  return _sendAndConfirmTransaction.apply(this, arguments);\n} // zzz\n\n\nfunction _sendAndConfirmTransaction() {\n  _sendAndConfirmTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee94(connection, transaction, signers, options) {\n    var sendOptions, signature, status;\n    return _regeneratorRuntime().wrap(function _callee94$(_context94) {\n      while (1) {\n        switch (_context94.prev = _context94.next) {\n          case 0:\n            sendOptions = options && {\n              skipPreflight: options.skipPreflight,\n              preflightCommitment: options.preflightCommitment || options.commitment,\n              maxRetries: options.maxRetries,\n              minContextSlot: options.minContextSlot\n            };\n            _context94.next = 3;\n            return connection.sendTransaction(transaction, signers, sendOptions);\n\n          case 3:\n            signature = _context94.sent;\n\n            if (!(transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null)) {\n              _context94.next = 10;\n              break;\n            }\n\n            _context94.next = 7;\n            return connection.confirmTransaction({\n              signature: signature,\n              blockhash: transaction.recentBlockhash,\n              lastValidBlockHeight: transaction.lastValidBlockHeight\n            }, options && options.commitment);\n\n          case 7:\n            _context94.t0 = _context94.sent.value;\n            _context94.next = 13;\n            break;\n\n          case 10:\n            _context94.next = 12;\n            return connection.confirmTransaction(signature, options && options.commitment);\n\n          case 12:\n            _context94.t0 = _context94.sent.value;\n\n          case 13:\n            status = _context94.t0;\n\n            if (!status.err) {\n              _context94.next = 16;\n              break;\n            }\n\n            throw new Error(\"Transaction \".concat(signature, \" failed (\").concat(JSON.stringify(status), \")\"));\n\n          case 16:\n            return _context94.abrupt(\"return\", signature);\n\n          case 17:\n          case \"end\":\n            return _context94.stop();\n        }\n      }\n    }, _callee94);\n  }));\n  return _sendAndConfirmTransaction.apply(this, arguments);\n}\n\nfunction sleep(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\n/**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */\n\n\nfunction encodeData(type, fields) {\n  var allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n  var data = Buffer.alloc(allocLength);\n  var layoutFields = Object.assign({\n    instruction: type.index\n  }, fields);\n  type.layout.encode(layoutFields, data);\n  return data;\n}\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */\n\n\nfunction decodeData(type, buffer) {\n  var data;\n\n  try {\n    data = type.layout.decode(buffer);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n\n  if (data.instruction !== type.index) {\n    throw new Error(\"invalid instruction; instruction index mismatch \".concat(data.instruction, \" != \").concat(type.index));\n  }\n\n  return data;\n}\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */\n\n\nvar FeeCalculatorLayout = BufferLayout.nu64('lamportsPerSignature');\n/**\n * Calculator for transaction fees.\n */\n\n/**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */\n\nvar NonceAccountLayout = BufferLayout.struct([BufferLayout.u32('version'), BufferLayout.u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), BufferLayout.struct([FeeCalculatorLayout], 'feeCalculator')]);\nvar NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n/**\n * NonceAccount class\n */\n\nvar NonceAccount = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function NonceAccount(args) {\n    _classCallCheck(this, NonceAccount);\n\n    this.authorizedPubkey = void 0;\n    this.nonce = void 0;\n    this.feeCalculator = void 0;\n    this.authorizedPubkey = args.authorizedPubkey;\n    this.nonce = args.nonce;\n    this.feeCalculator = args.feeCalculator;\n  }\n  /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */\n\n\n  _createClass(NonceAccount, null, [{\n    key: \"fromAccountData\",\n    value: function fromAccountData(buffer) {\n      var nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n      return new NonceAccount({\n        authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n        nonce: new PublicKey(nonceAccount.nonce).toString(),\n        feeCalculator: nonceAccount.feeCalculator\n      });\n    }\n  }]);\n\n  return NonceAccount;\n}();\n\nvar encodeDecode = function encodeDecode(layout) {\n  var decode = layout.decode.bind(layout);\n  var encode = layout.encode.bind(layout);\n  return {\n    decode: decode,\n    encode: encode\n  };\n};\n\nvar bigInt = function bigInt(length) {\n  return function (property) {\n    var layout = blob(length, property);\n\n    var _encodeDecode = encodeDecode(layout),\n        encode = _encodeDecode.encode,\n        decode = _encodeDecode.decode;\n\n    var bigIntLayout = layout;\n\n    bigIntLayout.decode = function (buffer, offset) {\n      var src = decode(buffer, offset);\n      return toBigIntLE(Buffer.from(src));\n    };\n\n    bigIntLayout.encode = function (bigInt, buffer, offset) {\n      var src = toBufferLE(bigInt, length);\n      return encode(src, buffer, offset);\n    };\n\n    return bigIntLayout;\n  };\n};\n\nvar u64 = bigInt(8);\n/**\n * Create account system transaction params\n */\n\n/**\n * System Instruction class\n */\n\nvar SystemInstruction = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function SystemInstruction() {\n    _classCallCheck(this, SystemInstruction);\n  }\n  /**\n   * Decode a system instruction and retrieve the instruction type.\n   */\n\n\n  _createClass(SystemInstruction, null, [{\n    key: \"decodeInstructionType\",\n    value: function decodeInstructionType(instruction) {\n      this.checkProgramId(instruction.programId);\n      var instructionTypeLayout = BufferLayout.u32('instruction');\n      var typeIndex = instructionTypeLayout.decode(instruction.data);\n      var type;\n\n      for (var _i4 = 0, _Object$entries = Object.entries(SYSTEM_INSTRUCTION_LAYOUTS); _i4 < _Object$entries.length; _i4++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i4], 2),\n            ixType = _Object$entries$_i[0],\n            layout = _Object$entries$_i[1];\n\n        if (layout.index == typeIndex) {\n          type = ixType;\n          break;\n        }\n      }\n\n      if (!type) {\n        throw new Error('Instruction type incorrect; not a SystemInstruction');\n      }\n\n      return type;\n    }\n    /**\n     * Decode a create account system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeCreateAccount\",\n    value: function decodeCreateAccount(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n\n      var _decodeData = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data),\n          lamports = _decodeData.lamports,\n          space = _decodeData.space,\n          programId = _decodeData.programId;\n\n      return {\n        fromPubkey: instruction.keys[0].pubkey,\n        newAccountPubkey: instruction.keys[1].pubkey,\n        lamports: lamports,\n        space: space,\n        programId: new PublicKey(programId)\n      };\n    }\n    /**\n     * Decode a transfer system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeTransfer\",\n    value: function decodeTransfer(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n\n      var _decodeData2 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data),\n          lamports = _decodeData2.lamports;\n\n      return {\n        fromPubkey: instruction.keys[0].pubkey,\n        toPubkey: instruction.keys[1].pubkey,\n        lamports: lamports\n      };\n    }\n    /**\n     * Decode a transfer with seed system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeTransferWithSeed\",\n    value: function decodeTransferWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n\n      var _decodeData3 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data),\n          lamports = _decodeData3.lamports,\n          seed = _decodeData3.seed,\n          programId = _decodeData3.programId;\n\n      return {\n        fromPubkey: instruction.keys[0].pubkey,\n        basePubkey: instruction.keys[1].pubkey,\n        toPubkey: instruction.keys[2].pubkey,\n        lamports: lamports,\n        seed: seed,\n        programId: new PublicKey(programId)\n      };\n    }\n    /**\n     * Decode an allocate system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeAllocate\",\n    value: function decodeAllocate(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 1);\n\n      var _decodeData4 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data),\n          space = _decodeData4.space;\n\n      return {\n        accountPubkey: instruction.keys[0].pubkey,\n        space: space\n      };\n    }\n    /**\n     * Decode an allocate with seed system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeAllocateWithSeed\",\n    value: function decodeAllocateWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 1);\n\n      var _decodeData5 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data),\n          base = _decodeData5.base,\n          seed = _decodeData5.seed,\n          space = _decodeData5.space,\n          programId = _decodeData5.programId;\n\n      return {\n        accountPubkey: instruction.keys[0].pubkey,\n        basePubkey: new PublicKey(base),\n        seed: seed,\n        space: space,\n        programId: new PublicKey(programId)\n      };\n    }\n    /**\n     * Decode an assign system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeAssign\",\n    value: function decodeAssign(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 1);\n\n      var _decodeData6 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data),\n          programId = _decodeData6.programId;\n\n      return {\n        accountPubkey: instruction.keys[0].pubkey,\n        programId: new PublicKey(programId)\n      };\n    }\n    /**\n     * Decode an assign with seed system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeAssignWithSeed\",\n    value: function decodeAssignWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 1);\n\n      var _decodeData7 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data),\n          base = _decodeData7.base,\n          seed = _decodeData7.seed,\n          programId = _decodeData7.programId;\n\n      return {\n        accountPubkey: instruction.keys[0].pubkey,\n        basePubkey: new PublicKey(base),\n        seed: seed,\n        programId: new PublicKey(programId)\n      };\n    }\n    /**\n     * Decode a create account with seed system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeCreateWithSeed\",\n    value: function decodeCreateWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n\n      var _decodeData8 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data),\n          base = _decodeData8.base,\n          seed = _decodeData8.seed,\n          lamports = _decodeData8.lamports,\n          space = _decodeData8.space,\n          programId = _decodeData8.programId;\n\n      return {\n        fromPubkey: instruction.keys[0].pubkey,\n        newAccountPubkey: instruction.keys[1].pubkey,\n        basePubkey: new PublicKey(base),\n        seed: seed,\n        lamports: lamports,\n        space: space,\n        programId: new PublicKey(programId)\n      };\n    }\n    /**\n     * Decode a nonce initialize system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeNonceInitialize\",\n    value: function decodeNonceInitialize(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n\n      var _decodeData9 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data),\n          authorized = _decodeData9.authorized;\n\n      return {\n        noncePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: new PublicKey(authorized)\n      };\n    }\n    /**\n     * Decode a nonce advance system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeNonceAdvance\",\n    value: function decodeNonceAdvance(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n      return {\n        noncePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: instruction.keys[2].pubkey\n      };\n    }\n    /**\n     * Decode a nonce withdraw system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeNonceWithdraw\",\n    value: function decodeNonceWithdraw(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 5);\n\n      var _decodeData10 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data),\n          lamports = _decodeData10.lamports;\n\n      return {\n        noncePubkey: instruction.keys[0].pubkey,\n        toPubkey: instruction.keys[1].pubkey,\n        authorizedPubkey: instruction.keys[4].pubkey,\n        lamports: lamports\n      };\n    }\n    /**\n     * Decode a nonce authorize system instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeNonceAuthorize\",\n    value: function decodeNonceAuthorize(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n\n      var _decodeData11 = decodeData(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data),\n          authorized = _decodeData11.authorized;\n\n      return {\n        noncePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: instruction.keys[1].pubkey,\n        newAuthorizedPubkey: new PublicKey(authorized)\n      };\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"checkProgramId\",\n    value: function checkProgramId(programId) {\n      if (!programId.equals(SystemProgram.programId)) {\n        throw new Error('invalid instruction; programId is not SystemProgram');\n      }\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"checkKeyLength\",\n    value: function checkKeyLength(keys, expectedLength) {\n      if (keys.length < expectedLength) {\n        throw new Error(\"invalid instruction; found \".concat(keys.length, \" keys, expected at least \").concat(expectedLength));\n      }\n    }\n  }]);\n\n  return SystemInstruction;\n}();\n/**\n * An enumeration of valid SystemInstructionType's\n */\n\n/**\n * An enumeration of valid system InstructionType's\n * @internal\n */\n\n\nvar SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n  Create: {\n    index: 0,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports'), BufferLayout.ns64('space'), publicKey('programId')])\n  },\n  Assign: {\n    index: 1,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('programId')])\n  },\n  Transfer: {\n    index: 2,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), u64('lamports')])\n  },\n  CreateWithSeed: {\n    index: 3,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout.ns64('lamports'), BufferLayout.ns64('space'), publicKey('programId')])\n  },\n  AdvanceNonceAccount: {\n    index: 4,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction')])\n  },\n  WithdrawNonceAccount: {\n    index: 5,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])\n  },\n  InitializeNonceAccount: {\n    index: 6,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('authorized')])\n  },\n  AuthorizeNonceAccount: {\n    index: 7,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('authorized')])\n  },\n  Allocate: {\n    index: 8,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('space')])\n  },\n  AllocateWithSeed: {\n    index: 9,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout.ns64('space'), publicKey('programId')])\n  },\n  AssignWithSeed: {\n    index: 10,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])\n  },\n  TransferWithSeed: {\n    index: 11,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])\n  },\n  UpgradeNonceAccount: {\n    index: 12,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction')])\n  }\n});\n/**\n * Factory class for transactions to interact with the System program\n */\n\nvar SystemProgram = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function SystemProgram() {\n    _classCallCheck(this, SystemProgram);\n  }\n  /**\n   * Public key that identifies the System program\n   */\n\n  /**\n   * Generate a transaction instruction that creates a new account\n   */\n\n\n  _createClass(SystemProgram, null, [{\n    key: \"createAccount\",\n    value: function createAccount(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n      var data = encodeData(type, {\n        lamports: params.lamports,\n        space: params.space,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: params.fromPubkey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: params.newAccountPubkey,\n          isSigner: true,\n          isWritable: true\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a transaction instruction that transfers lamports from one account to another\n     */\n\n  }, {\n    key: \"transfer\",\n    value: function transfer(params) {\n      var data;\n      var keys;\n\n      if ('basePubkey' in params) {\n        var _type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n        data = encodeData(_type, {\n          lamports: BigInt(params.lamports),\n          seed: params.seed,\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.fromPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        }, {\n          pubkey: params.toPubkey,\n          isSigner: false,\n          isWritable: true\n        }];\n      } else {\n        var _type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n        data = encodeData(_type2, {\n          lamports: BigInt(params.lamports)\n        });\n        keys = [{\n          pubkey: params.fromPubkey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: params.toPubkey,\n          isSigner: false,\n          isWritable: true\n        }];\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a transaction instruction that assigns an account to a program\n     */\n\n  }, {\n    key: \"assign\",\n    value: function assign(params) {\n      var data;\n      var keys;\n\n      if ('basePubkey' in params) {\n        var _type3 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n        data = encodeData(_type3, {\n          base: toBuffer(params.basePubkey.toBuffer()),\n          seed: params.seed,\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        }];\n      } else {\n        var _type4 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n        data = encodeData(_type4, {\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: true,\n          isWritable: true\n        }];\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a transaction instruction that creates a new account at\n     *   an address generated with `from`, a seed, and programId\n     */\n\n  }, {\n    key: \"createAccountWithSeed\",\n    value: function createAccountWithSeed(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n      var data = encodeData(type, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        lamports: params.lamports,\n        space: params.space,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      var keys = [{\n        pubkey: params.fromPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: params.newAccountPubkey,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (params.basePubkey != params.fromPubkey) {\n        keys.push({\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a transaction that creates a new Nonce account\n     */\n\n  }, {\n    key: \"createNonceAccount\",\n    value: function createNonceAccount(params) {\n      var transaction = new Transaction();\n\n      if ('basePubkey' in params && 'seed' in params) {\n        transaction.add(SystemProgram.createAccountWithSeed({\n          fromPubkey: params.fromPubkey,\n          newAccountPubkey: params.noncePubkey,\n          basePubkey: params.basePubkey,\n          seed: params.seed,\n          lamports: params.lamports,\n          space: NONCE_ACCOUNT_LENGTH,\n          programId: this.programId\n        }));\n      } else {\n        transaction.add(SystemProgram.createAccount({\n          fromPubkey: params.fromPubkey,\n          newAccountPubkey: params.noncePubkey,\n          lamports: params.lamports,\n          space: NONCE_ACCOUNT_LENGTH,\n          programId: this.programId\n        }));\n      }\n\n      var initParams = {\n        noncePubkey: params.noncePubkey,\n        authorizedPubkey: params.authorizedPubkey\n      };\n      transaction.add(this.nonceInitialize(initParams));\n      return transaction;\n    }\n    /**\n     * Generate an instruction to initialize a Nonce account\n     */\n\n  }, {\n    key: \"nonceInitialize\",\n    value: function nonceInitialize(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n      var data = encodeData(type, {\n        authorized: toBuffer(params.authorizedPubkey.toBuffer())\n      });\n      var instructionData = {\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n    /**\n     * Generate an instruction to advance the nonce in a Nonce account\n     */\n\n  }, {\n    key: \"nonceAdvance\",\n    value: function nonceAdvance(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n      var data = encodeData(type);\n      var instructionData = {\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: params.authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n    /**\n     * Generate a transaction instruction that withdraws lamports from a Nonce account\n     */\n\n  }, {\n    key: \"nonceWithdraw\",\n    value: function nonceWithdraw(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n      var data = encodeData(type, {\n        lamports: params.lamports\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.toPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: params.authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a transaction instruction that authorizes a new PublicKey as the authority\n     * on a Nonce account.\n     */\n\n  }, {\n    key: \"nonceAuthorize\",\n    value: function nonceAuthorize(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n      var data = encodeData(type, {\n        authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a transaction instruction that allocates space in an account without funding\n     */\n\n  }, {\n    key: \"allocate\",\n    value: function allocate(params) {\n      var data;\n      var keys;\n\n      if ('basePubkey' in params) {\n        var _type5 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n        data = encodeData(_type5, {\n          base: toBuffer(params.basePubkey.toBuffer()),\n          seed: params.seed,\n          space: params.space,\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        }];\n      } else {\n        var _type6 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n        data = encodeData(_type6, {\n          space: params.space\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: true,\n          isWritable: true\n        }];\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n  }]);\n\n  return SystemProgram;\n}();\n\nSystemProgram.programId = new PublicKey('11111111111111111111111111111111'); // rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\n\nvar CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n/**\n * Program loader interface\n */\n\nvar Loader = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function Loader() {\n    _classCallCheck(this, Loader);\n  }\n  /**\n   * Amount of program data placed in each load Transaction\n   */\n\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n\n\n  _createClass(Loader, null, [{\n    key: \"getMinNumSignatures\",\n    value: function getMinNumSignatures(dataLength) {\n      return 2 * ( // Every transaction requires two signatures (payer + program)\n      Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction\n      1) // Add one for Finalize transaction\n      ;\n    }\n    /**\n     * Loads a generic program\n     *\n     * @param connection The connection to use\n     * @param payer System account that pays to load the program\n     * @param program Account to load the program into\n     * @param programId Public key that identifies the loader\n     * @param data Program octets\n     * @return true if program was loaded successfully, false if program was already loaded\n     */\n\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(connection, payer, program, programId, data) {\n        var balanceNeeded, programInfo, transaction, dataLayout, chunkSize, offset, array, transactions, bytes, _data, _transaction, REQUESTS_PER_SECOND, _dataLayout, _data2, _transaction2;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return connection.getMinimumBalanceForRentExemption(data.length);\n\n              case 2:\n                balanceNeeded = _context5.sent;\n                _context5.next = 5;\n                return connection.getAccountInfo(program.publicKey, 'confirmed');\n\n              case 5:\n                programInfo = _context5.sent;\n                transaction = null;\n\n                if (!(programInfo !== null)) {\n                  _context5.next = 16;\n                  break;\n                }\n\n                if (!programInfo.executable) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                console.error('Program load failed, account is already executable');\n                return _context5.abrupt(\"return\", false);\n\n              case 11:\n                if (programInfo.data.length !== data.length) {\n                  transaction = transaction || new Transaction();\n                  transaction.add(SystemProgram.allocate({\n                    accountPubkey: program.publicKey,\n                    space: data.length\n                  }));\n                }\n\n                if (!programInfo.owner.equals(programId)) {\n                  transaction = transaction || new Transaction();\n                  transaction.add(SystemProgram.assign({\n                    accountPubkey: program.publicKey,\n                    programId: programId\n                  }));\n                }\n\n                if (programInfo.lamports < balanceNeeded) {\n                  transaction = transaction || new Transaction();\n                  transaction.add(SystemProgram.transfer({\n                    fromPubkey: payer.publicKey,\n                    toPubkey: program.publicKey,\n                    lamports: balanceNeeded - programInfo.lamports\n                  }));\n                }\n\n                _context5.next = 17;\n                break;\n\n              case 16:\n                transaction = new Transaction().add(SystemProgram.createAccount({\n                  fromPubkey: payer.publicKey,\n                  newAccountPubkey: program.publicKey,\n                  lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                  space: data.length,\n                  programId: programId\n                }));\n\n              case 17:\n                if (!(transaction !== null)) {\n                  _context5.next = 20;\n                  break;\n                }\n\n                _context5.next = 20;\n                return sendAndConfirmTransaction(connection, transaction, [payer, program], {\n                  commitment: 'confirmed'\n                });\n\n              case 20:\n                dataLayout = BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.u32('offset'), BufferLayout.u32('bytesLength'), BufferLayout.u32('bytesLengthPadding'), BufferLayout.seq(BufferLayout.u8('byte'), BufferLayout.offset(BufferLayout.u32(), -8), 'bytes')]);\n                chunkSize = Loader.chunkSize;\n                offset = 0;\n                array = data;\n                transactions = [];\n\n              case 25:\n                if (!(array.length > 0)) {\n                  _context5.next = 39;\n                  break;\n                }\n\n                bytes = array.slice(0, chunkSize);\n                _data = Buffer.alloc(chunkSize + 16);\n                dataLayout.encode({\n                  instruction: 0,\n                  // Load instruction\n                  offset: offset,\n                  bytes: bytes,\n                  bytesLength: 0,\n                  bytesLengthPadding: 0\n                }, _data);\n                _transaction = new Transaction().add({\n                  keys: [{\n                    pubkey: program.publicKey,\n                    isSigner: true,\n                    isWritable: true\n                  }],\n                  programId: programId,\n                  data: _data\n                });\n                transactions.push(sendAndConfirmTransaction(connection, _transaction, [payer, program], {\n                  commitment: 'confirmed'\n                })); // Delay between sends in an attempt to reduce rate limit errors\n\n                if (!connection._rpcEndpoint.includes('solana.com')) {\n                  _context5.next = 35;\n                  break;\n                }\n\n                REQUESTS_PER_SECOND = 4;\n                _context5.next = 35;\n                return sleep(1000 / REQUESTS_PER_SECOND);\n\n              case 35:\n                offset += chunkSize;\n                array = array.slice(chunkSize);\n                _context5.next = 25;\n                break;\n\n              case 39:\n                _context5.next = 41;\n                return Promise.all(transactions);\n\n              case 41:\n                _dataLayout = BufferLayout.struct([BufferLayout.u32('instruction')]);\n                _data2 = Buffer.alloc(_dataLayout.span);\n\n                _dataLayout.encode({\n                  instruction: 1 // Finalize instruction\n\n                }, _data2);\n\n                _transaction2 = new Transaction().add({\n                  keys: [{\n                    pubkey: program.publicKey,\n                    isSigner: true,\n                    isWritable: true\n                  }, {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                  }],\n                  programId: programId,\n                  data: _data2\n                });\n                _context5.next = 47;\n                return sendAndConfirmTransaction(connection, _transaction2, [payer, program], {\n                  commitment: 'confirmed'\n                });\n\n              case 47:\n                return _context5.abrupt(\"return\", true);\n\n              case 48:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function load(_x13, _x14, _x15, _x16, _x17) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }]);\n\n  return Loader;\n}();\n\nLoader.chunkSize = CHUNK_SIZE;\nvar BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');\n/**\n * Factory class for transactions to interact with a program loader\n */\n\nvar BpfLoader = /*#__PURE__*/function () {\n  function BpfLoader() {\n    _classCallCheck(this, BpfLoader);\n  }\n\n  _createClass(BpfLoader, null, [{\n    key: \"getMinNumSignatures\",\n\n    /**\n     * Minimum number of signatures required to load a program not including\n     * retries\n     *\n     * Can be used to calculate transaction fees\n     */\n    value: function getMinNumSignatures(dataLength) {\n      return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n     * Load a BPF program\n     *\n     * @param connection The connection to use\n     * @param payer Account that will pay program loading fees\n     * @param program Account to load the program into\n     * @param elf The entire ELF containing the BPF program\n     * @param loaderProgramId The program id of the BPF loader to use\n     * @return true if program was loaded successfully, false if program was already loaded\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(connection, payer, program, elf, loaderProgramId) {\n      return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n  }]);\n\n  return BpfLoader;\n}();\n/**\n * Compute Budget Instruction class\n */\n\n\nvar ComputeBudgetInstruction = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function ComputeBudgetInstruction() {\n    _classCallCheck(this, ComputeBudgetInstruction);\n  }\n  /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */\n\n\n  _createClass(ComputeBudgetInstruction, null, [{\n    key: \"decodeInstructionType\",\n    value: function decodeInstructionType(instruction) {\n      this.checkProgramId(instruction.programId);\n      var instructionTypeLayout = BufferLayout.u8('instruction');\n      var typeIndex = instructionTypeLayout.decode(instruction.data);\n      var type;\n\n      for (var _i5 = 0, _Object$entries2 = Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS); _i5 < _Object$entries2.length; _i5++) {\n        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i5], 2),\n            ixType = _Object$entries2$_i[0],\n            layout = _Object$entries2$_i[1];\n\n        if (layout.index == typeIndex) {\n          type = ixType;\n          break;\n        }\n      }\n\n      if (!type) {\n        throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');\n      }\n\n      return type;\n    }\n    /**\n     * Decode request units compute budget instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeRequestUnits\",\n    value: function decodeRequestUnits(instruction) {\n      this.checkProgramId(instruction.programId);\n\n      var _decodeData12 = decodeData(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data),\n          units = _decodeData12.units,\n          additionalFee = _decodeData12.additionalFee;\n\n      return {\n        units: units,\n        additionalFee: additionalFee\n      };\n    }\n    /**\n     * Decode request heap frame compute budget instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeRequestHeapFrame\",\n    value: function decodeRequestHeapFrame(instruction) {\n      this.checkProgramId(instruction.programId);\n\n      var _decodeData13 = decodeData(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data),\n          bytes = _decodeData13.bytes;\n\n      return {\n        bytes: bytes\n      };\n    }\n    /**\n     * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeSetComputeUnitLimit\",\n    value: function decodeSetComputeUnitLimit(instruction) {\n      this.checkProgramId(instruction.programId);\n\n      var _decodeData14 = decodeData(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data),\n          units = _decodeData14.units;\n\n      return {\n        units: units\n      };\n    }\n    /**\n     * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeSetComputeUnitPrice\",\n    value: function decodeSetComputeUnitPrice(instruction) {\n      this.checkProgramId(instruction.programId);\n\n      var _decodeData15 = decodeData(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data),\n          microLamports = _decodeData15.microLamports;\n\n      return {\n        microLamports: microLamports\n      };\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"checkProgramId\",\n    value: function checkProgramId(programId) {\n      if (!programId.equals(ComputeBudgetProgram.programId)) {\n        throw new Error('invalid instruction; programId is not ComputeBudgetProgram');\n      }\n    }\n  }]);\n\n  return ComputeBudgetInstruction;\n}();\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */\n\n/**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */\n\n\nvar COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n  RequestUnits: {\n    index: 0,\n    layout: BufferLayout.struct([BufferLayout.u8('instruction'), BufferLayout.u32('units'), BufferLayout.u32('additionalFee')])\n  },\n  RequestHeapFrame: {\n    index: 1,\n    layout: BufferLayout.struct([BufferLayout.u8('instruction'), BufferLayout.u32('bytes')])\n  },\n  SetComputeUnitLimit: {\n    index: 2,\n    layout: BufferLayout.struct([BufferLayout.u8('instruction'), BufferLayout.u32('units')])\n  },\n  SetComputeUnitPrice: {\n    index: 3,\n    layout: BufferLayout.struct([BufferLayout.u8('instruction'), u64('microLamports')])\n  }\n});\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */\n\nvar ComputeBudgetProgram = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function ComputeBudgetProgram() {\n    _classCallCheck(this, ComputeBudgetProgram);\n  }\n  /**\n   * Public key that identifies the Compute Budget program\n   */\n\n\n  _createClass(ComputeBudgetProgram, null, [{\n    key: \"requestUnits\",\n    value: function requestUnits(params) {\n      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n      var data = encodeData(type, params);\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }, {\n    key: \"requestHeapFrame\",\n    value: function requestHeapFrame(params) {\n      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n      var data = encodeData(type, params);\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }, {\n    key: \"setComputeUnitLimit\",\n    value: function setComputeUnitLimit(params) {\n      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n      var data = encodeData(type, params);\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }, {\n    key: \"setComputeUnitPrice\",\n    value: function setComputeUnitPrice(params) {\n      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n      var data = encodeData(type, {\n        microLamports: BigInt(params.microLamports)\n      });\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }]);\n\n  return ComputeBudgetProgram;\n}();\n\nComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');\nvar objToString = Object.prototype.toString;\n\nvar objKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var name in obj) {\n    keys.push(name);\n  }\n\n  return keys;\n};\n\nfunction stringify(val, isArrayProp) {\n  var i, max, str, keys, key, propVal, toStr;\n\n  if (val === true) {\n    return \"true\";\n  }\n\n  if (val === false) {\n    return \"false\";\n  }\n\n  switch (typeof val) {\n    case \"object\":\n      if (val === null) {\n        return null;\n      } else if (val.toJSON && typeof val.toJSON === \"function\") {\n        return stringify(val.toJSON(), isArrayProp);\n      } else {\n        toStr = objToString.call(val);\n\n        if (toStr === \"[object Array]\") {\n          str = '[';\n          max = val.length - 1;\n\n          for (i = 0; i < max; i++) {\n            str += stringify(val[i], true) + ',';\n          }\n\n          if (max > -1) {\n            str += stringify(val[i], true);\n          }\n\n          return str + ']';\n        } else if (toStr === \"[object Object]\") {\n          // only object is left\n          keys = objKeys(val).sort();\n          max = keys.length;\n          str = \"\";\n          i = 0;\n\n          while (i < max) {\n            key = keys[i];\n            propVal = stringify(val[key], false);\n\n            if (propVal !== undefined) {\n              if (str) {\n                str += ',';\n              }\n\n              str += JSON.stringify(key) + ':' + propVal;\n            }\n\n            i++;\n          }\n\n          return '{' + str + '}';\n        } else {\n          return JSON.stringify(val);\n        }\n      }\n\n    case \"function\":\n    case \"undefined\":\n      return isArrayProp ? null : undefined;\n\n    case \"string\":\n      return JSON.stringify(val);\n\n    default:\n      return isFinite(val) ? val : null;\n  }\n}\n\nvar fastStableStringify = function fastStableStringify(val) {\n  var returnVal = stringify(val, false);\n\n  if (returnVal !== undefined) {\n    return '' + returnVal;\n  }\n};\n\nvar fastStableStringify$1 = fastStableStringify;\nvar MINIMUM_SLOT_PER_EPOCH = 32; // Returns the number of trailing zeros in the binary representation of self.\n\nfunction trailingZeros(n) {\n  var trailingZeros = 0;\n\n  while (n > 1) {\n    n /= 2;\n    trailingZeros++;\n  }\n\n  return trailingZeros;\n} // Returns the smallest power of two greater than or equal to n\n\n\nfunction nextPowerOfTwo(n) {\n  if (n === 0) return 1;\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n  return n + 1;\n}\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link connection.getEpochSchedule} method\n */\n\n\nvar EpochSchedule = /*#__PURE__*/function () {\n  /** The maximum number of slots in each epoch */\n\n  /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */\n\n  /** Indicates whether epochs start short and grow */\n\n  /** The first epoch with `slotsPerEpoch` slots */\n\n  /** The first slot of `firstNormalEpoch` */\n  function EpochSchedule(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {\n    _classCallCheck(this, EpochSchedule);\n\n    this.slotsPerEpoch = void 0;\n    this.leaderScheduleSlotOffset = void 0;\n    this.warmup = void 0;\n    this.firstNormalEpoch = void 0;\n    this.firstNormalSlot = void 0;\n    this.slotsPerEpoch = slotsPerEpoch;\n    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n    this.warmup = warmup;\n    this.firstNormalEpoch = firstNormalEpoch;\n    this.firstNormalSlot = firstNormalSlot;\n  }\n\n  _createClass(EpochSchedule, [{\n    key: \"getEpoch\",\n    value: function getEpoch(slot) {\n      return this.getEpochAndSlotIndex(slot)[0];\n    }\n  }, {\n    key: \"getEpochAndSlotIndex\",\n    value: function getEpochAndSlotIndex(slot) {\n      if (slot < this.firstNormalSlot) {\n        var epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n        var epochLen = this.getSlotsInEpoch(epoch);\n        var slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n        return [epoch, slotIndex];\n      } else {\n        var normalSlotIndex = slot - this.firstNormalSlot;\n        var normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n\n        var _epoch = this.firstNormalEpoch + normalEpochIndex;\n\n        var _slotIndex = normalSlotIndex % this.slotsPerEpoch;\n\n        return [_epoch, _slotIndex];\n      }\n    }\n  }, {\n    key: \"getFirstSlotInEpoch\",\n    value: function getFirstSlotInEpoch(epoch) {\n      if (epoch <= this.firstNormalEpoch) {\n        return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n      } else {\n        return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n      }\n    }\n  }, {\n    key: \"getLastSlotInEpoch\",\n    value: function getLastSlotInEpoch(epoch) {\n      return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n  }, {\n    key: \"getSlotsInEpoch\",\n    value: function getSlotsInEpoch(epoch) {\n      if (epoch < this.firstNormalEpoch) {\n        return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n      } else {\n        return this.slotsPerEpoch;\n      }\n    }\n  }]);\n\n  return EpochSchedule;\n}();\n\nvar SendTransactionError = /*#__PURE__*/function (_Error) {\n  _inherits(SendTransactionError, _Error);\n\n  function SendTransactionError(message, logs) {\n    var _this7;\n\n    _classCallCheck(this, SendTransactionError);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(SendTransactionError).call(this, message));\n    _this7.logs = void 0;\n    _this7.logs = logs;\n    return _this7;\n  }\n\n  return SendTransactionError;\n}(_wrapNativeSuper(Error));\n\nvar fetchImpl = globalThis.fetch; // TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n\n/**\n * @internal\n */\n\nvar NUM_TICKS_PER_SECOND = 160;\n/**\n * @internal\n */\n\nvar DEFAULT_TICKS_PER_SLOT = 64;\n/**\n * @internal\n */\n\nvar NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n/**\n * @internal\n */\n\nvar MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\n\nvar TransactionExpiredBlockheightExceededError = /*#__PURE__*/function (_Error2) {\n  _inherits(TransactionExpiredBlockheightExceededError, _Error2);\n\n  function TransactionExpiredBlockheightExceededError(signature) {\n    var _this8;\n\n    _classCallCheck(this, TransactionExpiredBlockheightExceededError);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(TransactionExpiredBlockheightExceededError).call(this, \"Signature \".concat(signature, \" has expired: block height exceeded.\")));\n    _this8.signature = void 0;\n    _this8.signature = signature;\n    return _this8;\n  }\n\n  return TransactionExpiredBlockheightExceededError;\n}(_wrapNativeSuper(Error));\n\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {\n  value: 'TransactionExpiredBlockheightExceededError'\n});\n\nvar TransactionExpiredTimeoutError = /*#__PURE__*/function (_Error3) {\n  _inherits(TransactionExpiredTimeoutError, _Error3);\n\n  function TransactionExpiredTimeoutError(signature, timeoutSeconds) {\n    var _this9;\n\n    _classCallCheck(this, TransactionExpiredTimeoutError);\n\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(TransactionExpiredTimeoutError).call(this, \"Transaction was not confirmed in \".concat(timeoutSeconds.toFixed(2), \" seconds. It is \") + 'unknown if it succeeded or failed. Check signature ' + \"\".concat(signature, \" using the Solana Explorer or CLI tools.\")));\n    _this9.signature = void 0;\n    _this9.signature = signature;\n    return _this9;\n  }\n\n  return TransactionExpiredTimeoutError;\n}(_wrapNativeSuper(Error));\n\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {\n  value: 'TransactionExpiredTimeoutError'\n});\n\nfunction makeWebsocketUrl(endpoint) {\n  var url = new URL(endpoint);\n  var useHttps = url.protocol === 'https:';\n  url.protocol = useHttps ? 'wss:' : 'ws:';\n  url.host = ''; // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n  // is explictly specifying the endpoint port (HTTP-based RPC), assuming\n  // we're directly trying to connect to solana-validator's ws listening port.\n  // When the endpoint omits the port, we're connecting to the protocol\n  // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n  // proxy which manages WebSocket upgrade and backend port redirection.\n\n  if (url.port !== '') {\n    url.port = String(Number(url.port) + 1);\n  }\n\n  return url.toString();\n}\n\nvar _process$env$npm_pack;\n\nvar PublicKeyFromString = coerce(instance(PublicKey), string(), function (value) {\n  return new PublicKey(value);\n});\nvar RawAccountDataResult = tuple([string(), literal('base64')]);\nvar BufferFromRawAccountData = coerce(instance(Buffer), RawAccountDataResult, function (value) {\n  return Buffer.from(value[0], 'base64');\n});\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */\n\nvar BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */\n\n/** @internal */\n\nfunction extractCommitmentFromConfig(commitmentOrConfig) {\n  var commitment;\n  var config;\n\n  if (typeof commitmentOrConfig === 'string') {\n    commitment = commitmentOrConfig;\n  } else if (commitmentOrConfig) {\n    var specifiedCommitment = commitmentOrConfig.commitment,\n        specifiedConfig = _objectWithoutProperties(commitmentOrConfig, [\"commitment\"]);\n\n    commitment = specifiedCommitment;\n    config = specifiedConfig;\n  }\n\n  return {\n    commitment: commitment,\n    config: config\n  };\n}\n/**\n * @internal\n */\n\n\nfunction createRpcResult(result) {\n  return union([type({\n    jsonrpc: literal('2.0'),\n    id: string(),\n    result: result\n  }), type({\n    jsonrpc: literal('2.0'),\n    id: string(),\n    error: type({\n      code: unknown(),\n      message: string(),\n      data: optional(any())\n    })\n  })]);\n}\n\nvar UnknownRpcResult = createRpcResult(unknown());\n/**\n * @internal\n */\n\nfunction jsonRpcResult(schema) {\n  return coerce(createRpcResult(schema), UnknownRpcResult, function (value) {\n    if ('error' in value) {\n      return value;\n    } else {\n      return _objectSpread({}, value, {\n        result: create(value.result, schema)\n      });\n    }\n  });\n}\n/**\n * @internal\n */\n\n\nfunction jsonRpcResultAndContext(value) {\n  return jsonRpcResult(type({\n    context: type({\n      slot: number()\n    }),\n    value: value\n  }));\n}\n/**\n * @internal\n */\n\n\nfunction notificationResultAndContext(value) {\n  return type({\n    context: type({\n      slot: number()\n    }),\n    value: value\n  });\n}\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\n\n\nvar GetInflationGovernorResult = type({\n  foundation: number(),\n  foundationTerm: number(),\n  initial: number(),\n  taper: number(),\n  terminal: number()\n});\n/**\n * The inflation reward for an epoch\n */\n\n/**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */\n\nvar GetInflationRewardResult = jsonRpcResult(array(nullable(type({\n  epoch: number(),\n  effectiveSlot: number(),\n  amount: number(),\n  postBalance: number()\n}))));\n/**\n * Information about the current epoch\n */\n\nvar GetEpochInfoResult = type({\n  epoch: number(),\n  slotIndex: number(),\n  slotsInEpoch: number(),\n  absoluteSlot: number(),\n  blockHeight: optional(number()),\n  transactionCount: optional(number())\n});\nvar GetEpochScheduleResult = type({\n  slotsPerEpoch: number(),\n  leaderScheduleSlotOffset: number(),\n  warmup: boolean(),\n  firstNormalEpoch: number(),\n  firstNormalSlot: number()\n});\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */\n\nvar GetLeaderScheduleResult = record(string(), array(number()));\n/**\n * Transaction error or null\n */\n\nvar TransactionErrorResult = nullable(union([type({}), string()]));\n/**\n * Signature status for a transaction\n */\n\nvar SignatureStatusResult = type({\n  err: TransactionErrorResult\n});\n/**\n * Transaction signature received notification\n */\n\nvar SignatureReceivedResult = literal('receivedSignature');\n/**\n * Version info for a node\n */\n\nvar VersionResult = type({\n  'solana-core': string(),\n  'feature-set': optional(number())\n});\nvar SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({\n  err: nullable(union([type({}), string()])),\n  logs: nullable(array(string())),\n  accounts: optional(nullable(array(nullable(type({\n    executable: boolean(),\n    owner: string(),\n    lamports: number(),\n    data: array(string()),\n    rentEpoch: optional(number())\n  }))))),\n  unitsConsumed: optional(number())\n}));\n/**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */\n\nvar BlockProductionResponseStruct = jsonRpcResultAndContext(type({\n  byIdentity: record(string(), array(number())),\n  range: type({\n    firstSlot: number(),\n    lastSlot: number()\n  })\n}));\n/**\n * A performance sample\n */\n\nfunction createRpcClient(url, useHttps, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit) {\n  var fetch = customFetch ? customFetch : fetchImpl;\n  var fetchWithMiddleware;\n\n  if (fetchMiddleware) {\n    fetchWithMiddleware = /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(info, init) {\n        var modifiedFetchArgs;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return new Promise(function (resolve, reject) {\n                  try {\n                    fetchMiddleware(info, init, function (modifiedInfo, modifiedInit) {\n                      return resolve([modifiedInfo, modifiedInit]);\n                    });\n                  } catch (error) {\n                    reject(error);\n                  }\n                });\n\n              case 2:\n                modifiedFetchArgs = _context6.sent;\n                _context6.next = 5;\n                return fetch.apply(void 0, _toConsumableArray(modifiedFetchArgs));\n\n              case 5:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      return function fetchWithMiddleware(_x18, _x19) {\n        return _ref5.apply(this, arguments);\n      };\n    }();\n  }\n\n  var clientBrowser = new RpcClient( /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request, callback) {\n      var agent, options, too_many_requests_retries, res, waitTime, text;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              agent = undefined;\n              options = {\n                method: 'POST',\n                body: request,\n                agent: agent,\n                headers: Object.assign({\n                  'Content-Type': 'application/json'\n                }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n              };\n              _context7.prev = 2;\n              too_many_requests_retries = 5;\n              waitTime = 500;\n\n            case 5:\n              if (!fetchWithMiddleware) {\n                _context7.next = 11;\n                break;\n              }\n\n              _context7.next = 8;\n              return fetchWithMiddleware(url, options);\n\n            case 8:\n              res = _context7.sent;\n              _context7.next = 14;\n              break;\n\n            case 11:\n              _context7.next = 13;\n              return fetch(url, options);\n\n            case 13:\n              res = _context7.sent;\n\n            case 14:\n              if (!(res.status !== 429\n              /* Too many requests */\n              )) {\n                _context7.next = 16;\n                break;\n              }\n\n              return _context7.abrupt(\"break\", 27);\n\n            case 16:\n              if (!(disableRetryOnRateLimit === true)) {\n                _context7.next = 18;\n                break;\n              }\n\n              return _context7.abrupt(\"break\", 27);\n\n            case 18:\n              too_many_requests_retries -= 1;\n\n              if (!(too_many_requests_retries === 0)) {\n                _context7.next = 21;\n                break;\n              }\n\n              return _context7.abrupt(\"break\", 27);\n\n            case 21:\n              console.log(\"Server responded with \".concat(res.status, \" \").concat(res.statusText, \".  Retrying after \").concat(waitTime, \"ms delay...\"));\n              _context7.next = 24;\n              return sleep(waitTime);\n\n            case 24:\n              waitTime *= 2;\n\n            case 25:\n              _context7.next = 5;\n              break;\n\n            case 27:\n              _context7.next = 29;\n              return res.text();\n\n            case 29:\n              text = _context7.sent;\n\n              if (res.ok) {\n                callback(null, text);\n              } else {\n                callback(new Error(\"\".concat(res.status, \" \").concat(res.statusText, \": \").concat(text)));\n              }\n\n              _context7.next = 36;\n              break;\n\n            case 33:\n              _context7.prev = 33;\n              _context7.t0 = _context7[\"catch\"](2);\n              if (_context7.t0 instanceof Error) callback(_context7.t0);\n\n            case 36:\n              _context7.prev = 36;\n              return _context7.finish(36);\n\n            case 38:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, null, [[2, 33, 36, 38]]);\n    }));\n\n    return function (_x20, _x21) {\n      return _ref6.apply(this, arguments);\n    };\n  }(), {});\n  return clientBrowser;\n}\n\nfunction createRpcRequest(client) {\n  return function (method, args) {\n    return new Promise(function (resolve, reject) {\n      client.request(method, args, function (err, response) {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(response);\n      });\n    });\n  };\n}\n\nfunction createRpcBatchRequest(client) {\n  return function (requests) {\n    return new Promise(function (resolve, reject) {\n      // Do nothing if requests is empty\n      if (requests.length === 0) resolve([]);\n      var batch = requests.map(function (params) {\n        return client.request(params.methodName, params.args);\n      });\n      client.request(batch, function (err, response) {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(response);\n      });\n    });\n  };\n}\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */\n\n\nvar GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */\n\nvar GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */\n\nvar GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */\n\nvar GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */\n\nvar SlotRpcResult = jsonRpcResult(number());\n/**\n * Supply\n */\n\n/**\n * Expected JSON RPC response for the \"getSupply\" message\n */\n\nvar GetSupplyRpcResult = jsonRpcResultAndContext(type({\n  total: number(),\n  circulating: number(),\n  nonCirculating: number(),\n  nonCirculatingAccounts: array(PublicKeyFromString)\n}));\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */\n\n/**\n * Expected JSON RPC structure for token amounts\n */\n\nvar TokenAmountResult = type({\n  amount: string(),\n  uiAmount: nullable(number()),\n  decimals: number(),\n  uiAmountString: optional(string())\n});\n/**\n * Token address and balance.\n */\n\n/**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */\n\nvar GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({\n  address: PublicKeyFromString,\n  amount: string(),\n  uiAmount: nullable(number()),\n  decimals: number(),\n  uiAmountString: optional(string())\n})));\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */\n\nvar GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({\n  pubkey: PublicKeyFromString,\n  account: type({\n    executable: boolean(),\n    owner: PublicKeyFromString,\n    lamports: number(),\n    data: BufferFromRawAccountData,\n    rentEpoch: number()\n  })\n})));\nvar ParsedAccountDataResult = type({\n  program: string(),\n  parsed: unknown(),\n  space: number()\n});\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */\n\nvar GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({\n  pubkey: PublicKeyFromString,\n  account: type({\n    executable: boolean(),\n    owner: PublicKeyFromString,\n    lamports: number(),\n    data: ParsedAccountDataResult,\n    rentEpoch: number()\n  })\n})));\n/**\n * Pair of an account address and its balance\n */\n\n/**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */\n\nvar GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({\n  lamports: number(),\n  address: PublicKeyFromString\n})));\n/**\n * @internal\n */\n\nvar AccountInfoResult = type({\n  executable: boolean(),\n  owner: PublicKeyFromString,\n  lamports: number(),\n  data: BufferFromRawAccountData,\n  rentEpoch: number()\n});\n/**\n * @internal\n */\n\nvar KeyedAccountInfoResult = type({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult\n});\nvar ParsedOrRawAccountData = coerce(union([instance(Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), function (value) {\n  if (Array.isArray(value)) {\n    return create(value, BufferFromRawAccountData);\n  } else {\n    return value;\n  }\n});\n/**\n * @internal\n */\n\nvar ParsedAccountInfoResult = type({\n  executable: boolean(),\n  owner: PublicKeyFromString,\n  lamports: number(),\n  data: ParsedOrRawAccountData,\n  rentEpoch: number()\n});\nvar KeyedParsedAccountInfoResult = type({\n  pubkey: PublicKeyFromString,\n  account: ParsedAccountInfoResult\n});\n/**\n * @internal\n */\n\nvar StakeActivationResult = type({\n  state: union([literal('active'), literal('inactive'), literal('activating'), literal('deactivating')]),\n  active: number(),\n  inactive: number()\n});\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */\n\nvar GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({\n  signature: string(),\n  slot: number(),\n  err: TransactionErrorResult,\n  memo: nullable(string()),\n  blockTime: optional(nullable(number()))\n})));\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */\n\nvar GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({\n  signature: string(),\n  slot: number(),\n  err: TransactionErrorResult,\n  memo: nullable(string()),\n  blockTime: optional(nullable(number()))\n})));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */\n\nvar AccountNotificationResult = type({\n  subscription: number(),\n  result: notificationResultAndContext(AccountInfoResult)\n});\n/**\n * @internal\n */\n\nvar ProgramAccountInfoResult = type({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */\n\nvar ProgramAccountNotificationResult = type({\n  subscription: number(),\n  result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n/**\n * @internal\n */\n\nvar SlotInfoResult = type({\n  parent: number(),\n  slot: number(),\n  root: number()\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */\n\nvar SlotNotificationResult = type({\n  subscription: number(),\n  result: SlotInfoResult\n});\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */\n\n/**\n * @internal\n */\n\nvar SlotUpdateResult = union([type({\n  type: union([literal('firstShredReceived'), literal('completed'), literal('optimisticConfirmation'), literal('root')]),\n  slot: number(),\n  timestamp: number()\n}), type({\n  type: literal('createdBank'),\n  parent: number(),\n  slot: number(),\n  timestamp: number()\n}), type({\n  type: literal('frozen'),\n  slot: number(),\n  timestamp: number(),\n  stats: type({\n    numTransactionEntries: number(),\n    numSuccessfulTransactions: number(),\n    numFailedTransactions: number(),\n    maxTransactionsPerEntry: number()\n  })\n}), type({\n  type: literal('dead'),\n  slot: number(),\n  timestamp: number(),\n  err: string()\n})]);\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */\n\nvar SlotUpdateNotificationResult = type({\n  subscription: number(),\n  result: SlotUpdateResult\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */\n\nvar SignatureNotificationResult = type({\n  subscription: number(),\n  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))\n});\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */\n\nvar RootNotificationResult = type({\n  subscription: number(),\n  result: number()\n});\nvar ContactInfoResult = type({\n  pubkey: string(),\n  gossip: nullable(string()),\n  tpu: nullable(string()),\n  rpc: nullable(string()),\n  version: nullable(string())\n});\nvar VoteAccountInfoResult = type({\n  votePubkey: string(),\n  nodePubkey: string(),\n  activatedStake: number(),\n  epochVoteAccount: boolean(),\n  epochCredits: array(tuple([number(), number(), number()])),\n  commission: number(),\n  lastVote: number(),\n  rootSlot: nullable(number())\n});\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */\n\nvar GetVoteAccounts = jsonRpcResult(type({\n  current: array(VoteAccountInfoResult),\n  delinquent: array(VoteAccountInfoResult)\n}));\nvar ConfirmationStatus = union([literal('processed'), literal('confirmed'), literal('finalized')]);\nvar SignatureStatusResponse = type({\n  slot: number(),\n  confirmations: nullable(number()),\n  err: TransactionErrorResult,\n  confirmationStatus: optional(ConfirmationStatus)\n});\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */\n\nvar GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */\n\nvar GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());\nvar ConfirmedTransactionResult = type({\n  signatures: array(string()),\n  message: type({\n    accountKeys: array(string()),\n    header: type({\n      numRequiredSignatures: number(),\n      numReadonlySignedAccounts: number(),\n      numReadonlyUnsignedAccounts: number()\n    }),\n    instructions: array(type({\n      accounts: array(number()),\n      data: string(),\n      programIdIndex: number()\n    })),\n    recentBlockhash: string()\n  })\n});\nvar ParsedInstructionResult = type({\n  parsed: unknown(),\n  program: string(),\n  programId: PublicKeyFromString\n});\nvar RawInstructionResult = type({\n  accounts: array(PublicKeyFromString),\n  data: string(),\n  programId: PublicKeyFromString\n});\nvar InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);\nvar UnknownInstructionResult = union([type({\n  parsed: unknown(),\n  program: string(),\n  programId: string()\n}), type({\n  accounts: array(string()),\n  data: string(),\n  programId: string()\n})]);\nvar ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, function (value) {\n  if ('accounts' in value) {\n    return create(value, RawInstructionResult);\n  } else {\n    return create(value, ParsedInstructionResult);\n  }\n});\n/**\n * @internal\n */\n\nvar ParsedConfirmedTransactionResult = type({\n  signatures: array(string()),\n  message: type({\n    accountKeys: array(type({\n      pubkey: PublicKeyFromString,\n      signer: boolean(),\n      writable: boolean()\n    })),\n    instructions: array(ParsedOrRawInstruction),\n    recentBlockhash: string()\n  })\n});\nvar TokenBalanceResult = type({\n  accountIndex: number(),\n  mint: string(),\n  owner: optional(string()),\n  uiTokenAmount: TokenAmountResult\n});\n/**\n * @internal\n */\n\nvar ConfirmedTransactionMetaResult = type({\n  err: TransactionErrorResult,\n  fee: number(),\n  innerInstructions: optional(nullable(array(type({\n    index: number(),\n    instructions: array(type({\n      accounts: array(number()),\n      data: string(),\n      programIdIndex: number()\n    }))\n  })))),\n  preBalances: array(number()),\n  postBalances: array(number()),\n  logMessages: optional(nullable(array(string()))),\n  preTokenBalances: optional(nullable(array(TokenBalanceResult))),\n  postTokenBalances: optional(nullable(array(TokenBalanceResult)))\n});\n/**\n * @internal\n */\n\nvar ParsedConfirmedTransactionMetaResult = type({\n  err: TransactionErrorResult,\n  fee: number(),\n  innerInstructions: optional(nullable(array(type({\n    index: number(),\n    instructions: array(ParsedOrRawInstruction)\n  })))),\n  preBalances: array(number()),\n  postBalances: array(number()),\n  logMessages: optional(nullable(array(string()))),\n  preTokenBalances: optional(nullable(array(TokenBalanceResult))),\n  postTokenBalances: optional(nullable(array(TokenBalanceResult)))\n});\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\n\nvar GetBlockRpcResult = jsonRpcResult(nullable(type({\n  blockhash: string(),\n  previousBlockhash: string(),\n  parentSlot: number(),\n  transactions: array(type({\n    transaction: ConfirmedTransactionResult,\n    meta: nullable(ConfirmedTransactionMetaResult)\n  })),\n  rewards: optional(array(type({\n    pubkey: string(),\n    lamports: number(),\n    postBalance: nullable(number()),\n    rewardType: nullable(string())\n  }))),\n  blockTime: nullable(number()),\n  blockHeight: nullable(number())\n})));\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */\n\nvar GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({\n  blockhash: string(),\n  previousBlockhash: string(),\n  parentSlot: number(),\n  transactions: array(type({\n    transaction: ConfirmedTransactionResult,\n    meta: nullable(ConfirmedTransactionMetaResult)\n  })),\n  rewards: optional(array(type({\n    pubkey: string(),\n    lamports: number(),\n    postBalance: nullable(number()),\n    rewardType: nullable(string())\n  }))),\n  blockTime: nullable(number())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\n\nvar GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({\n  blockhash: string(),\n  previousBlockhash: string(),\n  parentSlot: number(),\n  signatures: array(string()),\n  blockTime: nullable(number())\n})));\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */\n\nvar GetTransactionRpcResult = jsonRpcResult(nullable(type({\n  slot: number(),\n  meta: ConfirmedTransactionMetaResult,\n  blockTime: optional(nullable(number())),\n  transaction: ConfirmedTransactionResult\n})));\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */\n\nvar GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({\n  slot: number(),\n  transaction: ParsedConfirmedTransactionResult,\n  meta: nullable(ParsedConfirmedTransactionMetaResult),\n  blockTime: optional(nullable(number()))\n})));\n/**\n * Expected JSON RPC response for the \"getRecentBlockhash\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.\n */\n\nvar GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({\n  blockhash: string(),\n  feeCalculator: type({\n    lamportsPerSignature: number()\n  })\n}));\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */\n\nvar GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({\n  blockhash: string(),\n  lastValidBlockHeight: number()\n}));\nvar PerfSampleResult = type({\n  slot: number(),\n  numTransactions: number(),\n  numSlots: number(),\n  samplePeriodSecs: number()\n});\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */\n\nvar GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */\n\nvar GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({\n  feeCalculator: type({\n    lamportsPerSignature: number()\n  })\n})));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */\n\nvar RequestAirdropRpcResult = jsonRpcResult(string());\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */\n\nvar SendTransactionRpcResult = jsonRpcResult(string());\n/**\n * Information about the latest slot being processed by a node\n */\n\n/**\n * @internal\n */\n\nvar LogsResult = type({\n  err: TransactionErrorResult,\n  logs: array(string()),\n  signature: string()\n});\n/**\n * Logs result.\n */\n\n/**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */\n\nvar LogsNotificationResult = type({\n  result: notificationResultAndContext(LogsResult),\n  subscription: number()\n});\n/**\n * Filter for log subscriptions.\n */\n\n/** @internal */\n\nvar COMMON_HTTP_HEADERS = {\n  'solana-client': \"js/\".concat((_process$env$npm_pack = \"0.0.0-development\") !== null && _process$env$npm_pack !== void 0 ? _process$env$npm_pack : 'UNKNOWN')\n};\n/**\n * A connection to a fullnode JSON RPC endpoint\n */\n\nvar Connection = /*#__PURE__*/function () {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal\n   * A number that we increment every time an active connection closes.\n   * Used to determine whether the same socket connection that was open\n   * when an async operation started is the same one that's active when\n   * its continuation fires.\n   *\n   */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /**\n   * Special case.\n   * After a signature is processed, RPCs automatically dispose of the\n   * subscription on the server side. We need to track which of these\n   * subscriptions have been disposed in such a way, so that we know\n   * whether the client is dealing with a not-yet-processed signature\n   * (in which case we must tear down the server subscription) or an\n   * already-processed signature (in which case the client can simply\n   * clear out the subscription locally without telling the server).\n   *\n   * NOTE: There is a proposal to eliminate this special case, here:\n   * https://github.com/solana-labs/solana/issues/18892\n   */\n\n  /** @internal */\n\n  /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */\n  function Connection(endpoint, commitmentOrConfig) {\n    _classCallCheck(this, Connection);\n\n    this._commitment = void 0;\n    this._confirmTransactionInitialTimeout = void 0;\n    this._rpcEndpoint = void 0;\n    this._rpcWsEndpoint = void 0;\n    this._rpcClient = void 0;\n    this._rpcRequest = void 0;\n    this._rpcBatchRequest = void 0;\n    this._rpcWebSocket = void 0;\n    this._rpcWebSocketConnected = false;\n    this._rpcWebSocketHeartbeat = null;\n    this._rpcWebSocketIdleTimeout = null;\n    this._rpcWebSocketGeneration = 0;\n    this._disableBlockhashCaching = false;\n    this._pollingBlockhash = false;\n    this._blockhashInfo = {\n      latestBlockhash: null,\n      lastFetch: 0,\n      transactionSignatures: [],\n      simulatedSignatures: []\n    };\n    this._nextClientSubscriptionId = 0;\n    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n    this._subscriptionCallbacksByServerSubscriptionId = {};\n    this._subscriptionsByHash = {};\n    this._subscriptionsAutoDisposedByRpc = new Set();\n    var url = new URL(endpoint);\n    var useHttps = url.protocol === 'https:';\n    var wsEndpoint;\n    var httpHeaders;\n    var fetch;\n    var fetchMiddleware;\n    var disableRetryOnRateLimit;\n\n    if (commitmentOrConfig && typeof commitmentOrConfig === 'string') {\n      this._commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n      this._commitment = commitmentOrConfig.commitment;\n      this._confirmTransactionInitialTimeout = commitmentOrConfig.confirmTransactionInitialTimeout;\n      wsEndpoint = commitmentOrConfig.wsEndpoint;\n      httpHeaders = commitmentOrConfig.httpHeaders;\n      fetch = commitmentOrConfig.fetch;\n      fetchMiddleware = commitmentOrConfig.fetchMiddleware;\n      disableRetryOnRateLimit = commitmentOrConfig.disableRetryOnRateLimit;\n    }\n\n    this._rpcEndpoint = endpoint;\n    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n    this._rpcClient = createRpcClient(url.toString(), useHttps, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit);\n    this._rpcRequest = createRpcRequest(this._rpcClient);\n    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n    this._rpcWebSocket = new Client(this._rpcWsEndpoint, {\n      autoconnect: false,\n      max_reconnects: Infinity\n    });\n\n    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));\n\n    this._rpcWebSocket.on('error', this._wsOnError.bind(this));\n\n    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));\n\n    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));\n\n    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));\n\n    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));\n\n    this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));\n\n    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));\n\n    this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));\n\n    this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));\n  }\n  /**\n   * The default commitment used for requests\n   */\n\n\n  _createClass(Connection, [{\n    key: \"getBalanceAndContext\",\n\n    /**\n     * Fetch the balance for the specified public key, return with context\n     */\n    value: function () {\n      var _getBalanceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(publicKey, commitmentOrConfig) {\n        var _extractCommitmentFro, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                /** @internal */\n                _extractCommitmentFro = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro.commitment, config = _extractCommitmentFro.config;\n                args = this._buildArgs([publicKey.toBase58()], commitment, undefined\n                /* encoding */\n                , config);\n                _context8.next = 4;\n                return this._rpcRequest('getBalance', args);\n\n              case 4:\n                unsafeRes = _context8.sent;\n                res = create(unsafeRes, jsonRpcResultAndContext(number()));\n\n                if (!('error' in res)) {\n                  _context8.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get balance for ' + publicKey.toBase58() + ': ' + res.error.message);\n\n              case 8:\n                return _context8.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getBalanceAndContext(_x22, _x23) {\n        return _getBalanceAndContext.apply(this, arguments);\n      }\n\n      return getBalanceAndContext;\n    }()\n    /**\n     * Fetch the balance for the specified public key\n     */\n\n  }, {\n    key: \"getBalance\",\n    value: function () {\n      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(publicKey, commitmentOrConfig) {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.getBalanceAndContext(publicKey, commitmentOrConfig).then(function (x) {\n                  return x.value;\n                }).catch(function (e) {\n                  throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);\n                });\n\n              case 2:\n                return _context9.abrupt(\"return\", _context9.sent);\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getBalance(_x24, _x25) {\n        return _getBalance.apply(this, arguments);\n      }\n\n      return getBalance;\n    }()\n    /**\n     * Fetch the estimated production time of a block\n     */\n\n  }, {\n    key: \"getBlockTime\",\n    value: function () {\n      var _getBlockTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(slot) {\n        var unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this._rpcRequest('getBlockTime', [slot]);\n\n              case 2:\n                unsafeRes = _context10.sent;\n                res = create(unsafeRes, jsonRpcResult(nullable(number())));\n\n                if (!('error' in res)) {\n                  _context10.next = 6;\n                  break;\n                }\n\n                throw new Error('failed to get block time for slot ' + slot + ': ' + res.error.message);\n\n              case 6:\n                return _context10.abrupt(\"return\", res.result);\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getBlockTime(_x26) {\n        return _getBlockTime.apply(this, arguments);\n      }\n\n      return getBlockTime;\n    }()\n    /**\n     * Fetch the lowest slot that the node has information about in its ledger.\n     * This value may increase over time if the node is configured to purge older ledger data\n     */\n\n  }, {\n    key: \"getMinimumLedgerSlot\",\n    value: function () {\n      var _getMinimumLedgerSlot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this._rpcRequest('minimumLedgerSlot', []);\n\n              case 2:\n                unsafeRes = _context11.sent;\n                res = create(unsafeRes, jsonRpcResult(number()));\n\n                if (!('error' in res)) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                throw new Error('failed to get minimum ledger slot: ' + res.error.message);\n\n              case 6:\n                return _context11.abrupt(\"return\", res.result);\n\n              case 7:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getMinimumLedgerSlot() {\n        return _getMinimumLedgerSlot.apply(this, arguments);\n      }\n\n      return getMinimumLedgerSlot;\n    }()\n    /**\n     * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n     */\n\n  }, {\n    key: \"getFirstAvailableBlock\",\n    value: function () {\n      var _getFirstAvailableBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this._rpcRequest('getFirstAvailableBlock', []);\n\n              case 2:\n                unsafeRes = _context12.sent;\n                res = create(unsafeRes, SlotRpcResult);\n\n                if (!('error' in res)) {\n                  _context12.next = 6;\n                  break;\n                }\n\n                throw new Error('failed to get first available block: ' + res.error.message);\n\n              case 6:\n                return _context12.abrupt(\"return\", res.result);\n\n              case 7:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getFirstAvailableBlock() {\n        return _getFirstAvailableBlock.apply(this, arguments);\n      }\n\n      return getFirstAvailableBlock;\n    }()\n    /**\n     * Fetch information about the current supply\n     */\n\n  }, {\n    key: \"getSupply\",\n    value: function () {\n      var _getSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(config) {\n        var configArg, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                configArg = {};\n\n                if (typeof config === 'string') {\n                  configArg = {\n                    commitment: config\n                  };\n                } else if (config) {\n                  configArg = _objectSpread({}, config, {\n                    commitment: config && config.commitment || this.commitment\n                  });\n                } else {\n                  configArg = {\n                    commitment: this.commitment\n                  };\n                }\n\n                _context13.next = 4;\n                return this._rpcRequest('getSupply', [configArg]);\n\n              case 4:\n                unsafeRes = _context13.sent;\n                res = create(unsafeRes, GetSupplyRpcResult);\n\n                if (!('error' in res)) {\n                  _context13.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get supply: ' + res.error.message);\n\n              case 8:\n                return _context13.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function getSupply(_x27) {\n        return _getSupply.apply(this, arguments);\n      }\n\n      return getSupply;\n    }()\n    /**\n     * Fetch the current supply of a token mint\n     */\n\n  }, {\n    key: \"getTokenSupply\",\n    value: function () {\n      var _getTokenSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(tokenMintAddress, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                args = this._buildArgs([tokenMintAddress.toBase58()], commitment);\n                _context14.next = 3;\n                return this._rpcRequest('getTokenSupply', args);\n\n              case 3:\n                unsafeRes = _context14.sent;\n                res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n\n                if (!('error' in res)) {\n                  _context14.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get token supply: ' + res.error.message);\n\n              case 7:\n                return _context14.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function getTokenSupply(_x28, _x29) {\n        return _getTokenSupply.apply(this, arguments);\n      }\n\n      return getTokenSupply;\n    }()\n    /**\n     * Fetch the current balance of a token account\n     */\n\n  }, {\n    key: \"getTokenAccountBalance\",\n    value: function () {\n      var _getTokenAccountBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(tokenAddress, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                args = this._buildArgs([tokenAddress.toBase58()], commitment);\n                _context15.next = 3;\n                return this._rpcRequest('getTokenAccountBalance', args);\n\n              case 3:\n                unsafeRes = _context15.sent;\n                res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n\n                if (!('error' in res)) {\n                  _context15.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get token account balance: ' + res.error.message);\n\n              case 7:\n                return _context15.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getTokenAccountBalance(_x30, _x31) {\n        return _getTokenAccountBalance.apply(this, arguments);\n      }\n\n      return getTokenAccountBalance;\n    }()\n    /**\n     * Fetch all the token accounts owned by the specified account\n     *\n     * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>>}\n     */\n\n  }, {\n    key: \"getTokenAccountsByOwner\",\n    value: function () {\n      var _getTokenAccountsByOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(ownerAddress, filter, commitmentOrConfig) {\n        var _extractCommitmentFro2, commitment, config, _args, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _extractCommitmentFro2 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro2.commitment, config = _extractCommitmentFro2.config;\n                _args = [ownerAddress.toBase58()];\n\n                if ('mint' in filter) {\n                  _args.push({\n                    mint: filter.mint.toBase58()\n                  });\n                } else {\n                  _args.push({\n                    programId: filter.programId.toBase58()\n                  });\n                }\n\n                args = this._buildArgs(_args, commitment, 'base64', config);\n                _context16.next = 6;\n                return this._rpcRequest('getTokenAccountsByOwner', args);\n\n              case 6:\n                unsafeRes = _context16.sent;\n                res = create(unsafeRes, GetTokenAccountsByOwner);\n\n                if (!('error' in res)) {\n                  _context16.next = 10;\n                  break;\n                }\n\n                throw new Error('failed to get token accounts owned by account ' + ownerAddress.toBase58() + ': ' + res.error.message);\n\n              case 10:\n                return _context16.abrupt(\"return\", res.result);\n\n              case 11:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function getTokenAccountsByOwner(_x32, _x33, _x34) {\n        return _getTokenAccountsByOwner.apply(this, arguments);\n      }\n\n      return getTokenAccountsByOwner;\n    }()\n    /**\n     * Fetch parsed token accounts owned by the specified account\n     *\n     * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n     */\n\n  }, {\n    key: \"getParsedTokenAccountsByOwner\",\n    value: function () {\n      var _getParsedTokenAccountsByOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(ownerAddress, filter, commitment) {\n        var _args, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _args = [ownerAddress.toBase58()];\n\n                if ('mint' in filter) {\n                  _args.push({\n                    mint: filter.mint.toBase58()\n                  });\n                } else {\n                  _args.push({\n                    programId: filter.programId.toBase58()\n                  });\n                }\n\n                args = this._buildArgs(_args, commitment, 'jsonParsed');\n                _context17.next = 5;\n                return this._rpcRequest('getTokenAccountsByOwner', args);\n\n              case 5:\n                unsafeRes = _context17.sent;\n                res = create(unsafeRes, GetParsedTokenAccountsByOwner);\n\n                if (!('error' in res)) {\n                  _context17.next = 9;\n                  break;\n                }\n\n                throw new Error('failed to get token accounts owned by account ' + ownerAddress.toBase58() + ': ' + res.error.message);\n\n              case 9:\n                return _context17.abrupt(\"return\", res.result);\n\n              case 10:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function getParsedTokenAccountsByOwner(_x35, _x36, _x37) {\n        return _getParsedTokenAccountsByOwner.apply(this, arguments);\n      }\n\n      return getParsedTokenAccountsByOwner;\n    }()\n    /**\n     * Fetch the 20 largest accounts with their current balances\n     */\n\n  }, {\n    key: \"getLargestAccounts\",\n    value: function () {\n      var _getLargestAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(config) {\n        var arg, args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                arg = _objectSpread({}, config, {\n                  commitment: config && config.commitment || this.commitment\n                });\n                args = arg.filter || arg.commitment ? [arg] : [];\n                _context18.next = 4;\n                return this._rpcRequest('getLargestAccounts', args);\n\n              case 4:\n                unsafeRes = _context18.sent;\n                res = create(unsafeRes, GetLargestAccountsRpcResult);\n\n                if (!('error' in res)) {\n                  _context18.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get largest accounts: ' + res.error.message);\n\n              case 8:\n                return _context18.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function getLargestAccounts(_x38) {\n        return _getLargestAccounts.apply(this, arguments);\n      }\n\n      return getLargestAccounts;\n    }()\n    /**\n     * Fetch the 20 largest token accounts with their current balances\n     * for a given mint.\n     */\n\n  }, {\n    key: \"getTokenLargestAccounts\",\n    value: function () {\n      var _getTokenLargestAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(mintAddress, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                args = this._buildArgs([mintAddress.toBase58()], commitment);\n                _context19.next = 3;\n                return this._rpcRequest('getTokenLargestAccounts', args);\n\n              case 3:\n                unsafeRes = _context19.sent;\n                res = create(unsafeRes, GetTokenLargestAccountsResult);\n\n                if (!('error' in res)) {\n                  _context19.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get token largest accounts: ' + res.error.message);\n\n              case 7:\n                return _context19.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function getTokenLargestAccounts(_x39, _x40) {\n        return _getTokenLargestAccounts.apply(this, arguments);\n      }\n\n      return getTokenLargestAccounts;\n    }()\n    /**\n     * Fetch all the account info for the specified public key, return with context\n     */\n\n  }, {\n    key: \"getAccountInfoAndContext\",\n    value: function () {\n      var _getAccountInfoAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(publicKey, commitmentOrConfig) {\n        var _extractCommitmentFro3, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _extractCommitmentFro3 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro3.commitment, config = _extractCommitmentFro3.config;\n                args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);\n                _context20.next = 4;\n                return this._rpcRequest('getAccountInfo', args);\n\n              case 4:\n                unsafeRes = _context20.sent;\n                res = create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));\n\n                if (!('error' in res)) {\n                  _context20.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + res.error.message);\n\n              case 8:\n                return _context20.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function getAccountInfoAndContext(_x41, _x42) {\n        return _getAccountInfoAndContext.apply(this, arguments);\n      }\n\n      return getAccountInfoAndContext;\n    }()\n    /**\n     * Fetch parsed account info for the specified public key\n     */\n\n  }, {\n    key: \"getParsedAccountInfo\",\n    value: function () {\n      var _getParsedAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(publicKey, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed');\n                _context21.next = 3;\n                return this._rpcRequest('getAccountInfo', args);\n\n              case 3:\n                unsafeRes = _context21.sent;\n                res = create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));\n\n                if (!('error' in res)) {\n                  _context21.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + res.error.message);\n\n              case 7:\n                return _context21.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function getParsedAccountInfo(_x43, _x44) {\n        return _getParsedAccountInfo.apply(this, arguments);\n      }\n\n      return getParsedAccountInfo;\n    }()\n    /**\n     * Fetch all the account info for the specified public key\n     */\n\n  }, {\n    key: \"getAccountInfo\",\n    value: function () {\n      var _getAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(publicKey, commitmentOrConfig) {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.prev = 0;\n                _context22.next = 3;\n                return this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n\n              case 3:\n                res = _context22.sent;\n                return _context22.abrupt(\"return\", res.value);\n\n              case 7:\n                _context22.prev = 7;\n                _context22.t0 = _context22[\"catch\"](0);\n                throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + _context22.t0);\n\n              case 10:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this, [[0, 7]]);\n      }));\n\n      function getAccountInfo(_x45, _x46) {\n        return _getAccountInfo.apply(this, arguments);\n      }\n\n      return getAccountInfo;\n    }()\n    /**\n     * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n     */\n\n  }, {\n    key: \"getMultipleAccountsInfoAndContext\",\n    value: function () {\n      var _getMultipleAccountsInfoAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(publicKeys, commitmentOrConfig) {\n        var _extractCommitmentFro4, commitment, config, keys, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _extractCommitmentFro4 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro4.commitment, config = _extractCommitmentFro4.config;\n                keys = publicKeys.map(function (key) {\n                  return key.toBase58();\n                });\n                args = this._buildArgs([keys], commitment, 'base64', config);\n                _context23.next = 5;\n                return this._rpcRequest('getMultipleAccounts', args);\n\n              case 5:\n                unsafeRes = _context23.sent;\n                res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));\n\n                if (!('error' in res)) {\n                  _context23.next = 9;\n                  break;\n                }\n\n                throw new Error('failed to get info for accounts ' + keys + ': ' + res.error.message);\n\n              case 9:\n                return _context23.abrupt(\"return\", res.result);\n\n              case 10:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function getMultipleAccountsInfoAndContext(_x47, _x48) {\n        return _getMultipleAccountsInfoAndContext.apply(this, arguments);\n      }\n\n      return getMultipleAccountsInfoAndContext;\n    }()\n    /**\n     * Fetch all the account info for multiple accounts specified by an array of public keys\n     */\n\n  }, {\n    key: \"getMultipleAccountsInfo\",\n    value: function () {\n      var _getMultipleAccountsInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(publicKeys, commitmentOrConfig) {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n\n              case 2:\n                res = _context24.sent;\n                return _context24.abrupt(\"return\", res.value);\n\n              case 4:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function getMultipleAccountsInfo(_x49, _x50) {\n        return _getMultipleAccountsInfo.apply(this, arguments);\n      }\n\n      return getMultipleAccountsInfo;\n    }()\n    /**\n     * Returns epoch activation information for a stake account that has been delegated\n     */\n\n  }, {\n    key: \"getStakeActivation\",\n    value: function () {\n      var _getStakeActivation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(publicKey, commitmentOrConfig, epoch) {\n        var _extractCommitmentFro5, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _extractCommitmentFro5 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro5.commitment, config = _extractCommitmentFro5.config;\n                args = this._buildArgs([publicKey.toBase58()], commitment, undefined\n                /* encoding */\n                , _objectSpread({}, config, {\n                  epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch\n                }));\n                _context25.next = 4;\n                return this._rpcRequest('getStakeActivation', args);\n\n              case 4:\n                unsafeRes = _context25.sent;\n                res = create(unsafeRes, jsonRpcResult(StakeActivationResult));\n\n                if (!('error' in res)) {\n                  _context25.next = 8;\n                  break;\n                }\n\n                throw new Error(\"failed to get Stake Activation \".concat(publicKey.toBase58(), \": \").concat(res.error.message));\n\n              case 8:\n                return _context25.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function getStakeActivation(_x51, _x52, _x53) {\n        return _getStakeActivation.apply(this, arguments);\n      }\n\n      return getStakeActivation;\n    }()\n    /**\n     * Fetch all the accounts owned by the specified program id\n     *\n     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n     */\n\n  }, {\n    key: \"getProgramAccounts\",\n    value: function () {\n      var _getProgramAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(programId, configOrCommitment) {\n        var _extractCommitmentFro6, commitment, config, _ref7, encoding, configWithoutEncoding, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _extractCommitmentFro6 = extractCommitmentFromConfig(configOrCommitment), commitment = _extractCommitmentFro6.commitment, config = _extractCommitmentFro6.config;\n                _ref7 = config || {}, encoding = _ref7.encoding, configWithoutEncoding = _objectWithoutProperties(_ref7, [\"encoding\"]);\n                args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', configWithoutEncoding);\n                _context26.next = 5;\n                return this._rpcRequest('getProgramAccounts', args);\n\n              case 5:\n                unsafeRes = _context26.sent;\n                res = create(unsafeRes, jsonRpcResult(array(KeyedAccountInfoResult)));\n\n                if (!('error' in res)) {\n                  _context26.next = 9;\n                  break;\n                }\n\n                throw new Error('failed to get accounts owned by program ' + programId.toBase58() + ': ' + res.error.message);\n\n              case 9:\n                return _context26.abrupt(\"return\", res.result);\n\n              case 10:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function getProgramAccounts(_x54, _x55) {\n        return _getProgramAccounts.apply(this, arguments);\n      }\n\n      return getProgramAccounts;\n    }()\n    /**\n     * Fetch and parse all the accounts owned by the specified program id\n     *\n     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n     */\n\n  }, {\n    key: \"getParsedProgramAccounts\",\n    value: function () {\n      var _getParsedProgramAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(programId, configOrCommitment) {\n        var _extractCommitmentFro7, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                _extractCommitmentFro7 = extractCommitmentFromConfig(configOrCommitment), commitment = _extractCommitmentFro7.commitment, config = _extractCommitmentFro7.config;\n                args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);\n                _context27.next = 4;\n                return this._rpcRequest('getProgramAccounts', args);\n\n              case 4:\n                unsafeRes = _context27.sent;\n                res = create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));\n\n                if (!('error' in res)) {\n                  _context27.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get accounts owned by program ' + programId.toBase58() + ': ' + res.error.message);\n\n              case 8:\n                return _context27.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function getParsedProgramAccounts(_x56, _x57) {\n        return _getParsedProgramAccounts.apply(this, arguments);\n      }\n\n      return getParsedProgramAccounts;\n    }() // eslint-disable-next-line no-dupe-class-members\n\n  }, {\n    key: \"confirmTransaction\",\n    value: function () {\n      var _confirmTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(strategy, commitment) {\n        var _this10 = this;\n\n        var rawSignature, config, decodedSignature, subscriptionCommitment, timeoutId, subscriptionId, done, confirmationPromise, checkBlockHeight, expiryPromise, result, outcome;\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                if (typeof strategy == 'string') {\n                  rawSignature = strategy;\n                } else {\n                  config = strategy;\n                  rawSignature = config.signature;\n                }\n\n                _context30.prev = 1;\n                decodedSignature = bs58.decode(rawSignature);\n                _context30.next = 8;\n                break;\n\n              case 5:\n                _context30.prev = 5;\n                _context30.t0 = _context30[\"catch\"](1);\n                throw new Error('signature must be base58 encoded: ' + rawSignature);\n\n              case 8:\n                assert(decodedSignature.length === 64, 'signature has invalid length');\n                subscriptionCommitment = commitment || this.commitment;\n                done = false;\n                confirmationPromise = new Promise(function (resolve, reject) {\n                  try {\n                    subscriptionId = _this10.onSignature(rawSignature, function (result, context) {\n                      subscriptionId = undefined;\n                      var response = {\n                        context: context,\n                        value: result\n                      };\n                      done = true;\n                      resolve({\n                        __type: TransactionStatus.PROCESSED,\n                        response: response\n                      });\n                    }, subscriptionCommitment);\n                  } catch (err) {\n                    reject(err);\n                  }\n                });\n\n                checkBlockHeight = /*#__PURE__*/function () {\n                  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n                    var blockHeight;\n                    return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n                      while (1) {\n                        switch (_context28.prev = _context28.next) {\n                          case 0:\n                            _context28.prev = 0;\n                            _context28.next = 3;\n                            return _this10.getBlockHeight(commitment);\n\n                          case 3:\n                            blockHeight = _context28.sent;\n                            return _context28.abrupt(\"return\", blockHeight);\n\n                          case 7:\n                            _context28.prev = 7;\n                            _context28.t0 = _context28[\"catch\"](0);\n                            return _context28.abrupt(\"return\", -1);\n\n                          case 10:\n                          case \"end\":\n                            return _context28.stop();\n                        }\n                      }\n                    }, _callee28, null, [[0, 7]]);\n                  }));\n\n                  return function checkBlockHeight() {\n                    return _ref8.apply(this, arguments);\n                  };\n                }();\n\n                expiryPromise = new Promise(function (resolve) {\n                  if (typeof strategy === 'string') {\n                    var timeoutMs = _this10._confirmTransactionInitialTimeout || 60 * 1000;\n\n                    switch (subscriptionCommitment) {\n                      case 'processed':\n                      case 'recent':\n                      case 'single':\n                      case 'confirmed':\n                      case 'singleGossip':\n                        {\n                          timeoutMs = _this10._confirmTransactionInitialTimeout || 30 * 1000;\n                          break;\n                        }\n                    }\n\n                    timeoutId = setTimeout(function () {\n                      return resolve({\n                        __type: TransactionStatus.TIMED_OUT,\n                        timeoutMs: timeoutMs\n                      });\n                    }, timeoutMs);\n                  } else {\n                    var _config = strategy;\n\n                    _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n                      var currentBlockHeight;\n                      return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n                        while (1) {\n                          switch (_context29.prev = _context29.next) {\n                            case 0:\n                              _context29.next = 2;\n                              return checkBlockHeight();\n\n                            case 2:\n                              currentBlockHeight = _context29.sent;\n\n                              if (!done) {\n                                _context29.next = 5;\n                                break;\n                              }\n\n                              return _context29.abrupt(\"return\");\n\n                            case 5:\n                              if (!(currentBlockHeight <= _config.lastValidBlockHeight)) {\n                                _context29.next = 17;\n                                break;\n                              }\n\n                              _context29.next = 8;\n                              return sleep(1000);\n\n                            case 8:\n                              if (!done) {\n                                _context29.next = 10;\n                                break;\n                              }\n\n                              return _context29.abrupt(\"return\");\n\n                            case 10:\n                              _context29.next = 12;\n                              return checkBlockHeight();\n\n                            case 12:\n                              currentBlockHeight = _context29.sent;\n\n                              if (!done) {\n                                _context29.next = 15;\n                                break;\n                              }\n\n                              return _context29.abrupt(\"return\");\n\n                            case 15:\n                              _context29.next = 5;\n                              break;\n\n                            case 17:\n                              resolve({\n                                __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                              });\n\n                            case 18:\n                            case \"end\":\n                              return _context29.stop();\n                          }\n                        }\n                      }, _callee29);\n                    }))();\n                  }\n                });\n                _context30.prev = 14;\n                _context30.next = 17;\n                return Promise.race([confirmationPromise, expiryPromise]);\n\n              case 17:\n                outcome = _context30.sent;\n                _context30.t1 = outcome.__type;\n                _context30.next = _context30.t1 === TransactionStatus.BLOCKHEIGHT_EXCEEDED ? 21 : _context30.t1 === TransactionStatus.PROCESSED ? 22 : _context30.t1 === TransactionStatus.TIMED_OUT ? 24 : 25;\n                break;\n\n              case 21:\n                throw new TransactionExpiredBlockheightExceededError(rawSignature);\n\n              case 22:\n                result = outcome.response;\n                return _context30.abrupt(\"break\", 25);\n\n              case 24:\n                throw new TransactionExpiredTimeoutError(rawSignature, outcome.timeoutMs / 1000);\n\n              case 25:\n                _context30.prev = 25;\n                clearTimeout(timeoutId);\n\n                if (subscriptionId) {\n                  this.removeSignatureListener(subscriptionId);\n                }\n\n                return _context30.finish(25);\n\n              case 29:\n                return _context30.abrupt(\"return\", result);\n\n              case 30:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30, this, [[1, 5], [14,, 25, 29]]);\n      }));\n\n      function confirmTransaction(_x58, _x59) {\n        return _confirmTransaction.apply(this, arguments);\n      }\n\n      return confirmTransaction;\n    }()\n    /**\n     * Return the list of nodes that are currently participating in the cluster\n     */\n\n  }, {\n    key: \"getClusterNodes\",\n    value: function () {\n      var _getClusterNodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {\n        var unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                _context31.next = 2;\n                return this._rpcRequest('getClusterNodes', []);\n\n              case 2:\n                unsafeRes = _context31.sent;\n                res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));\n\n                if (!('error' in res)) {\n                  _context31.next = 6;\n                  break;\n                }\n\n                throw new Error('failed to get cluster nodes: ' + res.error.message);\n\n              case 6:\n                return _context31.abrupt(\"return\", res.result);\n\n              case 7:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31, this);\n      }));\n\n      function getClusterNodes() {\n        return _getClusterNodes.apply(this, arguments);\n      }\n\n      return getClusterNodes;\n    }()\n    /**\n     * Return the list of nodes that are currently participating in the cluster\n     */\n\n  }, {\n    key: \"getVoteAccounts\",\n    value: function () {\n      var _getVoteAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n          while (1) {\n            switch (_context32.prev = _context32.next) {\n              case 0:\n                args = this._buildArgs([], commitment);\n                _context32.next = 3;\n                return this._rpcRequest('getVoteAccounts', args);\n\n              case 3:\n                unsafeRes = _context32.sent;\n                res = create(unsafeRes, GetVoteAccounts);\n\n                if (!('error' in res)) {\n                  _context32.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get vote accounts: ' + res.error.message);\n\n              case 7:\n                return _context32.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context32.stop();\n            }\n          }\n        }, _callee32, this);\n      }));\n\n      function getVoteAccounts(_x60) {\n        return _getVoteAccounts.apply(this, arguments);\n      }\n\n      return getVoteAccounts;\n    }()\n    /**\n     * Fetch the current slot that the node is processing\n     */\n\n  }, {\n    key: \"getSlot\",\n    value: function () {\n      var _getSlot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(commitmentOrConfig) {\n        var _extractCommitmentFro8, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) {\n            switch (_context33.prev = _context33.next) {\n              case 0:\n                _extractCommitmentFro8 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro8.commitment, config = _extractCommitmentFro8.config;\n                args = this._buildArgs([], commitment, undefined\n                /* encoding */\n                , config);\n                _context33.next = 4;\n                return this._rpcRequest('getSlot', args);\n\n              case 4:\n                unsafeRes = _context33.sent;\n                res = create(unsafeRes, jsonRpcResult(number()));\n\n                if (!('error' in res)) {\n                  _context33.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get slot: ' + res.error.message);\n\n              case 8:\n                return _context33.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context33.stop();\n            }\n          }\n        }, _callee33, this);\n      }));\n\n      function getSlot(_x61) {\n        return _getSlot.apply(this, arguments);\n      }\n\n      return getSlot;\n    }()\n    /**\n     * Fetch the current slot leader of the cluster\n     */\n\n  }, {\n    key: \"getSlotLeader\",\n    value: function () {\n      var _getSlotLeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(commitmentOrConfig) {\n        var _extractCommitmentFro9, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) {\n            switch (_context34.prev = _context34.next) {\n              case 0:\n                _extractCommitmentFro9 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro9.commitment, config = _extractCommitmentFro9.config;\n                args = this._buildArgs([], commitment, undefined\n                /* encoding */\n                , config);\n                _context34.next = 4;\n                return this._rpcRequest('getSlotLeader', args);\n\n              case 4:\n                unsafeRes = _context34.sent;\n                res = create(unsafeRes, jsonRpcResult(string()));\n\n                if (!('error' in res)) {\n                  _context34.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get slot leader: ' + res.error.message);\n\n              case 8:\n                return _context34.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context34.stop();\n            }\n          }\n        }, _callee34, this);\n      }));\n\n      function getSlotLeader(_x62) {\n        return _getSlotLeader.apply(this, arguments);\n      }\n\n      return getSlotLeader;\n    }()\n    /**\n     * Fetch `limit` number of slot leaders starting from `startSlot`\n     *\n     * @param startSlot fetch slot leaders starting from this slot\n     * @param limit number of slot leaders to return\n     */\n\n  }, {\n    key: \"getSlotLeaders\",\n    value: function () {\n      var _getSlotLeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(startSlot, limit) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) {\n            switch (_context35.prev = _context35.next) {\n              case 0:\n                args = [startSlot, limit];\n                _context35.next = 3;\n                return this._rpcRequest('getSlotLeaders', args);\n\n              case 3:\n                unsafeRes = _context35.sent;\n                res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));\n\n                if (!('error' in res)) {\n                  _context35.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get slot leaders: ' + res.error.message);\n\n              case 7:\n                return _context35.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context35.stop();\n            }\n          }\n        }, _callee35, this);\n      }));\n\n      function getSlotLeaders(_x63, _x64) {\n        return _getSlotLeaders.apply(this, arguments);\n      }\n\n      return getSlotLeaders;\n    }()\n    /**\n     * Fetch the current status of a signature\n     */\n\n  }, {\n    key: \"getSignatureStatus\",\n    value: function () {\n      var _getSignatureStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(signature, config) {\n        var _yield$this$getSignat, context, values, value;\n\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) {\n            switch (_context36.prev = _context36.next) {\n              case 0:\n                _context36.next = 2;\n                return this.getSignatureStatuses([signature], config);\n\n              case 2:\n                _yield$this$getSignat = _context36.sent;\n                context = _yield$this$getSignat.context;\n                values = _yield$this$getSignat.value;\n                assert(values.length === 1);\n                value = values[0];\n                return _context36.abrupt(\"return\", {\n                  context: context,\n                  value: value\n                });\n\n              case 8:\n              case \"end\":\n                return _context36.stop();\n            }\n          }\n        }, _callee36, this);\n      }));\n\n      function getSignatureStatus(_x65, _x66) {\n        return _getSignatureStatus.apply(this, arguments);\n      }\n\n      return getSignatureStatus;\n    }()\n    /**\n     * Fetch the current statuses of a batch of signatures\n     */\n\n  }, {\n    key: \"getSignatureStatuses\",\n    value: function () {\n      var _getSignatureStatuses = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(signatures, config) {\n        var params, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee37$(_context37) {\n          while (1) {\n            switch (_context37.prev = _context37.next) {\n              case 0:\n                params = [signatures];\n\n                if (config) {\n                  params.push(config);\n                }\n\n                _context37.next = 4;\n                return this._rpcRequest('getSignatureStatuses', params);\n\n              case 4:\n                unsafeRes = _context37.sent;\n                res = create(unsafeRes, GetSignatureStatusesRpcResult);\n\n                if (!('error' in res)) {\n                  _context37.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get signature status: ' + res.error.message);\n\n              case 8:\n                return _context37.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context37.stop();\n            }\n          }\n        }, _callee37, this);\n      }));\n\n      function getSignatureStatuses(_x67, _x68) {\n        return _getSignatureStatuses.apply(this, arguments);\n      }\n\n      return getSignatureStatuses;\n    }()\n    /**\n     * Fetch the current transaction count of the cluster\n     */\n\n  }, {\n    key: \"getTransactionCount\",\n    value: function () {\n      var _getTransactionCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(commitmentOrConfig) {\n        var _extractCommitmentFro10, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee38$(_context38) {\n          while (1) {\n            switch (_context38.prev = _context38.next) {\n              case 0:\n                _extractCommitmentFro10 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro10.commitment, config = _extractCommitmentFro10.config;\n                args = this._buildArgs([], commitment, undefined\n                /* encoding */\n                , config);\n                _context38.next = 4;\n                return this._rpcRequest('getTransactionCount', args);\n\n              case 4:\n                unsafeRes = _context38.sent;\n                res = create(unsafeRes, jsonRpcResult(number()));\n\n                if (!('error' in res)) {\n                  _context38.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get transaction count: ' + res.error.message);\n\n              case 8:\n                return _context38.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context38.stop();\n            }\n          }\n        }, _callee38, this);\n      }));\n\n      function getTransactionCount(_x69) {\n        return _getTransactionCount.apply(this, arguments);\n      }\n\n      return getTransactionCount;\n    }()\n    /**\n     * Fetch the current total currency supply of the cluster in lamports\n     *\n     * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.\n     */\n\n  }, {\n    key: \"getTotalSupply\",\n    value: function () {\n      var _getTotalSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39(commitment) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee39$(_context39) {\n          while (1) {\n            switch (_context39.prev = _context39.next) {\n              case 0:\n                _context39.next = 2;\n                return this.getSupply({\n                  commitment: commitment,\n                  excludeNonCirculatingAccountsList: true\n                });\n\n              case 2:\n                result = _context39.sent;\n                return _context39.abrupt(\"return\", result.value.total);\n\n              case 4:\n              case \"end\":\n                return _context39.stop();\n            }\n          }\n        }, _callee39, this);\n      }));\n\n      function getTotalSupply(_x70) {\n        return _getTotalSupply.apply(this, arguments);\n      }\n\n      return getTotalSupply;\n    }()\n    /**\n     * Fetch the cluster InflationGovernor parameters\n     */\n\n  }, {\n    key: \"getInflationGovernor\",\n    value: function () {\n      var _getInflationGovernor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee40$(_context40) {\n          while (1) {\n            switch (_context40.prev = _context40.next) {\n              case 0:\n                args = this._buildArgs([], commitment);\n                _context40.next = 3;\n                return this._rpcRequest('getInflationGovernor', args);\n\n              case 3:\n                unsafeRes = _context40.sent;\n                res = create(unsafeRes, GetInflationGovernorRpcResult);\n\n                if (!('error' in res)) {\n                  _context40.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get inflation: ' + res.error.message);\n\n              case 7:\n                return _context40.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context40.stop();\n            }\n          }\n        }, _callee40, this);\n      }));\n\n      function getInflationGovernor(_x71) {\n        return _getInflationGovernor.apply(this, arguments);\n      }\n\n      return getInflationGovernor;\n    }()\n    /**\n     * Fetch the inflation reward for a list of addresses for an epoch\n     */\n\n  }, {\n    key: \"getInflationReward\",\n    value: function () {\n      var _getInflationReward = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(addresses, epoch, commitmentOrConfig) {\n        var _extractCommitmentFro11, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee41$(_context41) {\n          while (1) {\n            switch (_context41.prev = _context41.next) {\n              case 0:\n                _extractCommitmentFro11 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro11.commitment, config = _extractCommitmentFro11.config;\n                args = this._buildArgs([addresses.map(function (pubkey) {\n                  return pubkey.toBase58();\n                })], commitment, undefined\n                /* encoding */\n                , _objectSpread({}, config, {\n                  epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch\n                }));\n                _context41.next = 4;\n                return this._rpcRequest('getInflationReward', args);\n\n              case 4:\n                unsafeRes = _context41.sent;\n                res = create(unsafeRes, GetInflationRewardResult);\n\n                if (!('error' in res)) {\n                  _context41.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get inflation reward: ' + res.error.message);\n\n              case 8:\n                return _context41.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context41.stop();\n            }\n          }\n        }, _callee41, this);\n      }));\n\n      function getInflationReward(_x72, _x73, _x74) {\n        return _getInflationReward.apply(this, arguments);\n      }\n\n      return getInflationReward;\n    }()\n    /**\n     * Fetch the Epoch Info parameters\n     */\n\n  }, {\n    key: \"getEpochInfo\",\n    value: function () {\n      var _getEpochInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42(commitmentOrConfig) {\n        var _extractCommitmentFro12, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee42$(_context42) {\n          while (1) {\n            switch (_context42.prev = _context42.next) {\n              case 0:\n                _extractCommitmentFro12 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro12.commitment, config = _extractCommitmentFro12.config;\n                args = this._buildArgs([], commitment, undefined\n                /* encoding */\n                , config);\n                _context42.next = 4;\n                return this._rpcRequest('getEpochInfo', args);\n\n              case 4:\n                unsafeRes = _context42.sent;\n                res = create(unsafeRes, GetEpochInfoRpcResult);\n\n                if (!('error' in res)) {\n                  _context42.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get epoch info: ' + res.error.message);\n\n              case 8:\n                return _context42.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context42.stop();\n            }\n          }\n        }, _callee42, this);\n      }));\n\n      function getEpochInfo(_x75) {\n        return _getEpochInfo.apply(this, arguments);\n      }\n\n      return getEpochInfo;\n    }()\n    /**\n     * Fetch the Epoch Schedule parameters\n     */\n\n  }, {\n    key: \"getEpochSchedule\",\n    value: function () {\n      var _getEpochSchedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {\n        var unsafeRes, res, epochSchedule;\n        return _regeneratorRuntime().wrap(function _callee43$(_context43) {\n          while (1) {\n            switch (_context43.prev = _context43.next) {\n              case 0:\n                _context43.next = 2;\n                return this._rpcRequest('getEpochSchedule', []);\n\n              case 2:\n                unsafeRes = _context43.sent;\n                res = create(unsafeRes, GetEpochScheduleRpcResult);\n\n                if (!('error' in res)) {\n                  _context43.next = 6;\n                  break;\n                }\n\n                throw new Error('failed to get epoch schedule: ' + res.error.message);\n\n              case 6:\n                epochSchedule = res.result;\n                return _context43.abrupt(\"return\", new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot));\n\n              case 8:\n              case \"end\":\n                return _context43.stop();\n            }\n          }\n        }, _callee43, this);\n      }));\n\n      function getEpochSchedule() {\n        return _getEpochSchedule.apply(this, arguments);\n      }\n\n      return getEpochSchedule;\n    }()\n    /**\n     * Fetch the leader schedule for the current epoch\n     * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n     */\n\n  }, {\n    key: \"getLeaderSchedule\",\n    value: function () {\n      var _getLeaderSchedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44() {\n        var unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee44$(_context44) {\n          while (1) {\n            switch (_context44.prev = _context44.next) {\n              case 0:\n                _context44.next = 2;\n                return this._rpcRequest('getLeaderSchedule', []);\n\n              case 2:\n                unsafeRes = _context44.sent;\n                res = create(unsafeRes, GetLeaderScheduleRpcResult);\n\n                if (!('error' in res)) {\n                  _context44.next = 6;\n                  break;\n                }\n\n                throw new Error('failed to get leader schedule: ' + res.error.message);\n\n              case 6:\n                return _context44.abrupt(\"return\", res.result);\n\n              case 7:\n              case \"end\":\n                return _context44.stop();\n            }\n          }\n        }, _callee44, this);\n      }));\n\n      function getLeaderSchedule() {\n        return _getLeaderSchedule.apply(this, arguments);\n      }\n\n      return getLeaderSchedule;\n    }()\n    /**\n     * Fetch the minimum balance needed to exempt an account of `dataLength`\n     * size from rent\n     */\n\n  }, {\n    key: \"getMinimumBalanceForRentExemption\",\n    value: function () {\n      var _getMinimumBalanceForRentExemption = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45(dataLength, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee45$(_context45) {\n          while (1) {\n            switch (_context45.prev = _context45.next) {\n              case 0:\n                args = this._buildArgs([dataLength], commitment);\n                _context45.next = 3;\n                return this._rpcRequest('getMinimumBalanceForRentExemption', args);\n\n              case 3:\n                unsafeRes = _context45.sent;\n                res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n\n                if (!('error' in res)) {\n                  _context45.next = 8;\n                  break;\n                }\n\n                console.warn('Unable to fetch minimum balance for rent exemption');\n                return _context45.abrupt(\"return\", 0);\n\n              case 8:\n                return _context45.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context45.stop();\n            }\n          }\n        }, _callee45, this);\n      }));\n\n      function getMinimumBalanceForRentExemption(_x76, _x77) {\n        return _getMinimumBalanceForRentExemption.apply(this, arguments);\n      }\n\n      return getMinimumBalanceForRentExemption;\n    }()\n    /**\n     * Fetch a recent blockhash from the cluster, return with context\n     * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n     */\n\n  }, {\n    key: \"getRecentBlockhashAndContext\",\n    value: function () {\n      var _getRecentBlockhashAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee46$(_context46) {\n          while (1) {\n            switch (_context46.prev = _context46.next) {\n              case 0:\n                args = this._buildArgs([], commitment);\n                _context46.next = 3;\n                return this._rpcRequest('getRecentBlockhash', args);\n\n              case 3:\n                unsafeRes = _context46.sent;\n                res = create(unsafeRes, GetRecentBlockhashAndContextRpcResult);\n\n                if (!('error' in res)) {\n                  _context46.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get recent blockhash: ' + res.error.message);\n\n              case 7:\n                return _context46.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context46.stop();\n            }\n          }\n        }, _callee46, this);\n      }));\n\n      function getRecentBlockhashAndContext(_x78) {\n        return _getRecentBlockhashAndContext.apply(this, arguments);\n      }\n\n      return getRecentBlockhashAndContext;\n    }()\n    /**\n     * Fetch recent performance samples\n     * @return {Promise<Array<PerfSample>>}\n     */\n\n  }, {\n    key: \"getRecentPerformanceSamples\",\n    value: function () {\n      var _getRecentPerformanceSamples = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47(limit) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee47$(_context47) {\n          while (1) {\n            switch (_context47.prev = _context47.next) {\n              case 0:\n                args = this._buildArgs(limit ? [limit] : []);\n                _context47.next = 3;\n                return this._rpcRequest('getRecentPerformanceSamples', args);\n\n              case 3:\n                unsafeRes = _context47.sent;\n                res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n\n                if (!('error' in res)) {\n                  _context47.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get recent performance samples: ' + res.error.message);\n\n              case 7:\n                return _context47.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context47.stop();\n            }\n          }\n        }, _callee47, this);\n      }));\n\n      function getRecentPerformanceSamples(_x79) {\n        return _getRecentPerformanceSamples.apply(this, arguments);\n      }\n\n      return getRecentPerformanceSamples;\n    }()\n    /**\n     * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.\n     */\n\n  }, {\n    key: \"getFeeCalculatorForBlockhash\",\n    value: function () {\n      var _getFeeCalculatorForBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee48(blockhash, commitment) {\n        var args, unsafeRes, res, _res$result, context, value;\n\n        return _regeneratorRuntime().wrap(function _callee48$(_context48) {\n          while (1) {\n            switch (_context48.prev = _context48.next) {\n              case 0:\n                args = this._buildArgs([blockhash], commitment);\n                _context48.next = 3;\n                return this._rpcRequest('getFeeCalculatorForBlockhash', args);\n\n              case 3:\n                unsafeRes = _context48.sent;\n                res = create(unsafeRes, GetFeeCalculatorRpcResult);\n\n                if (!('error' in res)) {\n                  _context48.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get fee calculator: ' + res.error.message);\n\n              case 7:\n                _res$result = res.result, context = _res$result.context, value = _res$result.value;\n                return _context48.abrupt(\"return\", {\n                  context: context,\n                  value: value !== null ? value.feeCalculator : null\n                });\n\n              case 9:\n              case \"end\":\n                return _context48.stop();\n            }\n          }\n        }, _callee48, this);\n      }));\n\n      function getFeeCalculatorForBlockhash(_x80, _x81) {\n        return _getFeeCalculatorForBlockhash.apply(this, arguments);\n      }\n\n      return getFeeCalculatorForBlockhash;\n    }()\n    /**\n     * Fetch the fee for a message from the cluster, return with context\n     */\n\n  }, {\n    key: \"getFeeForMessage\",\n    value: function () {\n      var _getFeeForMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee49(message, commitment) {\n        var wireMessage, args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee49$(_context49) {\n          while (1) {\n            switch (_context49.prev = _context49.next) {\n              case 0:\n                wireMessage = message.serialize().toString('base64');\n                args = this._buildArgs([wireMessage], commitment);\n                _context49.next = 4;\n                return this._rpcRequest('getFeeForMessage', args);\n\n              case 4:\n                unsafeRes = _context49.sent;\n                res = create(unsafeRes, jsonRpcResultAndContext(nullable(number())));\n\n                if (!('error' in res)) {\n                  _context49.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get slot: ' + res.error.message);\n\n              case 8:\n                if (!(res.result === null)) {\n                  _context49.next = 10;\n                  break;\n                }\n\n                throw new Error('invalid blockhash');\n\n              case 10:\n                return _context49.abrupt(\"return\", res.result);\n\n              case 11:\n              case \"end\":\n                return _context49.stop();\n            }\n          }\n        }, _callee49, this);\n      }));\n\n      function getFeeForMessage(_x82, _x83) {\n        return _getFeeForMessage.apply(this, arguments);\n      }\n\n      return getFeeForMessage;\n    }()\n    /**\n     * Fetch a recent blockhash from the cluster\n     * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n     */\n\n  }, {\n    key: \"getRecentBlockhash\",\n    value: function () {\n      var _getRecentBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee50(commitment) {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee50$(_context50) {\n          while (1) {\n            switch (_context50.prev = _context50.next) {\n              case 0:\n                _context50.prev = 0;\n                _context50.next = 3;\n                return this.getRecentBlockhashAndContext(commitment);\n\n              case 3:\n                res = _context50.sent;\n                return _context50.abrupt(\"return\", res.value);\n\n              case 7:\n                _context50.prev = 7;\n                _context50.t0 = _context50[\"catch\"](0);\n                throw new Error('failed to get recent blockhash: ' + _context50.t0);\n\n              case 10:\n              case \"end\":\n                return _context50.stop();\n            }\n          }\n        }, _callee50, this, [[0, 7]]);\n      }));\n\n      function getRecentBlockhash(_x84) {\n        return _getRecentBlockhash.apply(this, arguments);\n      }\n\n      return getRecentBlockhash;\n    }()\n    /**\n     * Fetch the latest blockhash from the cluster\n     * @return {Promise<BlockhashWithExpiryBlockHeight>}\n     */\n\n  }, {\n    key: \"getLatestBlockhash\",\n    value: function () {\n      var _getLatestBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee51(commitmentOrConfig) {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee51$(_context51) {\n          while (1) {\n            switch (_context51.prev = _context51.next) {\n              case 0:\n                _context51.prev = 0;\n                _context51.next = 3;\n                return this.getLatestBlockhashAndContext(commitmentOrConfig);\n\n              case 3:\n                res = _context51.sent;\n                return _context51.abrupt(\"return\", res.value);\n\n              case 7:\n                _context51.prev = 7;\n                _context51.t0 = _context51[\"catch\"](0);\n                throw new Error('failed to get recent blockhash: ' + _context51.t0);\n\n              case 10:\n              case \"end\":\n                return _context51.stop();\n            }\n          }\n        }, _callee51, this, [[0, 7]]);\n      }));\n\n      function getLatestBlockhash(_x85) {\n        return _getLatestBlockhash.apply(this, arguments);\n      }\n\n      return getLatestBlockhash;\n    }()\n    /**\n     * Fetch the latest blockhash from the cluster\n     * @return {Promise<BlockhashWithExpiryBlockHeight>}\n     */\n\n  }, {\n    key: \"getLatestBlockhashAndContext\",\n    value: function () {\n      var _getLatestBlockhashAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee52(commitmentOrConfig) {\n        var _extractCommitmentFro13, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee52$(_context52) {\n          while (1) {\n            switch (_context52.prev = _context52.next) {\n              case 0:\n                _extractCommitmentFro13 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro13.commitment, config = _extractCommitmentFro13.config;\n                args = this._buildArgs([], commitment, undefined\n                /* encoding */\n                , config);\n                _context52.next = 4;\n                return this._rpcRequest('getLatestBlockhash', args);\n\n              case 4:\n                unsafeRes = _context52.sent;\n                res = create(unsafeRes, GetLatestBlockhashRpcResult);\n\n                if (!('error' in res)) {\n                  _context52.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get latest blockhash: ' + res.error.message);\n\n              case 8:\n                return _context52.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context52.stop();\n            }\n          }\n        }, _callee52, this);\n      }));\n\n      function getLatestBlockhashAndContext(_x86) {\n        return _getLatestBlockhashAndContext.apply(this, arguments);\n      }\n\n      return getLatestBlockhashAndContext;\n    }()\n    /**\n     * Fetch the node version\n     */\n\n  }, {\n    key: \"getVersion\",\n    value: function () {\n      var _getVersion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee53() {\n        var unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee53$(_context53) {\n          while (1) {\n            switch (_context53.prev = _context53.next) {\n              case 0:\n                _context53.next = 2;\n                return this._rpcRequest('getVersion', []);\n\n              case 2:\n                unsafeRes = _context53.sent;\n                res = create(unsafeRes, jsonRpcResult(VersionResult));\n\n                if (!('error' in res)) {\n                  _context53.next = 6;\n                  break;\n                }\n\n                throw new Error('failed to get version: ' + res.error.message);\n\n              case 6:\n                return _context53.abrupt(\"return\", res.result);\n\n              case 7:\n              case \"end\":\n                return _context53.stop();\n            }\n          }\n        }, _callee53, this);\n      }));\n\n      function getVersion() {\n        return _getVersion.apply(this, arguments);\n      }\n\n      return getVersion;\n    }()\n    /**\n     * Fetch the genesis hash\n     */\n\n  }, {\n    key: \"getGenesisHash\",\n    value: function () {\n      var _getGenesisHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee54() {\n        var unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee54$(_context54) {\n          while (1) {\n            switch (_context54.prev = _context54.next) {\n              case 0:\n                _context54.next = 2;\n                return this._rpcRequest('getGenesisHash', []);\n\n              case 2:\n                unsafeRes = _context54.sent;\n                res = create(unsafeRes, jsonRpcResult(string()));\n\n                if (!('error' in res)) {\n                  _context54.next = 6;\n                  break;\n                }\n\n                throw new Error('failed to get genesis hash: ' + res.error.message);\n\n              case 6:\n                return _context54.abrupt(\"return\", res.result);\n\n              case 7:\n              case \"end\":\n                return _context54.stop();\n            }\n          }\n        }, _callee54, this);\n      }));\n\n      function getGenesisHash() {\n        return _getGenesisHash.apply(this, arguments);\n      }\n\n      return getGenesisHash;\n    }()\n    /**\n     * Fetch a processed block from the cluster.\n     */\n\n  }, {\n    key: \"getBlock\",\n    value: function () {\n      var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee55(slot, opts) {\n        var args, unsafeRes, res, result;\n        return _regeneratorRuntime().wrap(function _callee55$(_context55) {\n          while (1) {\n            switch (_context55.prev = _context55.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed([slot], opts && opts.commitment);\n                _context55.next = 3;\n                return this._rpcRequest('getBlock', args);\n\n              case 3:\n                unsafeRes = _context55.sent;\n                res = create(unsafeRes, GetBlockRpcResult);\n\n                if (!('error' in res)) {\n                  _context55.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get confirmed block: ' + res.error.message);\n\n              case 7:\n                result = res.result;\n\n                if (result) {\n                  _context55.next = 10;\n                  break;\n                }\n\n                return _context55.abrupt(\"return\", result);\n\n              case 10:\n                return _context55.abrupt(\"return\", _objectSpread({}, result, {\n                  transactions: result.transactions.map(function (_ref10) {\n                    var transaction = _ref10.transaction,\n                        meta = _ref10.meta;\n                    var message = new Message(transaction.message);\n                    return {\n                      meta: meta,\n                      transaction: _objectSpread({}, transaction, {\n                        message: message\n                      })\n                    };\n                  })\n                }));\n\n              case 11:\n              case \"end\":\n                return _context55.stop();\n            }\n          }\n        }, _callee55, this);\n      }));\n\n      function getBlock(_x87, _x88) {\n        return _getBlock.apply(this, arguments);\n      }\n\n      return getBlock;\n    }()\n    /*\n     * Returns the current block height of the node\n     */\n\n  }, {\n    key: \"getBlockHeight\",\n    value: function () {\n      var _getBlockHeight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee56(commitmentOrConfig) {\n        var _extractCommitmentFro14, commitment, config, args, unsafeRes, res;\n\n        return _regeneratorRuntime().wrap(function _callee56$(_context56) {\n          while (1) {\n            switch (_context56.prev = _context56.next) {\n              case 0:\n                _extractCommitmentFro14 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro14.commitment, config = _extractCommitmentFro14.config;\n                args = this._buildArgs([], commitment, undefined\n                /* encoding */\n                , config);\n                _context56.next = 4;\n                return this._rpcRequest('getBlockHeight', args);\n\n              case 4:\n                unsafeRes = _context56.sent;\n                res = create(unsafeRes, jsonRpcResult(number()));\n\n                if (!('error' in res)) {\n                  _context56.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get block height information: ' + res.error.message);\n\n              case 8:\n                return _context56.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context56.stop();\n            }\n          }\n        }, _callee56, this);\n      }));\n\n      function getBlockHeight(_x89) {\n        return _getBlockHeight.apply(this, arguments);\n      }\n\n      return getBlockHeight;\n    }()\n    /*\n     * Returns recent block production information from the current or previous epoch\n     */\n\n  }, {\n    key: \"getBlockProduction\",\n    value: function () {\n      var _getBlockProduction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee57(configOrCommitment) {\n        var extra, commitment, c, rest, args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee57$(_context57) {\n          while (1) {\n            switch (_context57.prev = _context57.next) {\n              case 0:\n                if (typeof configOrCommitment === 'string') {\n                  commitment = configOrCommitment;\n                } else if (configOrCommitment) {\n                  c = configOrCommitment.commitment, rest = _objectWithoutProperties(configOrCommitment, [\"commitment\"]);\n                  commitment = c;\n                  extra = rest;\n                }\n\n                args = this._buildArgs([], commitment, 'base64', extra);\n                _context57.next = 4;\n                return this._rpcRequest('getBlockProduction', args);\n\n              case 4:\n                unsafeRes = _context57.sent;\n                res = create(unsafeRes, BlockProductionResponseStruct);\n\n                if (!('error' in res)) {\n                  _context57.next = 8;\n                  break;\n                }\n\n                throw new Error('failed to get block production information: ' + res.error.message);\n\n              case 8:\n                return _context57.abrupt(\"return\", res.result);\n\n              case 9:\n              case \"end\":\n                return _context57.stop();\n            }\n          }\n        }, _callee57, this);\n      }));\n\n      function getBlockProduction(_x90) {\n        return _getBlockProduction.apply(this, arguments);\n      }\n\n      return getBlockProduction;\n    }()\n    /**\n     * Fetch a confirmed or finalized transaction from the cluster.\n     */\n\n  }, {\n    key: \"getTransaction\",\n    value: function () {\n      var _getTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee58(signature, opts) {\n        var args, unsafeRes, res, result;\n        return _regeneratorRuntime().wrap(function _callee58$(_context58) {\n          while (1) {\n            switch (_context58.prev = _context58.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed([signature], opts && opts.commitment);\n                _context58.next = 3;\n                return this._rpcRequest('getTransaction', args);\n\n              case 3:\n                unsafeRes = _context58.sent;\n                res = create(unsafeRes, GetTransactionRpcResult);\n\n                if (!('error' in res)) {\n                  _context58.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get transaction: ' + res.error.message);\n\n              case 7:\n                result = res.result;\n\n                if (result) {\n                  _context58.next = 10;\n                  break;\n                }\n\n                return _context58.abrupt(\"return\", result);\n\n              case 10:\n                return _context58.abrupt(\"return\", _objectSpread({}, result, {\n                  transaction: _objectSpread({}, result.transaction, {\n                    message: new Message(result.transaction.message)\n                  })\n                }));\n\n              case 11:\n              case \"end\":\n                return _context58.stop();\n            }\n          }\n        }, _callee58, this);\n      }));\n\n      function getTransaction(_x91, _x92) {\n        return _getTransaction.apply(this, arguments);\n      }\n\n      return getTransaction;\n    }()\n    /**\n     * Fetch parsed transaction details for a confirmed or finalized transaction\n     */\n\n  }, {\n    key: \"getParsedTransaction\",\n    value: function () {\n      var _getParsedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee59(signature, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee59$(_context59) {\n          while (1) {\n            switch (_context59.prev = _context59.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n                _context59.next = 3;\n                return this._rpcRequest('getTransaction', args);\n\n              case 3:\n                unsafeRes = _context59.sent;\n                res = create(unsafeRes, GetParsedTransactionRpcResult);\n\n                if (!('error' in res)) {\n                  _context59.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get transaction: ' + res.error.message);\n\n              case 7:\n                return _context59.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context59.stop();\n            }\n          }\n        }, _callee59, this);\n      }));\n\n      function getParsedTransaction(_x93, _x94) {\n        return _getParsedTransaction.apply(this, arguments);\n      }\n\n      return getParsedTransaction;\n    }()\n    /**\n     * Fetch parsed transaction details for a batch of confirmed transactions\n     */\n\n  }, {\n    key: \"getParsedTransactions\",\n    value: function () {\n      var _getParsedTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee60(signatures, commitment) {\n        var _this11 = this;\n\n        var batch, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee60$(_context60) {\n          while (1) {\n            switch (_context60.prev = _context60.next) {\n              case 0:\n                batch = signatures.map(function (signature) {\n                  var args = _this11._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n\n                  return {\n                    methodName: 'getTransaction',\n                    args: args\n                  };\n                });\n                _context60.next = 3;\n                return this._rpcBatchRequest(batch);\n\n              case 3:\n                unsafeRes = _context60.sent;\n                res = unsafeRes.map(function (unsafeRes) {\n                  var res = create(unsafeRes, GetParsedTransactionRpcResult);\n\n                  if ('error' in res) {\n                    throw new Error('failed to get transactions: ' + res.error.message);\n                  }\n\n                  return res.result;\n                });\n                return _context60.abrupt(\"return\", res);\n\n              case 6:\n              case \"end\":\n                return _context60.stop();\n            }\n          }\n        }, _callee60, this);\n      }));\n\n      function getParsedTransactions(_x95, _x96) {\n        return _getParsedTransactions.apply(this, arguments);\n      }\n\n      return getParsedTransactions;\n    }()\n    /**\n     * Fetch transaction details for a batch of confirmed transactions.\n     * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n     */\n\n  }, {\n    key: \"getTransactions\",\n    value: function () {\n      var _getTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee61(signatures, commitment) {\n        var _this12 = this;\n\n        var batch, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee61$(_context61) {\n          while (1) {\n            switch (_context61.prev = _context61.next) {\n              case 0:\n                batch = signatures.map(function (signature) {\n                  var args = _this12._buildArgsAtLeastConfirmed([signature], commitment);\n\n                  return {\n                    methodName: 'getTransaction',\n                    args: args\n                  };\n                });\n                _context61.next = 3;\n                return this._rpcBatchRequest(batch);\n\n              case 3:\n                unsafeRes = _context61.sent;\n                res = unsafeRes.map(function (unsafeRes) {\n                  var res = create(unsafeRes, GetTransactionRpcResult);\n\n                  if ('error' in res) {\n                    throw new Error('failed to get transactions: ' + res.error.message);\n                  }\n\n                  var result = res.result;\n                  if (!result) return result;\n                  return _objectSpread({}, result, {\n                    transaction: _objectSpread({}, result.transaction, {\n                      message: new Message(result.transaction.message)\n                    })\n                  });\n                });\n                return _context61.abrupt(\"return\", res);\n\n              case 6:\n              case \"end\":\n                return _context61.stop();\n            }\n          }\n        }, _callee61, this);\n      }));\n\n      function getTransactions(_x97, _x98) {\n        return _getTransactions.apply(this, arguments);\n      }\n\n      return getTransactions;\n    }()\n    /**\n     * Fetch a list of Transactions and transaction statuses from the cluster\n     * for a confirmed block.\n     *\n     * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.\n     */\n\n  }, {\n    key: \"getConfirmedBlock\",\n    value: function () {\n      var _getConfirmedBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee62(slot, commitment) {\n        var args, unsafeRes, res, result, block;\n        return _regeneratorRuntime().wrap(function _callee62$(_context62) {\n          while (1) {\n            switch (_context62.prev = _context62.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed([slot], commitment);\n                _context62.next = 3;\n                return this._rpcRequest('getConfirmedBlock', args);\n\n              case 3:\n                unsafeRes = _context62.sent;\n                res = create(unsafeRes, GetConfirmedBlockRpcResult);\n\n                if (!('error' in res)) {\n                  _context62.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get confirmed block: ' + res.error.message);\n\n              case 7:\n                result = res.result;\n\n                if (result) {\n                  _context62.next = 10;\n                  break;\n                }\n\n                throw new Error('Confirmed block ' + slot + ' not found');\n\n              case 10:\n                block = _objectSpread({}, result, {\n                  transactions: result.transactions.map(function (_ref11) {\n                    var transaction = _ref11.transaction,\n                        meta = _ref11.meta;\n                    var message = new Message(transaction.message);\n                    return {\n                      meta: meta,\n                      transaction: _objectSpread({}, transaction, {\n                        message: message\n                      })\n                    };\n                  })\n                });\n                return _context62.abrupt(\"return\", _objectSpread({}, block, {\n                  transactions: block.transactions.map(function (_ref12) {\n                    var transaction = _ref12.transaction,\n                        meta = _ref12.meta;\n                    return {\n                      meta: meta,\n                      transaction: Transaction.populate(transaction.message, transaction.signatures)\n                    };\n                  })\n                }));\n\n              case 12:\n              case \"end\":\n                return _context62.stop();\n            }\n          }\n        }, _callee62, this);\n      }));\n\n      function getConfirmedBlock(_x99, _x100) {\n        return _getConfirmedBlock.apply(this, arguments);\n      }\n\n      return getConfirmedBlock;\n    }()\n    /**\n     * Fetch confirmed blocks between two slots\n     */\n\n  }, {\n    key: \"getBlocks\",\n    value: function () {\n      var _getBlocks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee63(startSlot, endSlot, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee63$(_context63) {\n          while (1) {\n            switch (_context63.prev = _context63.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);\n                _context63.next = 3;\n                return this._rpcRequest('getBlocks', args);\n\n              case 3:\n                unsafeRes = _context63.sent;\n                res = create(unsafeRes, jsonRpcResult(array(number())));\n\n                if (!('error' in res)) {\n                  _context63.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get blocks: ' + res.error.message);\n\n              case 7:\n                return _context63.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context63.stop();\n            }\n          }\n        }, _callee63, this);\n      }));\n\n      function getBlocks(_x101, _x102, _x103) {\n        return _getBlocks.apply(this, arguments);\n      }\n\n      return getBlocks;\n    }()\n    /**\n     * Fetch a list of Signatures from the cluster for a block, excluding rewards\n     */\n\n  }, {\n    key: \"getBlockSignatures\",\n    value: function () {\n      var _getBlockSignatures = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee64(slot, commitment) {\n        var args, unsafeRes, res, result;\n        return _regeneratorRuntime().wrap(function _callee64$(_context64) {\n          while (1) {\n            switch (_context64.prev = _context64.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {\n                  transactionDetails: 'signatures',\n                  rewards: false\n                });\n                _context64.next = 3;\n                return this._rpcRequest('getBlock', args);\n\n              case 3:\n                unsafeRes = _context64.sent;\n                res = create(unsafeRes, GetBlockSignaturesRpcResult);\n\n                if (!('error' in res)) {\n                  _context64.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get block: ' + res.error.message);\n\n              case 7:\n                result = res.result;\n\n                if (result) {\n                  _context64.next = 10;\n                  break;\n                }\n\n                throw new Error('Block ' + slot + ' not found');\n\n              case 10:\n                return _context64.abrupt(\"return\", result);\n\n              case 11:\n              case \"end\":\n                return _context64.stop();\n            }\n          }\n        }, _callee64, this);\n      }));\n\n      function getBlockSignatures(_x104, _x105) {\n        return _getBlockSignatures.apply(this, arguments);\n      }\n\n      return getBlockSignatures;\n    }()\n    /**\n     * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.\n     */\n\n  }, {\n    key: \"getConfirmedBlockSignatures\",\n    value: function () {\n      var _getConfirmedBlockSignatures = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee65(slot, commitment) {\n        var args, unsafeRes, res, result;\n        return _regeneratorRuntime().wrap(function _callee65$(_context65) {\n          while (1) {\n            switch (_context65.prev = _context65.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {\n                  transactionDetails: 'signatures',\n                  rewards: false\n                });\n                _context65.next = 3;\n                return this._rpcRequest('getConfirmedBlock', args);\n\n              case 3:\n                unsafeRes = _context65.sent;\n                res = create(unsafeRes, GetBlockSignaturesRpcResult);\n\n                if (!('error' in res)) {\n                  _context65.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get confirmed block: ' + res.error.message);\n\n              case 7:\n                result = res.result;\n\n                if (result) {\n                  _context65.next = 10;\n                  break;\n                }\n\n                throw new Error('Confirmed block ' + slot + ' not found');\n\n              case 10:\n                return _context65.abrupt(\"return\", result);\n\n              case 11:\n              case \"end\":\n                return _context65.stop();\n            }\n          }\n        }, _callee65, this);\n      }));\n\n      function getConfirmedBlockSignatures(_x106, _x107) {\n        return _getConfirmedBlockSignatures.apply(this, arguments);\n      }\n\n      return getConfirmedBlockSignatures;\n    }()\n    /**\n     * Fetch a transaction details for a confirmed transaction\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.\n     */\n\n  }, {\n    key: \"getConfirmedTransaction\",\n    value: function () {\n      var _getConfirmedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee66(signature, commitment) {\n        var args, unsafeRes, res, result, message, signatures;\n        return _regeneratorRuntime().wrap(function _callee66$(_context66) {\n          while (1) {\n            switch (_context66.prev = _context66.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed([signature], commitment);\n                _context66.next = 3;\n                return this._rpcRequest('getConfirmedTransaction', args);\n\n              case 3:\n                unsafeRes = _context66.sent;\n                res = create(unsafeRes, GetTransactionRpcResult);\n\n                if (!('error' in res)) {\n                  _context66.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get transaction: ' + res.error.message);\n\n              case 7:\n                result = res.result;\n\n                if (result) {\n                  _context66.next = 10;\n                  break;\n                }\n\n                return _context66.abrupt(\"return\", result);\n\n              case 10:\n                message = new Message(result.transaction.message);\n                signatures = result.transaction.signatures;\n                return _context66.abrupt(\"return\", _objectSpread({}, result, {\n                  transaction: Transaction.populate(message, signatures)\n                }));\n\n              case 13:\n              case \"end\":\n                return _context66.stop();\n            }\n          }\n        }, _callee66, this);\n      }));\n\n      function getConfirmedTransaction(_x108, _x109) {\n        return _getConfirmedTransaction.apply(this, arguments);\n      }\n\n      return getConfirmedTransaction;\n    }()\n    /**\n     * Fetch parsed transaction details for a confirmed transaction\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.\n     */\n\n  }, {\n    key: \"getParsedConfirmedTransaction\",\n    value: function () {\n      var _getParsedConfirmedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee67(signature, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee67$(_context67) {\n          while (1) {\n            switch (_context67.prev = _context67.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n                _context67.next = 3;\n                return this._rpcRequest('getConfirmedTransaction', args);\n\n              case 3:\n                unsafeRes = _context67.sent;\n                res = create(unsafeRes, GetParsedTransactionRpcResult);\n\n                if (!('error' in res)) {\n                  _context67.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get confirmed transaction: ' + res.error.message);\n\n              case 7:\n                return _context67.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context67.stop();\n            }\n          }\n        }, _callee67, this);\n      }));\n\n      function getParsedConfirmedTransaction(_x110, _x111) {\n        return _getParsedConfirmedTransaction.apply(this, arguments);\n      }\n\n      return getParsedConfirmedTransaction;\n    }()\n    /**\n     * Fetch parsed transaction details for a batch of confirmed transactions\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.\n     */\n\n  }, {\n    key: \"getParsedConfirmedTransactions\",\n    value: function () {\n      var _getParsedConfirmedTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee68(signatures, commitment) {\n        var _this13 = this;\n\n        var batch, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee68$(_context68) {\n          while (1) {\n            switch (_context68.prev = _context68.next) {\n              case 0:\n                batch = signatures.map(function (signature) {\n                  var args = _this13._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n\n                  return {\n                    methodName: 'getConfirmedTransaction',\n                    args: args\n                  };\n                });\n                _context68.next = 3;\n                return this._rpcBatchRequest(batch);\n\n              case 3:\n                unsafeRes = _context68.sent;\n                res = unsafeRes.map(function (unsafeRes) {\n                  var res = create(unsafeRes, GetParsedTransactionRpcResult);\n\n                  if ('error' in res) {\n                    throw new Error('failed to get confirmed transactions: ' + res.error.message);\n                  }\n\n                  return res.result;\n                });\n                return _context68.abrupt(\"return\", res);\n\n              case 6:\n              case \"end\":\n                return _context68.stop();\n            }\n          }\n        }, _callee68, this);\n      }));\n\n      function getParsedConfirmedTransactions(_x112, _x113) {\n        return _getParsedConfirmedTransactions.apply(this, arguments);\n      }\n\n      return getParsedConfirmedTransactions;\n    }()\n    /**\n     * Fetch a list of all the confirmed signatures for transactions involving an address\n     * within a specified slot range. Max range allowed is 10,000 slots.\n     *\n     * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n     *\n     * @param address queried address\n     * @param startSlot start slot, inclusive\n     * @param endSlot end slot, inclusive\n     */\n\n  }, {\n    key: \"getConfirmedSignaturesForAddress\",\n    value: function () {\n      var _getConfirmedSignaturesForAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee69(address, startSlot, endSlot) {\n        var options, firstAvailableBlock, block, highestConfirmedRoot, _block, confirmedSignatureInfo;\n\n        return _regeneratorRuntime().wrap(function _callee69$(_context69) {\n          while (1) {\n            switch (_context69.prev = _context69.next) {\n              case 0:\n                options = {};\n                _context69.next = 3;\n                return this.getFirstAvailableBlock();\n\n              case 3:\n                firstAvailableBlock = _context69.sent;\n\n              case 4:\n                if ('until' in options) {\n                  _context69.next = 24;\n                  break;\n                }\n\n                startSlot--;\n\n                if (!(startSlot <= 0 || startSlot < firstAvailableBlock)) {\n                  _context69.next = 8;\n                  break;\n                }\n\n                return _context69.abrupt(\"break\", 24);\n\n              case 8:\n                _context69.prev = 8;\n                _context69.next = 11;\n                return this.getConfirmedBlockSignatures(startSlot, 'finalized');\n\n              case 11:\n                block = _context69.sent;\n\n                if (block.signatures.length > 0) {\n                  options.until = block.signatures[block.signatures.length - 1].toString();\n                }\n\n                _context69.next = 22;\n                break;\n\n              case 15:\n                _context69.prev = 15;\n                _context69.t0 = _context69[\"catch\"](8);\n\n                if (!(_context69.t0 instanceof Error && _context69.t0.message.includes('skipped'))) {\n                  _context69.next = 21;\n                  break;\n                }\n\n                return _context69.abrupt(\"continue\", 4);\n\n              case 21:\n                throw _context69.t0;\n\n              case 22:\n                _context69.next = 4;\n                break;\n\n              case 24:\n                _context69.next = 26;\n                return this.getSlot('finalized');\n\n              case 26:\n                highestConfirmedRoot = _context69.sent;\n\n              case 27:\n                if ('before' in options) {\n                  _context69.next = 47;\n                  break;\n                }\n\n                endSlot++;\n\n                if (!(endSlot > highestConfirmedRoot)) {\n                  _context69.next = 31;\n                  break;\n                }\n\n                return _context69.abrupt(\"break\", 47);\n\n              case 31:\n                _context69.prev = 31;\n                _context69.next = 34;\n                return this.getConfirmedBlockSignatures(endSlot);\n\n              case 34:\n                _block = _context69.sent;\n\n                if (_block.signatures.length > 0) {\n                  options.before = _block.signatures[_block.signatures.length - 1].toString();\n                }\n\n                _context69.next = 45;\n                break;\n\n              case 38:\n                _context69.prev = 38;\n                _context69.t1 = _context69[\"catch\"](31);\n\n                if (!(_context69.t1 instanceof Error && _context69.t1.message.includes('skipped'))) {\n                  _context69.next = 44;\n                  break;\n                }\n\n                return _context69.abrupt(\"continue\", 27);\n\n              case 44:\n                throw _context69.t1;\n\n              case 45:\n                _context69.next = 27;\n                break;\n\n              case 47:\n                _context69.next = 49;\n                return this.getConfirmedSignaturesForAddress2(address, options);\n\n              case 49:\n                confirmedSignatureInfo = _context69.sent;\n                return _context69.abrupt(\"return\", confirmedSignatureInfo.map(function (info) {\n                  return info.signature;\n                }));\n\n              case 51:\n              case \"end\":\n                return _context69.stop();\n            }\n          }\n        }, _callee69, this, [[8, 15], [31, 38]]);\n      }));\n\n      function getConfirmedSignaturesForAddress(_x114, _x115, _x116) {\n        return _getConfirmedSignaturesForAddress.apply(this, arguments);\n      }\n\n      return getConfirmedSignaturesForAddress;\n    }()\n    /**\n     * Returns confirmed signatures for transactions involving an\n     * address backwards in time from the provided signature or most recent confirmed block\n     *\n     *\n     * @param address queried address\n     * @param options\n     */\n\n  }, {\n    key: \"getConfirmedSignaturesForAddress2\",\n    value: function () {\n      var _getConfirmedSignaturesForAddress2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee70(address, options, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee70$(_context70) {\n          while (1) {\n            switch (_context70.prev = _context70.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);\n                _context70.next = 3;\n                return this._rpcRequest('getConfirmedSignaturesForAddress2', args);\n\n              case 3:\n                unsafeRes = _context70.sent;\n                res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n\n                if (!('error' in res)) {\n                  _context70.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get confirmed signatures for address: ' + res.error.message);\n\n              case 7:\n                return _context70.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context70.stop();\n            }\n          }\n        }, _callee70, this);\n      }));\n\n      function getConfirmedSignaturesForAddress2(_x117, _x118, _x119) {\n        return _getConfirmedSignaturesForAddress2.apply(this, arguments);\n      }\n\n      return getConfirmedSignaturesForAddress2;\n    }()\n    /**\n     * Returns confirmed signatures for transactions involving an\n     * address backwards in time from the provided signature or most recent confirmed block\n     *\n     *\n     * @param address queried address\n     * @param options\n     */\n\n  }, {\n    key: \"getSignaturesForAddress\",\n    value: function () {\n      var _getSignaturesForAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee71(address, options, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee71$(_context71) {\n          while (1) {\n            switch (_context71.prev = _context71.next) {\n              case 0:\n                args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);\n                _context71.next = 3;\n                return this._rpcRequest('getSignaturesForAddress', args);\n\n              case 3:\n                unsafeRes = _context71.sent;\n                res = create(unsafeRes, GetSignaturesForAddressRpcResult);\n\n                if (!('error' in res)) {\n                  _context71.next = 7;\n                  break;\n                }\n\n                throw new Error('failed to get signatures for address: ' + res.error.message);\n\n              case 7:\n                return _context71.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context71.stop();\n            }\n          }\n        }, _callee71, this);\n      }));\n\n      function getSignaturesForAddress(_x120, _x121, _x122) {\n        return _getSignaturesForAddress.apply(this, arguments);\n      }\n\n      return getSignaturesForAddress;\n    }()\n    /**\n     * Fetch the contents of a Nonce account from the cluster, return with context\n     */\n\n  }, {\n    key: \"getNonceAndContext\",\n    value: function () {\n      var _getNonceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee72(nonceAccount, commitment) {\n        var _yield$this$getAccoun, context, accountInfo, value;\n\n        return _regeneratorRuntime().wrap(function _callee72$(_context72) {\n          while (1) {\n            switch (_context72.prev = _context72.next) {\n              case 0:\n                _context72.next = 2;\n                return this.getAccountInfoAndContext(nonceAccount, commitment);\n\n              case 2:\n                _yield$this$getAccoun = _context72.sent;\n                context = _yield$this$getAccoun.context;\n                accountInfo = _yield$this$getAccoun.value;\n                value = null;\n\n                if (accountInfo !== null) {\n                  value = NonceAccount.fromAccountData(accountInfo.data);\n                }\n\n                return _context72.abrupt(\"return\", {\n                  context: context,\n                  value: value\n                });\n\n              case 8:\n              case \"end\":\n                return _context72.stop();\n            }\n          }\n        }, _callee72, this);\n      }));\n\n      function getNonceAndContext(_x123, _x124) {\n        return _getNonceAndContext.apply(this, arguments);\n      }\n\n      return getNonceAndContext;\n    }()\n    /**\n     * Fetch the contents of a Nonce account from the cluster\n     */\n\n  }, {\n    key: \"getNonce\",\n    value: function () {\n      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee73(nonceAccount, commitment) {\n        return _regeneratorRuntime().wrap(function _callee73$(_context73) {\n          while (1) {\n            switch (_context73.prev = _context73.next) {\n              case 0:\n                _context73.next = 2;\n                return this.getNonceAndContext(nonceAccount, commitment).then(function (x) {\n                  return x.value;\n                }).catch(function (e) {\n                  throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);\n                });\n\n              case 2:\n                return _context73.abrupt(\"return\", _context73.sent);\n\n              case 3:\n              case \"end\":\n                return _context73.stop();\n            }\n          }\n        }, _callee73, this);\n      }));\n\n      function getNonce(_x125, _x126) {\n        return _getNonce.apply(this, arguments);\n      }\n\n      return getNonce;\n    }()\n    /**\n     * Request an allocation of lamports to the specified address\n     *\n     * ```typescript\n     * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n     *\n     * (async () => {\n     *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n     *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n     *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n     *   await connection.confirmTransaction(signature);\n     * })();\n     * ```\n     */\n\n  }, {\n    key: \"requestAirdrop\",\n    value: function () {\n      var _requestAirdrop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee74(to, lamports) {\n        var unsafeRes, res;\n        return _regeneratorRuntime().wrap(function _callee74$(_context74) {\n          while (1) {\n            switch (_context74.prev = _context74.next) {\n              case 0:\n                _context74.next = 2;\n                return this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);\n\n              case 2:\n                unsafeRes = _context74.sent;\n                res = create(unsafeRes, RequestAirdropRpcResult);\n\n                if (!('error' in res)) {\n                  _context74.next = 6;\n                  break;\n                }\n\n                throw new Error('airdrop to ' + to.toBase58() + ' failed: ' + res.error.message);\n\n              case 6:\n                return _context74.abrupt(\"return\", res.result);\n\n              case 7:\n              case \"end\":\n                return _context74.stop();\n            }\n          }\n        }, _callee74, this);\n      }));\n\n      function requestAirdrop(_x127, _x128) {\n        return _requestAirdrop.apply(this, arguments);\n      }\n\n      return requestAirdrop;\n    }()\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_blockhashWithExpiryBlockHeight\",\n    value: function () {\n      var _blockhashWithExpiryBlockHeight2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee75(disableCache) {\n        var timeSinceFetch, expired;\n        return _regeneratorRuntime().wrap(function _callee75$(_context75) {\n          while (1) {\n            switch (_context75.prev = _context75.next) {\n              case 0:\n                if (disableCache) {\n                  _context75.next = 10;\n                  break;\n                }\n\n              case 1:\n                if (!this._pollingBlockhash) {\n                  _context75.next = 6;\n                  break;\n                }\n\n                _context75.next = 4;\n                return sleep(100);\n\n              case 4:\n                _context75.next = 1;\n                break;\n\n              case 6:\n                timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n                expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n\n                if (!(this._blockhashInfo.latestBlockhash !== null && !expired)) {\n                  _context75.next = 10;\n                  break;\n                }\n\n                return _context75.abrupt(\"return\", this._blockhashInfo.latestBlockhash);\n\n              case 10:\n                _context75.next = 12;\n                return this._pollNewBlockhash();\n\n              case 12:\n                return _context75.abrupt(\"return\", _context75.sent);\n\n              case 13:\n              case \"end\":\n                return _context75.stop();\n            }\n          }\n        }, _callee75, this);\n      }));\n\n      function _blockhashWithExpiryBlockHeight(_x129) {\n        return _blockhashWithExpiryBlockHeight2.apply(this, arguments);\n      }\n\n      return _blockhashWithExpiryBlockHeight;\n    }()\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_pollNewBlockhash\",\n    value: function () {\n      var _pollNewBlockhash2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee76() {\n        var startTime, cachedLatestBlockhash, cachedBlockhash, i, latestBlockhash;\n        return _regeneratorRuntime().wrap(function _callee76$(_context76) {\n          while (1) {\n            switch (_context76.prev = _context76.next) {\n              case 0:\n                this._pollingBlockhash = true;\n                _context76.prev = 1;\n                startTime = Date.now();\n                cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n                cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n                i = 0;\n\n              case 6:\n                if (!(i < 50)) {\n                  _context76.next = 18;\n                  break;\n                }\n\n                _context76.next = 9;\n                return this.getLatestBlockhash('finalized');\n\n              case 9:\n                latestBlockhash = _context76.sent;\n\n                if (!(cachedBlockhash !== latestBlockhash.blockhash)) {\n                  _context76.next = 13;\n                  break;\n                }\n\n                this._blockhashInfo = {\n                  latestBlockhash: latestBlockhash,\n                  lastFetch: Date.now(),\n                  transactionSignatures: [],\n                  simulatedSignatures: []\n                };\n                return _context76.abrupt(\"return\", latestBlockhash);\n\n              case 13:\n                _context76.next = 15;\n                return sleep(MS_PER_SLOT / 2);\n\n              case 15:\n                i++;\n                _context76.next = 6;\n                break;\n\n              case 18:\n                throw new Error(\"Unable to obtain a new blockhash after \".concat(Date.now() - startTime, \"ms\"));\n\n              case 19:\n                _context76.prev = 19;\n                this._pollingBlockhash = false;\n                return _context76.finish(19);\n\n              case 22:\n              case \"end\":\n                return _context76.stop();\n            }\n          }\n        }, _callee76, this, [[1,, 19, 22]]);\n      }));\n\n      function _pollNewBlockhash() {\n        return _pollNewBlockhash2.apply(this, arguments);\n      }\n\n      return _pollNewBlockhash;\n    }()\n    /**\n     * Simulate a transaction\n     */\n\n  }, {\n    key: \"simulateTransaction\",\n    value: function () {\n      var _simulateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee77(transactionOrMessage, signers, includeAccounts) {\n        var transaction, originalTx, _transaction3, disableCache, _transaction4, latestBlockhash, signature, message, signData, wireTransaction, encodedTransaction, config, addresses, args, unsafeRes, res, logs, traceIndent, logTrace;\n\n        return _regeneratorRuntime().wrap(function _callee77$(_context77) {\n          while (1) {\n            switch (_context77.prev = _context77.next) {\n              case 0:\n                if (transactionOrMessage instanceof Transaction) {\n                  originalTx = transactionOrMessage;\n                  transaction = new Transaction();\n                  transaction.feePayer = originalTx.feePayer;\n                  transaction.instructions = transactionOrMessage.instructions;\n                  transaction.nonceInfo = originalTx.nonceInfo;\n                  transaction.signatures = originalTx.signatures;\n                } else {\n                  transaction = Transaction.populate(transactionOrMessage); // HACK: this function relies on mutating the populated transaction\n\n                  transaction._message = transaction._json = undefined;\n                }\n\n                if (!(transaction.nonceInfo && signers)) {\n                  _context77.next = 5;\n                  break;\n                }\n\n                (_transaction3 = transaction).sign.apply(_transaction3, _toConsumableArray(signers));\n\n                _context77.next = 25;\n                break;\n\n              case 5:\n                disableCache = this._disableBlockhashCaching;\n\n              case 6:\n                _context77.next = 8;\n                return this._blockhashWithExpiryBlockHeight(disableCache);\n\n              case 8:\n                latestBlockhash = _context77.sent;\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n\n                if (signers) {\n                  _context77.next = 13;\n                  break;\n                }\n\n                return _context77.abrupt(\"break\", 25);\n\n              case 13:\n                (_transaction4 = transaction).sign.apply(_transaction4, _toConsumableArray(signers));\n\n                if (transaction.signature) {\n                  _context77.next = 16;\n                  break;\n                }\n\n                throw new Error('!signature');\n\n              case 16:\n                signature = transaction.signature.toString('base64');\n\n                if (!(!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature))) {\n                  _context77.next = 22;\n                  break;\n                }\n\n                // The signature of this transaction has not been seen before with the\n                // current recentBlockhash, all done. Let's break\n                this._blockhashInfo.simulatedSignatures.push(signature);\n\n                return _context77.abrupt(\"break\", 25);\n\n              case 22:\n                // This transaction would be treated as duplicate (its derived signature\n                // matched to one of already recorded signatures).\n                // So, we must fetch a new blockhash for a different signature by disabling\n                // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                disableCache = true;\n\n              case 23:\n                _context77.next = 6;\n                break;\n\n              case 25:\n                message = transaction._compile();\n                signData = message.serialize();\n                wireTransaction = transaction._serialize(signData);\n                encodedTransaction = wireTransaction.toString('base64');\n                config = {\n                  encoding: 'base64',\n                  commitment: this.commitment\n                };\n\n                if (includeAccounts) {\n                  addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(function (key) {\n                    return key.toBase58();\n                  });\n                  config['accounts'] = {\n                    encoding: 'base64',\n                    addresses: addresses\n                  };\n                }\n\n                if (signers) {\n                  config.sigVerify = true;\n                }\n\n                args = [encodedTransaction, config];\n                _context77.next = 35;\n                return this._rpcRequest('simulateTransaction', args);\n\n              case 35:\n                unsafeRes = _context77.sent;\n                res = create(unsafeRes, SimulatedTransactionResponseStruct);\n\n                if (!('error' in res)) {\n                  _context77.next = 40;\n                  break;\n                }\n\n                if ('data' in res.error) {\n                  logs = res.error.data.logs;\n\n                  if (logs && Array.isArray(logs)) {\n                    traceIndent = '\\n    ';\n                    logTrace = traceIndent + logs.join(traceIndent);\n                    console.error(res.error.message, logTrace);\n                  }\n                }\n\n                throw new SendTransactionError('failed to simulate transaction: ' + res.error.message, logs);\n\n              case 40:\n                return _context77.abrupt(\"return\", res.result);\n\n              case 41:\n              case \"end\":\n                return _context77.stop();\n            }\n          }\n        }, _callee77, this);\n      }));\n\n      function simulateTransaction(_x130, _x131, _x132) {\n        return _simulateTransaction.apply(this, arguments);\n      }\n\n      return simulateTransaction;\n    }()\n    /**\n     * Sign and send a transaction\n     */\n\n  }, {\n    key: \"sendTransaction\",\n    value: function () {\n      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee78(transaction, signers, options) {\n        var disableCache, latestBlockhash, signature, wireTransaction;\n        return _regeneratorRuntime().wrap(function _callee78$(_context78) {\n          while (1) {\n            switch (_context78.prev = _context78.next) {\n              case 0:\n                if (!transaction.nonceInfo) {\n                  _context78.next = 4;\n                  break;\n                }\n\n                transaction.sign.apply(transaction, _toConsumableArray(signers));\n                _context78.next = 22;\n                break;\n\n              case 4:\n                disableCache = this._disableBlockhashCaching;\n\n              case 5:\n                _context78.next = 7;\n                return this._blockhashWithExpiryBlockHeight(disableCache);\n\n              case 7:\n                latestBlockhash = _context78.sent;\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                transaction.sign.apply(transaction, _toConsumableArray(signers));\n\n                if (transaction.signature) {\n                  _context78.next = 13;\n                  break;\n                }\n\n                throw new Error('!signature');\n\n              case 13:\n                signature = transaction.signature.toString('base64');\n\n                if (this._blockhashInfo.transactionSignatures.includes(signature)) {\n                  _context78.next = 19;\n                  break;\n                }\n\n                // The signature of this transaction has not been seen before with the\n                // current recentBlockhash, all done. Let's break\n                this._blockhashInfo.transactionSignatures.push(signature);\n\n                return _context78.abrupt(\"break\", 22);\n\n              case 19:\n                // This transaction would be treated as duplicate (its derived signature\n                // matched to one of already recorded signatures).\n                // So, we must fetch a new blockhash for a different signature by disabling\n                // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                disableCache = true;\n\n              case 20:\n                _context78.next = 5;\n                break;\n\n              case 22:\n                wireTransaction = transaction.serialize();\n                _context78.next = 25;\n                return this.sendRawTransaction(wireTransaction, options);\n\n              case 25:\n                return _context78.abrupt(\"return\", _context78.sent);\n\n              case 26:\n              case \"end\":\n                return _context78.stop();\n            }\n          }\n        }, _callee78, this);\n      }));\n\n      function sendTransaction(_x133, _x134, _x135) {\n        return _sendTransaction.apply(this, arguments);\n      }\n\n      return sendTransaction;\n    }()\n    /**\n     * Send a transaction that has already been signed and serialized into the\n     * wire format\n     */\n\n  }, {\n    key: \"sendRawTransaction\",\n    value: function () {\n      var _sendRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee79(rawTransaction, options) {\n        var encodedTransaction, result;\n        return _regeneratorRuntime().wrap(function _callee79$(_context79) {\n          while (1) {\n            switch (_context79.prev = _context79.next) {\n              case 0:\n                encodedTransaction = toBuffer(rawTransaction).toString('base64');\n                _context79.next = 3;\n                return this.sendEncodedTransaction(encodedTransaction, options);\n\n              case 3:\n                result = _context79.sent;\n                return _context79.abrupt(\"return\", result);\n\n              case 5:\n              case \"end\":\n                return _context79.stop();\n            }\n          }\n        }, _callee79, this);\n      }));\n\n      function sendRawTransaction(_x136, _x137) {\n        return _sendRawTransaction.apply(this, arguments);\n      }\n\n      return sendRawTransaction;\n    }()\n    /**\n     * Send a transaction that has already been signed, serialized into the\n     * wire format, and encoded as a base64 string\n     */\n\n  }, {\n    key: \"sendEncodedTransaction\",\n    value: function () {\n      var _sendEncodedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee80(encodedTransaction, options) {\n        var config, skipPreflight, preflightCommitment, args, unsafeRes, res, logs;\n        return _regeneratorRuntime().wrap(function _callee80$(_context80) {\n          while (1) {\n            switch (_context80.prev = _context80.next) {\n              case 0:\n                config = {\n                  encoding: 'base64'\n                };\n                skipPreflight = options && options.skipPreflight;\n                preflightCommitment = options && options.preflightCommitment || this.commitment;\n\n                if (options && options.maxRetries) {\n                  config.maxRetries = options.maxRetries;\n                }\n\n                if (options && options.minContextSlot != null) {\n                  config.minContextSlot = options.minContextSlot;\n                }\n\n                if (skipPreflight) {\n                  config.skipPreflight = skipPreflight;\n                }\n\n                if (preflightCommitment) {\n                  config.preflightCommitment = preflightCommitment;\n                }\n\n                args = [encodedTransaction, config];\n                _context80.next = 10;\n                return this._rpcRequest('sendTransaction', args);\n\n              case 10:\n                unsafeRes = _context80.sent;\n                res = create(unsafeRes, SendTransactionRpcResult);\n\n                if (!('error' in res)) {\n                  _context80.next = 15;\n                  break;\n                }\n\n                if ('data' in res.error) {\n                  logs = res.error.data.logs;\n                }\n\n                throw new SendTransactionError('failed to send transaction: ' + res.error.message, logs);\n\n              case 15:\n                return _context80.abrupt(\"return\", res.result);\n\n              case 16:\n              case \"end\":\n                return _context80.stop();\n            }\n          }\n        }, _callee80, this);\n      }));\n\n      function sendEncodedTransaction(_x138, _x139) {\n        return _sendEncodedTransaction.apply(this, arguments);\n      }\n\n      return sendEncodedTransaction;\n    }()\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_wsOnOpen\",\n    value: function _wsOnOpen() {\n      var _this14 = this;\n\n      this._rpcWebSocketConnected = true;\n      this._rpcWebSocketHeartbeat = setInterval(function () {\n        // Ping server every 5s to prevent idle timeouts\n        _this14._rpcWebSocket.notify('ping').catch(function () {});\n      }, 5000);\n\n      this._updateSubscriptions();\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_wsOnError\",\n    value: function _wsOnError(err) {\n      this._rpcWebSocketConnected = false;\n      console.error('ws error:', err.message);\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_wsOnClose\",\n    value: function _wsOnClose(code) {\n      var _this15 = this;\n\n      this._rpcWebSocketConnected = false;\n      this._rpcWebSocketGeneration++;\n\n      if (this._rpcWebSocketHeartbeat) {\n        clearInterval(this._rpcWebSocketHeartbeat);\n        this._rpcWebSocketHeartbeat = null;\n      }\n\n      if (code === 1000) {\n        // explicit close, check if any subscriptions have been made since close\n        this._updateSubscriptions();\n\n        return;\n      } // implicit close, prepare subscriptions for auto-reconnect\n\n\n      this._subscriptionCallbacksByServerSubscriptionId = {};\n      Object.entries(this._subscriptionsByHash).forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 2),\n            hash = _ref14[0],\n            subscription = _ref14[1];\n\n        _this15._subscriptionsByHash[hash] = _objectSpread({}, subscription, {\n          state: 'pending'\n        });\n      });\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_updateSubscriptions\",\n    value: function () {\n      var _updateSubscriptions2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee84() {\n        var _this16 = this;\n\n        var activeWebSocketGeneration, isCurrentConnectionStillActive;\n        return _regeneratorRuntime().wrap(function _callee84$(_context84) {\n          while (1) {\n            switch (_context84.prev = _context84.next) {\n              case 0:\n                if (!(Object.keys(this._subscriptionsByHash).length === 0)) {\n                  _context84.next = 3;\n                  break;\n                }\n\n                if (this._rpcWebSocketConnected) {\n                  this._rpcWebSocketConnected = false;\n                  this._rpcWebSocketIdleTimeout = setTimeout(function () {\n                    _this16._rpcWebSocketIdleTimeout = null;\n\n                    try {\n                      _this16._rpcWebSocket.close();\n                    } catch (err) {\n                      // swallow error if socket has already been closed.\n                      if (err instanceof Error) {\n                        console.log(\"Error when closing socket connection: \".concat(err.message));\n                      }\n                    }\n                  }, 500);\n                }\n\n                return _context84.abrupt(\"return\");\n\n              case 3:\n                if (this._rpcWebSocketIdleTimeout !== null) {\n                  clearTimeout(this._rpcWebSocketIdleTimeout);\n                  this._rpcWebSocketIdleTimeout = null;\n                  this._rpcWebSocketConnected = true;\n                }\n\n                if (this._rpcWebSocketConnected) {\n                  _context84.next = 7;\n                  break;\n                }\n\n                this._rpcWebSocket.connect();\n\n                return _context84.abrupt(\"return\");\n\n              case 7:\n                activeWebSocketGeneration = this._rpcWebSocketGeneration;\n\n                isCurrentConnectionStillActive = function isCurrentConnectionStillActive() {\n                  return activeWebSocketGeneration === _this16._rpcWebSocketGeneration;\n                };\n\n                _context84.next = 11;\n                return Promise.all( // Don't be tempted to change this to `Object.entries`. We call\n                // `_updateSubscriptions` recursively when processing the state,\n                // so it's important that we look up the *current* version of\n                // each subscription, every time we process a hash.\n                Object.keys(this._subscriptionsByHash).map( /*#__PURE__*/function () {\n                  var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee83(hash) {\n                    var subscription;\n                    return _regeneratorRuntime().wrap(function _callee83$(_context83) {\n                      while (1) {\n                        switch (_context83.prev = _context83.next) {\n                          case 0:\n                            subscription = _this16._subscriptionsByHash[hash];\n\n                            if (!(subscription === undefined)) {\n                              _context83.next = 3;\n                              break;\n                            }\n\n                            return _context83.abrupt(\"return\");\n\n                          case 3:\n                            _context83.t0 = subscription.state;\n                            _context83.next = _context83.t0 === 'pending' ? 6 : _context83.t0 === 'unsubscribed' ? 6 : _context83.t0 === 'subscribed' ? 15 : 19;\n                            break;\n\n                          case 6:\n                            if (!(subscription.callbacks.size === 0)) {\n                              _context83.next = 12;\n                              break;\n                            }\n\n                            /**\n                             * You can end up here when:\n                             *\n                             * - a subscription has recently unsubscribed\n                             *   without having new callbacks added to it\n                             *   while the unsubscribe was in flight, or\n                             * - when a pending subscription has its\n                             *   listeners removed before a request was\n                             *   sent to the server.\n                             *\n                             * Being that nobody is interested in this\n                             * subscription any longer, delete it.\n                             */\n                            delete _this16._subscriptionsByHash[hash];\n\n                            if (subscription.state === 'unsubscribed') {\n                              delete _this16._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                            }\n\n                            _context83.next = 11;\n                            return _this16._updateSubscriptions();\n\n                          case 11:\n                            return _context83.abrupt(\"return\");\n\n                          case 12:\n                            _context83.next = 14;\n                            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee81() {\n                              var args, method, serverSubscriptionId;\n                              return _regeneratorRuntime().wrap(function _callee81$(_context81) {\n                                while (1) {\n                                  switch (_context81.prev = _context81.next) {\n                                    case 0:\n                                      args = subscription.args, method = subscription.method;\n                                      _context81.prev = 1;\n                                      _this16._subscriptionsByHash[hash] = _objectSpread({}, subscription, {\n                                        state: 'subscribing'\n                                      });\n                                      _context81.next = 5;\n                                      return _this16._rpcWebSocket.call(method, args);\n\n                                    case 5:\n                                      serverSubscriptionId = _context81.sent;\n                                      _this16._subscriptionsByHash[hash] = _objectSpread({}, subscription, {\n                                        serverSubscriptionId: serverSubscriptionId,\n                                        state: 'subscribed'\n                                      });\n                                      _this16._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n                                      _context81.next = 10;\n                                      return _this16._updateSubscriptions();\n\n                                    case 10:\n                                      _context81.next = 20;\n                                      break;\n\n                                    case 12:\n                                      _context81.prev = 12;\n                                      _context81.t0 = _context81[\"catch\"](1);\n\n                                      if (_context81.t0 instanceof Error) {\n                                        console.error(\"\".concat(method, \" error for argument\"), args, _context81.t0.message);\n                                      }\n\n                                      if (isCurrentConnectionStillActive()) {\n                                        _context81.next = 17;\n                                        break;\n                                      }\n\n                                      return _context81.abrupt(\"return\");\n\n                                    case 17:\n                                      // TODO: Maybe add an 'errored' state or a retry limit?\n                                      _this16._subscriptionsByHash[hash] = _objectSpread({}, subscription, {\n                                        state: 'pending'\n                                      });\n                                      _context81.next = 20;\n                                      return _this16._updateSubscriptions();\n\n                                    case 20:\n                                    case \"end\":\n                                      return _context81.stop();\n                                  }\n                                }\n                              }, _callee81, null, [[1, 12]]);\n                            }))();\n\n                          case 14:\n                            return _context83.abrupt(\"break\", 19);\n\n                          case 15:\n                            if (!(subscription.callbacks.size === 0)) {\n                              _context83.next = 18;\n                              break;\n                            }\n\n                            _context83.next = 18;\n                            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee82() {\n                              var serverSubscriptionId, unsubscribeMethod;\n                              return _regeneratorRuntime().wrap(function _callee82$(_context82) {\n                                while (1) {\n                                  switch (_context82.prev = _context82.next) {\n                                    case 0:\n                                      serverSubscriptionId = subscription.serverSubscriptionId, unsubscribeMethod = subscription.unsubscribeMethod;\n\n                                      if (!_this16._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                        _context82.next = 5;\n                                        break;\n                                      }\n\n                                      /**\n                                       * Special case.\n                                       * If we're dealing with a subscription that has been auto-\n                                       * disposed by the RPC, then we can skip the RPC call to\n                                       * tear down the subscription here.\n                                       *\n                                       * NOTE: There is a proposal to eliminate this special case, here:\n                                       * https://github.com/solana-labs/solana/issues/18892\n                                       */\n                                      _this16._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n\n                                      _context82.next = 20;\n                                      break;\n\n                                    case 5:\n                                      _this16._subscriptionsByHash[hash] = _objectSpread({}, subscription, {\n                                        state: 'unsubscribing'\n                                      });\n                                      _context82.prev = 6;\n                                      _context82.next = 9;\n                                      return _this16._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);\n\n                                    case 9:\n                                      _context82.next = 20;\n                                      break;\n\n                                    case 11:\n                                      _context82.prev = 11;\n                                      _context82.t0 = _context82[\"catch\"](6);\n\n                                      if (_context82.t0 instanceof Error) {\n                                        console.error(\"\".concat(unsubscribeMethod, \" error:\"), _context82.t0.message);\n                                      }\n\n                                      if (isCurrentConnectionStillActive()) {\n                                        _context82.next = 16;\n                                        break;\n                                      }\n\n                                      return _context82.abrupt(\"return\");\n\n                                    case 16:\n                                      // TODO: Maybe add an 'errored' state or a retry limit?\n                                      _this16._subscriptionsByHash[hash] = _objectSpread({}, subscription, {\n                                        state: 'subscribed'\n                                      });\n                                      _context82.next = 19;\n                                      return _this16._updateSubscriptions();\n\n                                    case 19:\n                                      return _context82.abrupt(\"return\");\n\n                                    case 20:\n                                      _this16._subscriptionsByHash[hash] = _objectSpread({}, subscription, {\n                                        state: 'unsubscribed'\n                                      });\n                                      _context82.next = 23;\n                                      return _this16._updateSubscriptions();\n\n                                    case 23:\n                                    case \"end\":\n                                      return _context82.stop();\n                                  }\n                                }\n                              }, _callee82, null, [[6, 11]]);\n                            }))();\n\n                          case 18:\n                            return _context83.abrupt(\"break\", 19);\n\n                          case 19:\n                          case \"end\":\n                            return _context83.stop();\n                        }\n                      }\n                    }, _callee83);\n                  }));\n\n                  return function (_x140) {\n                    return _ref15.apply(this, arguments);\n                  };\n                }()));\n\n              case 11:\n              case \"end\":\n                return _context84.stop();\n            }\n          }\n        }, _callee84, this);\n      }));\n\n      function _updateSubscriptions() {\n        return _updateSubscriptions2.apply(this, arguments);\n      }\n\n      return _updateSubscriptions;\n    }()\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_handleServerNotification\",\n    value: function _handleServerNotification(serverSubscriptionId, callbackArgs) {\n      var callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n\n      if (callbacks === undefined) {\n        return;\n      }\n\n      callbacks.forEach(function (cb) {\n        try {\n          cb.apply(void 0, _toConsumableArray(callbackArgs));\n        } catch (e) {\n          console.error(e);\n        }\n      });\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_wsOnAccountNotification\",\n    value: function _wsOnAccountNotification(notification) {\n      var _create = create(notification, AccountNotificationResult),\n          result = _create.result,\n          subscription = _create.subscription;\n\n      this._handleServerNotification(subscription, [result.value, result.context]);\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_makeSubscription\",\n    value: function _makeSubscription(subscriptionConfig,\n    /**\n     * When preparing `args` for a call to `_makeSubscription`, be sure\n     * to carefully apply a default `commitment` property, if necessary.\n     *\n     * - If the user supplied a `commitment` use that.\n     * - Otherwise, if the `Connection::commitment` is set, use that.\n     * - Otherwise, set it to the RPC server default: `finalized`.\n     *\n     * This is extremely important to ensure that these two fundamentally\n     * identical subscriptions produce the same identifying hash:\n     *\n     * - A subscription made without specifying a commitment.\n     * - A subscription made where the commitment specified is the same\n     *   as the default applied to the subscription above.\n     *\n     * Example; these two subscriptions must produce the same hash:\n     *\n     * - An `accountSubscribe` subscription for `'PUBKEY'`\n     * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n     *   `'finalized'`.\n     *\n     * See the 'making a subscription with defaulted params omitted' test\n     * in `connection-subscriptions.ts` for more.\n     */\n    args) {\n      var _this17 = this;\n\n      var clientSubscriptionId = this._nextClientSubscriptionId++;\n      var hash = fastStableStringify$1([subscriptionConfig.method, args], true\n      /* isArrayProp */\n      );\n      var existingSubscription = this._subscriptionsByHash[hash];\n\n      if (existingSubscription === undefined) {\n        this._subscriptionsByHash[hash] = _objectSpread({}, subscriptionConfig, {\n          args: args,\n          callbacks: new Set([subscriptionConfig.callback]),\n          state: 'pending'\n        });\n      } else {\n        existingSubscription.callbacks.add(subscriptionConfig.callback);\n      }\n\n      this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee85() {\n        var subscription;\n        return _regeneratorRuntime().wrap(function _callee85$(_context85) {\n          while (1) {\n            switch (_context85.prev = _context85.next) {\n              case 0:\n                delete _this17._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n                subscription = _this17._subscriptionsByHash[hash];\n                assert(subscription !== undefined, \"Could not find a `Subscription` when tearing down client subscription #\".concat(clientSubscriptionId));\n                subscription.callbacks.delete(subscriptionConfig.callback);\n                _context85.next = 6;\n                return _this17._updateSubscriptions();\n\n              case 6:\n              case \"end\":\n                return _context85.stop();\n            }\n          }\n        }, _callee85);\n      }));\n\n      this._updateSubscriptions();\n\n      return clientSubscriptionId;\n    }\n    /**\n     * Register a callback to be invoked whenever the specified account changes\n     *\n     * @param publicKey Public key of the account to monitor\n     * @param callback Function to invoke whenever the account is changed\n     * @param commitment Specify the commitment level account changes must reach before notification\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onAccountChange\",\n    value: function onAccountChange(publicKey, callback, commitment) {\n      var args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized', // Apply connection/server default.\n      'base64');\n\n      return this._makeSubscription({\n        callback: callback,\n        method: 'accountSubscribe',\n        unsubscribeMethod: 'accountUnsubscribe'\n      }, args);\n    }\n    /**\n     * Deregister an account notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n\n  }, {\n    key: \"removeAccountChangeListener\",\n    value: function () {\n      var _removeAccountChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee86(clientSubscriptionId) {\n        return _regeneratorRuntime().wrap(function _callee86$(_context86) {\n          while (1) {\n            switch (_context86.prev = _context86.next) {\n              case 0:\n                _context86.next = 2;\n                return this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');\n\n              case 2:\n              case \"end\":\n                return _context86.stop();\n            }\n          }\n        }, _callee86, this);\n      }));\n\n      function removeAccountChangeListener(_x141) {\n        return _removeAccountChangeListener.apply(this, arguments);\n      }\n\n      return removeAccountChangeListener;\n    }()\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_wsOnProgramAccountNotification\",\n    value: function _wsOnProgramAccountNotification(notification) {\n      var _create2 = create(notification, ProgramAccountNotificationResult),\n          result = _create2.result,\n          subscription = _create2.subscription;\n\n      this._handleServerNotification(subscription, [{\n        accountId: result.value.pubkey,\n        accountInfo: result.value.account\n      }, result.context]);\n    }\n    /**\n     * Register a callback to be invoked whenever accounts owned by the\n     * specified program change\n     *\n     * @param programId Public key of the program to monitor\n     * @param callback Function to invoke whenever the account is changed\n     * @param commitment Specify the commitment level account changes must reach before notification\n     * @param filters The program account filters to pass into the RPC method\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onProgramAccountChange\",\n    value: function onProgramAccountChange(programId, callback, commitment, filters) {\n      var args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized', // Apply connection/server default.\n      'base64'\n      /* encoding */\n      , filters ? {\n        filters: filters\n      } : undefined\n      /* extra */\n      );\n\n      return this._makeSubscription({\n        callback: callback,\n        method: 'programSubscribe',\n        unsubscribeMethod: 'programUnsubscribe'\n      }, args);\n    }\n    /**\n     * Deregister an account notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n\n  }, {\n    key: \"removeProgramAccountChangeListener\",\n    value: function () {\n      var _removeProgramAccountChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee87(clientSubscriptionId) {\n        return _regeneratorRuntime().wrap(function _callee87$(_context87) {\n          while (1) {\n            switch (_context87.prev = _context87.next) {\n              case 0:\n                _context87.next = 2;\n                return this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');\n\n              case 2:\n              case \"end\":\n                return _context87.stop();\n            }\n          }\n        }, _callee87, this);\n      }));\n\n      function removeProgramAccountChangeListener(_x142) {\n        return _removeProgramAccountChangeListener.apply(this, arguments);\n      }\n\n      return removeProgramAccountChangeListener;\n    }()\n    /**\n     * Registers a callback to be invoked whenever logs are emitted.\n     */\n\n  }, {\n    key: \"onLogs\",\n    value: function onLogs(filter, callback, commitment) {\n      var args = this._buildArgs([typeof filter === 'object' ? {\n        mentions: [filter.toString()]\n      } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.\n      );\n\n      return this._makeSubscription({\n        callback: callback,\n        method: 'logsSubscribe',\n        unsubscribeMethod: 'logsUnsubscribe'\n      }, args);\n    }\n    /**\n     * Deregister a logs callback.\n     *\n     * @param id client subscription id to deregister.\n     */\n\n  }, {\n    key: \"removeOnLogsListener\",\n    value: function () {\n      var _removeOnLogsListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee88(clientSubscriptionId) {\n        return _regeneratorRuntime().wrap(function _callee88$(_context88) {\n          while (1) {\n            switch (_context88.prev = _context88.next) {\n              case 0:\n                _context88.next = 2;\n                return this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');\n\n              case 2:\n              case \"end\":\n                return _context88.stop();\n            }\n          }\n        }, _callee88, this);\n      }));\n\n      function removeOnLogsListener(_x143) {\n        return _removeOnLogsListener.apply(this, arguments);\n      }\n\n      return removeOnLogsListener;\n    }()\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_wsOnLogsNotification\",\n    value: function _wsOnLogsNotification(notification) {\n      var _create3 = create(notification, LogsNotificationResult),\n          result = _create3.result,\n          subscription = _create3.subscription;\n\n      this._handleServerNotification(subscription, [result.value, result.context]);\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_wsOnSlotNotification\",\n    value: function _wsOnSlotNotification(notification) {\n      var _create4 = create(notification, SlotNotificationResult),\n          result = _create4.result,\n          subscription = _create4.subscription;\n\n      this._handleServerNotification(subscription, [result]);\n    }\n    /**\n     * Register a callback to be invoked upon slot changes\n     *\n     * @param callback Function to invoke whenever the slot changes\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onSlotChange\",\n    value: function onSlotChange(callback) {\n      return this._makeSubscription({\n        callback: callback,\n        method: 'slotSubscribe',\n        unsubscribeMethod: 'slotUnsubscribe'\n      }, []\n      /* args */\n      );\n    }\n    /**\n     * Deregister a slot notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n\n  }, {\n    key: \"removeSlotChangeListener\",\n    value: function () {\n      var _removeSlotChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee89(clientSubscriptionId) {\n        return _regeneratorRuntime().wrap(function _callee89$(_context89) {\n          while (1) {\n            switch (_context89.prev = _context89.next) {\n              case 0:\n                _context89.next = 2;\n                return this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');\n\n              case 2:\n              case \"end\":\n                return _context89.stop();\n            }\n          }\n        }, _callee89, this);\n      }));\n\n      function removeSlotChangeListener(_x144) {\n        return _removeSlotChangeListener.apply(this, arguments);\n      }\n\n      return removeSlotChangeListener;\n    }()\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_wsOnSlotUpdatesNotification\",\n    value: function _wsOnSlotUpdatesNotification(notification) {\n      var _create5 = create(notification, SlotUpdateNotificationResult),\n          result = _create5.result,\n          subscription = _create5.subscription;\n\n      this._handleServerNotification(subscription, [result]);\n    }\n    /**\n     * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n     * may be useful to track live progress of a cluster.\n     *\n     * @param callback Function to invoke whenever the slot updates\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onSlotUpdate\",\n    value: function onSlotUpdate(callback) {\n      return this._makeSubscription({\n        callback: callback,\n        method: 'slotsUpdatesSubscribe',\n        unsubscribeMethod: 'slotsUpdatesUnsubscribe'\n      }, []\n      /* args */\n      );\n    }\n    /**\n     * Deregister a slot update notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n\n  }, {\n    key: \"removeSlotUpdateListener\",\n    value: function () {\n      var _removeSlotUpdateListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee90(clientSubscriptionId) {\n        return _regeneratorRuntime().wrap(function _callee90$(_context90) {\n          while (1) {\n            switch (_context90.prev = _context90.next) {\n              case 0:\n                _context90.next = 2;\n                return this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');\n\n              case 2:\n              case \"end\":\n                return _context90.stop();\n            }\n          }\n        }, _callee90, this);\n      }));\n\n      function removeSlotUpdateListener(_x145) {\n        return _removeSlotUpdateListener.apply(this, arguments);\n      }\n\n      return removeSlotUpdateListener;\n    }()\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_unsubscribeClientSubscription\",\n    value: function () {\n      var _unsubscribeClientSubscription2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee91(clientSubscriptionId, subscriptionName) {\n        var dispose;\n        return _regeneratorRuntime().wrap(function _callee91$(_context91) {\n          while (1) {\n            switch (_context91.prev = _context91.next) {\n              case 0:\n                dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n\n                if (!dispose) {\n                  _context91.next = 6;\n                  break;\n                }\n\n                _context91.next = 4;\n                return dispose();\n\n              case 4:\n                _context91.next = 7;\n                break;\n\n              case 6:\n                console.warn('Ignored unsubscribe request because an active subscription with id ' + \"`\".concat(clientSubscriptionId, \"` for '\").concat(subscriptionName, \"' events \") + 'could not be found.');\n\n              case 7:\n              case \"end\":\n                return _context91.stop();\n            }\n          }\n        }, _callee91, this);\n      }));\n\n      function _unsubscribeClientSubscription(_x146, _x147) {\n        return _unsubscribeClientSubscription2.apply(this, arguments);\n      }\n\n      return _unsubscribeClientSubscription;\n    }()\n  }, {\n    key: \"_buildArgs\",\n    value: function _buildArgs(args, override, encoding, extra) {\n      var commitment = override || this._commitment;\n\n      if (commitment || encoding || extra) {\n        var options = {};\n\n        if (encoding) {\n          options.encoding = encoding;\n        }\n\n        if (commitment) {\n          options.commitment = commitment;\n        }\n\n        if (extra) {\n          options = Object.assign(options, extra);\n        }\n\n        args.push(options);\n      }\n\n      return args;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_buildArgsAtLeastConfirmed\",\n    value: function _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n      var commitment = override || this._commitment;\n\n      if (commitment && !['confirmed', 'finalized'].includes(commitment)) {\n        throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');\n      }\n\n      return this._buildArgs(args, override, encoding, extra);\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_wsOnSignatureNotification\",\n    value: function _wsOnSignatureNotification(notification) {\n      var _create6 = create(notification, SignatureNotificationResult),\n          result = _create6.result,\n          subscription = _create6.subscription;\n\n      if (result.value !== 'receivedSignature') {\n        /**\n         * Special case.\n         * After a signature is processed, RPCs automatically dispose of the\n         * subscription on the server side. We need to track which of these\n         * subscriptions have been disposed in such a way, so that we know\n         * whether the client is dealing with a not-yet-processed signature\n         * (in which case we must tear down the server subscription) or an\n         * already-processed signature (in which case the client can simply\n         * clear out the subscription locally without telling the server).\n         *\n         * NOTE: There is a proposal to eliminate this special case, here:\n         * https://github.com/solana-labs/solana/issues/18892\n         */\n        this._subscriptionsAutoDisposedByRpc.add(subscription);\n      }\n\n      this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{\n        type: 'received'\n      }, result.context] : [{\n        type: 'status',\n        result: result.value\n      }, result.context]);\n    }\n    /**\n     * Register a callback to be invoked upon signature updates\n     *\n     * @param signature Transaction signature string in base 58\n     * @param callback Function to invoke on signature notifications\n     * @param commitment Specify the commitment level signature must reach before notification\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onSignature\",\n    value: function onSignature(signature, _callback, commitment) {\n      var _this18 = this;\n\n      var args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.\n      );\n\n      var clientSubscriptionId = this._makeSubscription({\n        callback: function callback(notification, context) {\n          if (notification.type === 'status') {\n            _callback(notification.result, context); // Signatures subscriptions are auto-removed by the RPC service\n            // so no need to explicitly send an unsubscribe message.\n\n\n            try {\n              _this18.removeSignatureListener(clientSubscriptionId); // eslint-disable-next-line no-empty\n\n            } catch (_err) {// Already removed.\n            }\n          }\n        },\n        method: 'signatureSubscribe',\n        unsubscribeMethod: 'signatureUnsubscribe'\n      }, args);\n\n      return clientSubscriptionId;\n    }\n    /**\n     * Register a callback to be invoked when a transaction is\n     * received and/or processed.\n     *\n     * @param signature Transaction signature string in base 58\n     * @param callback Function to invoke on signature notifications\n     * @param options Enable received notifications and set the commitment\n     *   level that signature must reach before notification\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onSignatureWithOptions\",\n    value: function onSignatureWithOptions(signature, _callback2, options) {\n      var _this19 = this;\n\n      var _options$commitment = _objectSpread({}, options, {\n        commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.\n\n      }),\n          commitment = _options$commitment.commitment,\n          extra = _objectWithoutProperties(_options$commitment, [\"commitment\"]);\n\n      var args = this._buildArgs([signature], commitment, undefined\n      /* encoding */\n      , extra);\n\n      var clientSubscriptionId = this._makeSubscription({\n        callback: function callback(notification, context) {\n          _callback2(notification, context); // Signatures subscriptions are auto-removed by the RPC service\n          // so no need to explicitly send an unsubscribe message.\n\n\n          try {\n            _this19.removeSignatureListener(clientSubscriptionId); // eslint-disable-next-line no-empty\n\n          } catch (_err) {// Already removed.\n          }\n        },\n        method: 'signatureSubscribe',\n        unsubscribeMethod: 'signatureUnsubscribe'\n      }, args);\n\n      return clientSubscriptionId;\n    }\n    /**\n     * Deregister a signature notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n\n  }, {\n    key: \"removeSignatureListener\",\n    value: function () {\n      var _removeSignatureListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee92(clientSubscriptionId) {\n        return _regeneratorRuntime().wrap(function _callee92$(_context92) {\n          while (1) {\n            switch (_context92.prev = _context92.next) {\n              case 0:\n                _context92.next = 2;\n                return this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');\n\n              case 2:\n              case \"end\":\n                return _context92.stop();\n            }\n          }\n        }, _callee92, this);\n      }));\n\n      function removeSignatureListener(_x148) {\n        return _removeSignatureListener.apply(this, arguments);\n      }\n\n      return removeSignatureListener;\n    }()\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_wsOnRootNotification\",\n    value: function _wsOnRootNotification(notification) {\n      var _create7 = create(notification, RootNotificationResult),\n          result = _create7.result,\n          subscription = _create7.subscription;\n\n      this._handleServerNotification(subscription, [result]);\n    }\n    /**\n     * Register a callback to be invoked upon root changes\n     *\n     * @param callback Function to invoke whenever the root changes\n     * @return subscription id\n     */\n\n  }, {\n    key: \"onRootChange\",\n    value: function onRootChange(callback) {\n      return this._makeSubscription({\n        callback: callback,\n        method: 'rootSubscribe',\n        unsubscribeMethod: 'rootUnsubscribe'\n      }, []\n      /* args */\n      );\n    }\n    /**\n     * Deregister a root notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n\n  }, {\n    key: \"removeRootChangeListener\",\n    value: function () {\n      var _removeRootChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee93(clientSubscriptionId) {\n        return _regeneratorRuntime().wrap(function _callee93$(_context93) {\n          while (1) {\n            switch (_context93.prev = _context93.next) {\n              case 0:\n                _context93.next = 2;\n                return this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');\n\n              case 2:\n              case \"end\":\n                return _context93.stop();\n            }\n          }\n        }, _callee93, this);\n      }));\n\n      function removeRootChangeListener(_x149) {\n        return _removeRootChangeListener.apply(this, arguments);\n      }\n\n      return removeRootChangeListener;\n    }()\n  }, {\n    key: \"commitment\",\n    get: function get() {\n      return this._commitment;\n    }\n    /**\n     * The RPC endpoint\n     */\n\n  }, {\n    key: \"rpcEndpoint\",\n    get: function get() {\n      return this._rpcEndpoint;\n    }\n  }]);\n\n  return Connection;\n}();\n/**\n * Keypair signer interface\n */\n\n/**\n * An account keypair used for signing transactions.\n */\n\n\nvar Keypair = /*#__PURE__*/function () {\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param keypair ed25519 keypair\n   */\n  function Keypair(keypair) {\n    _classCallCheck(this, Keypair);\n\n    this._keypair = void 0;\n\n    if (keypair) {\n      this._keypair = keypair;\n    } else {\n      this._keypair = nacl.sign.keyPair();\n    }\n  }\n  /**\n   * Generate a new random keypair\n   */\n\n\n  _createClass(Keypair, [{\n    key: \"publicKey\",\n\n    /**\n     * The public key for this keypair\n     */\n    get: function get() {\n      return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n     * The raw secret key for this keypair\n     */\n\n  }, {\n    key: \"secretKey\",\n    get: function get() {\n      return this._keypair.secretKey;\n    }\n  }], [{\n    key: \"generate\",\n    value: function generate() {\n      return new Keypair(nacl.sign.keyPair());\n    }\n    /**\n     * Create a keypair from a raw secret key byte array.\n     *\n     * This method should only be used to recreate a keypair from a previously\n     * generated secret key. Generating keypairs from a random seed should be done\n     * with the {@link Keypair.fromSeed} method.\n     *\n     * @throws error if the provided secret key is invalid and validation is not skipped.\n     *\n     * @param secretKey secret key byte array\n     * @param options: skip secret key validation\n     */\n\n  }, {\n    key: \"fromSecretKey\",\n    value: function fromSecretKey(secretKey, options) {\n      var keypair = nacl.sign.keyPair.fromSecretKey(secretKey);\n\n      if (!options || !options.skipValidation) {\n        var encoder = new TextEncoder();\n        var signData = encoder.encode('@solana/web3.js-validation-v1');\n        var signature = nacl.sign.detached(signData, keypair.secretKey);\n\n        if (!nacl.sign.detached.verify(signData, signature, keypair.publicKey)) {\n          throw new Error('provided secretKey is invalid');\n        }\n      }\n\n      return new Keypair(keypair);\n    }\n    /**\n     * Generate a keypair from a 32 byte seed.\n     *\n     * @param seed seed byte array\n     */\n\n  }, {\n    key: \"fromSeed\",\n    value: function fromSeed(seed) {\n      return new Keypair(nacl.sign.keyPair.fromSeed(seed));\n    }\n  }]);\n\n  return Keypair;\n}();\n\nvar PRIVATE_KEY_BYTES$1 = 64;\nvar PUBLIC_KEY_BYTES$1 = 32;\nvar SIGNATURE_BYTES = 64;\n/**\n * Params for creating an ed25519 instruction using a public key\n */\n\nvar ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8('numSignatures'), BufferLayout.u8('padding'), BufferLayout.u16('signatureOffset'), BufferLayout.u16('signatureInstructionIndex'), BufferLayout.u16('publicKeyOffset'), BufferLayout.u16('publicKeyInstructionIndex'), BufferLayout.u16('messageDataOffset'), BufferLayout.u16('messageDataSize'), BufferLayout.u16('messageInstructionIndex')]);\n\nvar Ed25519Program = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function Ed25519Program() {\n    _classCallCheck(this, Ed25519Program);\n  }\n  /**\n   * Public key that identifies the ed25519 program\n   */\n\n  /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */\n\n\n  _createClass(Ed25519Program, null, [{\n    key: \"createInstructionWithPublicKey\",\n    value: function createInstructionWithPublicKey(params) {\n      var publicKey = params.publicKey,\n          message = params.message,\n          signature = params.signature,\n          instructionIndex = params.instructionIndex;\n      assert(publicKey.length === PUBLIC_KEY_BYTES$1, \"Public Key must be \".concat(PUBLIC_KEY_BYTES$1, \" bytes but received \").concat(publicKey.length, \" bytes\"));\n      assert(signature.length === SIGNATURE_BYTES, \"Signature must be \".concat(SIGNATURE_BYTES, \" bytes but received \").concat(signature.length, \" bytes\"));\n      var publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n      var signatureOffset = publicKeyOffset + publicKey.length;\n      var messageDataOffset = signatureOffset + signature.length;\n      var numSignatures = 1;\n      var instructionData = Buffer.alloc(messageDataOffset + message.length);\n      var index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n      : instructionIndex;\n      ED25519_INSTRUCTION_LAYOUT.encode({\n        numSignatures: numSignatures,\n        padding: 0,\n        signatureOffset: signatureOffset,\n        signatureInstructionIndex: index,\n        publicKeyOffset: publicKeyOffset,\n        publicKeyInstructionIndex: index,\n        messageDataOffset: messageDataOffset,\n        messageDataSize: message.length,\n        messageInstructionIndex: index\n      }, instructionData);\n      instructionData.fill(publicKey, publicKeyOffset);\n      instructionData.fill(signature, signatureOffset);\n      instructionData.fill(message, messageDataOffset);\n      return new TransactionInstruction({\n        keys: [],\n        programId: Ed25519Program.programId,\n        data: instructionData\n      });\n    }\n    /**\n     * Create an ed25519 instruction with a private key. The private key\n     * must be a buffer that is 64 bytes long.\n     */\n\n  }, {\n    key: \"createInstructionWithPrivateKey\",\n    value: function createInstructionWithPrivateKey(params) {\n      var privateKey = params.privateKey,\n          message = params.message,\n          instructionIndex = params.instructionIndex;\n      assert(privateKey.length === PRIVATE_KEY_BYTES$1, \"Private key must be \".concat(PRIVATE_KEY_BYTES$1, \" bytes but received \").concat(privateKey.length, \" bytes\"));\n\n      try {\n        var keypair = Keypair.fromSecretKey(privateKey);\n\n        var _publicKey2 = keypair.publicKey.toBytes();\n\n        var signature = nacl.sign.detached(message, keypair.secretKey);\n        return this.createInstructionWithPublicKey({\n          publicKey: _publicKey2,\n          message: message,\n          signature: signature,\n          instructionIndex: instructionIndex\n        });\n      } catch (error) {\n        throw new Error(\"Error creating instruction; \".concat(error));\n      }\n    }\n  }]);\n\n  return Ed25519Program;\n}();\n\nEd25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111');\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */\n\nvar STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');\n/**\n * Stake account authority info\n */\n\nvar Authorized =\n/** stake authority */\n\n/** withdraw authority */\n\n/**\n * Create a new Authorized object\n * @param staker the stake authority\n * @param withdrawer the withdraw authority\n */\nfunction Authorized(staker, withdrawer) {\n  _classCallCheck(this, Authorized);\n\n  this.staker = void 0;\n  this.withdrawer = void 0;\n  this.staker = staker;\n  this.withdrawer = withdrawer;\n};\n/**\n * Stake account lockup info\n */\n\n\nvar Lockup =\n/** Unix timestamp of lockup expiration */\n\n/** Epoch of lockup expiration */\n\n/** Lockup custodian authority */\n\n/**\n * Create a new Lockup object\n */\nfunction Lockup(unixTimestamp, epoch, custodian) {\n  _classCallCheck(this, Lockup);\n\n  this.unixTimestamp = void 0;\n  this.epoch = void 0;\n  this.custodian = void 0;\n  this.unixTimestamp = unixTimestamp;\n  this.epoch = epoch;\n  this.custodian = custodian;\n}\n/**\n * Default, inactive Lockup value\n */\n;\n\nLockup.default = new Lockup(0, 0, PublicKey.default);\n/**\n * Stake Instruction class\n */\n\nvar StakeInstruction = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function StakeInstruction() {\n    _classCallCheck(this, StakeInstruction);\n  }\n  /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */\n\n\n  _createClass(StakeInstruction, null, [{\n    key: \"decodeInstructionType\",\n    value: function decodeInstructionType(instruction) {\n      this.checkProgramId(instruction.programId);\n      var instructionTypeLayout = BufferLayout.u32('instruction');\n      var typeIndex = instructionTypeLayout.decode(instruction.data);\n      var type;\n\n      for (var _i6 = 0, _Object$entries3 = Object.entries(STAKE_INSTRUCTION_LAYOUTS); _i6 < _Object$entries3.length; _i6++) {\n        var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i6], 2),\n            ixType = _Object$entries3$_i[0],\n            layout = _Object$entries3$_i[1];\n\n        if (layout.index == typeIndex) {\n          type = ixType;\n          break;\n        }\n      }\n\n      if (!type) {\n        throw new Error('Instruction type incorrect; not a StakeInstruction');\n      }\n\n      return type;\n    }\n    /**\n     * Decode a initialize stake instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeInitialize\",\n    value: function decodeInitialize(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n\n      var _decodeData16 = decodeData(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data),\n          authorized = _decodeData16.authorized,\n          lockup = _decodeData16.lockup;\n\n      return {\n        stakePubkey: instruction.keys[0].pubkey,\n        authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n        lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n      };\n    }\n    /**\n     * Decode a delegate stake instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeDelegate\",\n    value: function decodeDelegate(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 6);\n      decodeData(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n      return {\n        stakePubkey: instruction.keys[0].pubkey,\n        votePubkey: instruction.keys[1].pubkey,\n        authorizedPubkey: instruction.keys[5].pubkey\n      };\n    }\n    /**\n     * Decode an authorize stake instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeAuthorize\",\n    value: function decodeAuthorize(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n\n      var _decodeData17 = decodeData(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),\n          newAuthorized = _decodeData17.newAuthorized,\n          stakeAuthorizationType = _decodeData17.stakeAuthorizationType;\n\n      var o = {\n        stakePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: instruction.keys[2].pubkey,\n        newAuthorizedPubkey: new PublicKey(newAuthorized),\n        stakeAuthorizationType: {\n          index: stakeAuthorizationType\n        }\n      };\n\n      if (instruction.keys.length > 3) {\n        o.custodianPubkey = instruction.keys[3].pubkey;\n      }\n\n      return o;\n    }\n    /**\n     * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeAuthorizeWithSeed\",\n    value: function decodeAuthorizeWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n\n      var _decodeData18 = decodeData(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data),\n          newAuthorized = _decodeData18.newAuthorized,\n          stakeAuthorizationType = _decodeData18.stakeAuthorizationType,\n          authoritySeed = _decodeData18.authoritySeed,\n          authorityOwner = _decodeData18.authorityOwner;\n\n      var o = {\n        stakePubkey: instruction.keys[0].pubkey,\n        authorityBase: instruction.keys[1].pubkey,\n        authoritySeed: authoritySeed,\n        authorityOwner: new PublicKey(authorityOwner),\n        newAuthorizedPubkey: new PublicKey(newAuthorized),\n        stakeAuthorizationType: {\n          index: stakeAuthorizationType\n        }\n      };\n\n      if (instruction.keys.length > 3) {\n        o.custodianPubkey = instruction.keys[3].pubkey;\n      }\n\n      return o;\n    }\n    /**\n     * Decode a split stake instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeSplit\",\n    value: function decodeSplit(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n\n      var _decodeData19 = decodeData(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data),\n          lamports = _decodeData19.lamports;\n\n      return {\n        stakePubkey: instruction.keys[0].pubkey,\n        splitStakePubkey: instruction.keys[1].pubkey,\n        authorizedPubkey: instruction.keys[2].pubkey,\n        lamports: lamports\n      };\n    }\n    /**\n     * Decode a merge stake instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeMerge\",\n    value: function decodeMerge(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      decodeData(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n      return {\n        stakePubkey: instruction.keys[0].pubkey,\n        sourceStakePubKey: instruction.keys[1].pubkey,\n        authorizedPubkey: instruction.keys[4].pubkey\n      };\n    }\n    /**\n     * Decode a withdraw stake instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeWithdraw\",\n    value: function decodeWithdraw(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 5);\n\n      var _decodeData20 = decodeData(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),\n          lamports = _decodeData20.lamports;\n\n      var o = {\n        stakePubkey: instruction.keys[0].pubkey,\n        toPubkey: instruction.keys[1].pubkey,\n        authorizedPubkey: instruction.keys[4].pubkey,\n        lamports: lamports\n      };\n\n      if (instruction.keys.length > 5) {\n        o.custodianPubkey = instruction.keys[5].pubkey;\n      }\n\n      return o;\n    }\n    /**\n     * Decode a deactivate stake instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeDeactivate\",\n    value: function decodeDeactivate(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      decodeData(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n      return {\n        stakePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: instruction.keys[2].pubkey\n      };\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"checkProgramId\",\n    value: function checkProgramId(programId) {\n      if (!programId.equals(StakeProgram.programId)) {\n        throw new Error('invalid instruction; programId is not StakeProgram');\n      }\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"checkKeyLength\",\n    value: function checkKeyLength(keys, expectedLength) {\n      if (keys.length < expectedLength) {\n        throw new Error(\"invalid instruction; found \".concat(keys.length, \" keys, expected at least \").concat(expectedLength));\n      }\n    }\n  }]);\n\n  return StakeInstruction;\n}();\n/**\n * An enumeration of valid StakeInstructionType's\n */\n\n/**\n * An enumeration of valid stake InstructionType's\n * @internal\n */\n\n\nvar STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n  Initialize: {\n    index: 0,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), authorized(), lockup()])\n  },\n  Authorize: {\n    index: 1,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('newAuthorized'), BufferLayout.u32('stakeAuthorizationType')])\n  },\n  Delegate: {\n    index: 2,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction')])\n  },\n  Split: {\n    index: 3,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])\n  },\n  Withdraw: {\n    index: 4,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])\n  },\n  Deactivate: {\n    index: 5,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction')])\n  },\n  Merge: {\n    index: 7,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction')])\n  },\n  AuthorizeWithSeed: {\n    index: 8,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('newAuthorized'), BufferLayout.u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])\n  }\n});\n/**\n * Stake authorization type\n */\n\n/**\n * An enumeration of valid StakeAuthorizationLayout's\n */\n\nvar StakeAuthorizationLayout = Object.freeze({\n  Staker: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */\n\nvar StakeProgram = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function StakeProgram() {\n    _classCallCheck(this, StakeProgram);\n  }\n  /**\n   * Public key that identifies the Stake program\n   */\n\n  /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */\n\n\n  _createClass(StakeProgram, null, [{\n    key: \"initialize\",\n    value: function initialize(params) {\n      var stakePubkey = params.stakePubkey,\n          authorized = params.authorized,\n          maybeLockup = params.lockup;\n      var lockup = maybeLockup || Lockup.default;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n      var data = encodeData(type, {\n        authorized: {\n          staker: toBuffer(authorized.staker.toBuffer()),\n          withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n        },\n        lockup: {\n          unixTimestamp: lockup.unixTimestamp,\n          epoch: lockup.epoch,\n          custodian: toBuffer(lockup.custodian.toBuffer())\n        }\n      });\n      var instructionData = {\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n    /**\n     * Generate a Transaction that creates a new Stake account at\n     *   an address generated with `from`, a seed, and the Stake programId\n     */\n\n  }, {\n    key: \"createAccountWithSeed\",\n    value: function createAccountWithSeed(params) {\n      var transaction = new Transaction();\n      transaction.add(SystemProgram.createAccountWithSeed({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.stakePubkey,\n        basePubkey: params.basePubkey,\n        seed: params.seed,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId\n      }));\n      var stakePubkey = params.stakePubkey,\n          authorized = params.authorized,\n          lockup = params.lockup;\n      return transaction.add(this.initialize({\n        stakePubkey: stakePubkey,\n        authorized: authorized,\n        lockup: lockup\n      }));\n    }\n    /**\n     * Generate a Transaction that creates a new Stake account\n     */\n\n  }, {\n    key: \"createAccount\",\n    value: function createAccount(params) {\n      var transaction = new Transaction();\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.stakePubkey,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId\n      }));\n      var stakePubkey = params.stakePubkey,\n          authorized = params.authorized,\n          lockup = params.lockup;\n      return transaction.add(this.initialize({\n        stakePubkey: stakePubkey,\n        authorized: authorized,\n        lockup: lockup\n      }));\n    }\n    /**\n     * Generate a Transaction that delegates Stake tokens to a validator\n     * Vote PublicKey. This transaction can also be used to redelegate Stake\n     * to a new validator Vote PublicKey.\n     */\n\n  }, {\n    key: \"delegate\",\n    value: function delegate(params) {\n      var stakePubkey = params.stakePubkey,\n          authorizedPubkey = params.authorizedPubkey,\n          votePubkey = params.votePubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n      var data = encodeData(type);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: votePubkey,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: STAKE_CONFIG_ID,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that authorizes a new PublicKey as Staker\n     * or Withdrawer on the Stake account.\n     */\n\n  }, {\n    key: \"authorize\",\n    value: function authorize(params) {\n      var stakePubkey = params.stakePubkey,\n          authorizedPubkey = params.authorizedPubkey,\n          newAuthorizedPubkey = params.newAuthorizedPubkey,\n          stakeAuthorizationType = params.stakeAuthorizationType,\n          custodianPubkey = params.custodianPubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n      var data = encodeData(type, {\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        stakeAuthorizationType: stakeAuthorizationType.index\n      });\n      var keys = [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n\n      if (custodianPubkey) {\n        keys.push({\n          pubkey: custodianPubkey,\n          isSigner: false,\n          isWritable: false\n        });\n      }\n\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that authorizes a new PublicKey as Staker\n     * or Withdrawer on the Stake account.\n     */\n\n  }, {\n    key: \"authorizeWithSeed\",\n    value: function authorizeWithSeed(params) {\n      var stakePubkey = params.stakePubkey,\n          authorityBase = params.authorityBase,\n          authoritySeed = params.authoritySeed,\n          authorityOwner = params.authorityOwner,\n          newAuthorizedPubkey = params.newAuthorizedPubkey,\n          stakeAuthorizationType = params.stakeAuthorizationType,\n          custodianPubkey = params.custodianPubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n      var data = encodeData(type, {\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        stakeAuthorizationType: stakeAuthorizationType.index,\n        authoritySeed: authoritySeed,\n        authorityOwner: toBuffer(authorityOwner.toBuffer())\n      });\n      var keys = [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorityBase,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }];\n\n      if (custodianPubkey) {\n        keys.push({\n          pubkey: custodianPubkey,\n          isSigner: false,\n          isWritable: false\n        });\n      }\n\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"splitInstruction\",\n    value: function splitInstruction(params) {\n      var stakePubkey = params.stakePubkey,\n          authorizedPubkey = params.authorizedPubkey,\n          splitStakePubkey = params.splitStakePubkey,\n          lamports = params.lamports;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Split;\n      var data = encodeData(type, {\n        lamports: lamports\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: splitStakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that splits Stake tokens into another stake account\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(params) {\n      var transaction = new Transaction();\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.authorizedPubkey,\n        newAccountPubkey: params.splitStakePubkey,\n        lamports: 0,\n        space: this.space,\n        programId: this.programId\n      }));\n      return transaction.add(this.splitInstruction(params));\n    }\n    /**\n     * Generate a Transaction that splits Stake tokens into another account\n     * derived from a base public key and seed\n     */\n\n  }, {\n    key: \"splitWithSeed\",\n    value: function splitWithSeed(params) {\n      var stakePubkey = params.stakePubkey,\n          authorizedPubkey = params.authorizedPubkey,\n          splitStakePubkey = params.splitStakePubkey,\n          basePubkey = params.basePubkey,\n          seed = params.seed,\n          lamports = params.lamports;\n      var transaction = new Transaction();\n      transaction.add(SystemProgram.allocate({\n        accountPubkey: splitStakePubkey,\n        basePubkey: basePubkey,\n        seed: seed,\n        space: this.space,\n        programId: this.programId\n      }));\n      return transaction.add(this.splitInstruction({\n        stakePubkey: stakePubkey,\n        authorizedPubkey: authorizedPubkey,\n        splitStakePubkey: splitStakePubkey,\n        lamports: lamports\n      }));\n    }\n    /**\n     * Generate a Transaction that merges Stake accounts.\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(params) {\n      var stakePubkey = params.stakePubkey,\n          sourceStakePubKey = params.sourceStakePubKey,\n          authorizedPubkey = params.authorizedPubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n      var data = encodeData(type);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: sourceStakePubKey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that withdraws deactivated Stake tokens.\n     */\n\n  }, {\n    key: \"withdraw\",\n    value: function withdraw(params) {\n      var stakePubkey = params.stakePubkey,\n          authorizedPubkey = params.authorizedPubkey,\n          toPubkey = params.toPubkey,\n          lamports = params.lamports,\n          custodianPubkey = params.custodianPubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n      var data = encodeData(type, {\n        lamports: lamports\n      });\n      var keys = [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: toPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n\n      if (custodianPubkey) {\n        keys.push({\n          pubkey: custodianPubkey,\n          isSigner: false,\n          isWritable: false\n        });\n      }\n\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a Transaction that deactivates Stake tokens.\n     */\n\n  }, {\n    key: \"deactivate\",\n    value: function deactivate(params) {\n      var stakePubkey = params.stakePubkey,\n          authorizedPubkey = params.authorizedPubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n      var data = encodeData(type);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }]);\n\n  return StakeProgram;\n}();\n\nStakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');\nStakeProgram.space = 200;\nvar publicKeyCreate = secp256k1.publicKeyCreate,\n    ecdsaSign = secp256k1.ecdsaSign;\nvar PRIVATE_KEY_BYTES = 32;\nvar ETHEREUM_ADDRESS_BYTES = 20;\nvar PUBLIC_KEY_BYTES = 64;\nvar SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n/**\n * Params for creating an secp256k1 instruction using a public key\n */\n\nvar SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8('numSignatures'), BufferLayout.u16('signatureOffset'), BufferLayout.u8('signatureInstructionIndex'), BufferLayout.u16('ethAddressOffset'), BufferLayout.u8('ethAddressInstructionIndex'), BufferLayout.u16('messageDataOffset'), BufferLayout.u16('messageDataSize'), BufferLayout.u8('messageInstructionIndex'), BufferLayout.blob(20, 'ethAddress'), BufferLayout.blob(64, 'signature'), BufferLayout.u8('recoveryId')]);\n\nvar Secp256k1Program = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function Secp256k1Program() {\n    _classCallCheck(this, Secp256k1Program);\n  }\n  /**\n   * Public key that identifies the secp256k1 program\n   */\n\n  /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */\n\n\n  _createClass(Secp256k1Program, null, [{\n    key: \"publicKeyToEthAddress\",\n    value: function publicKeyToEthAddress(publicKey) {\n      assert(publicKey.length === PUBLIC_KEY_BYTES, \"Public key must be \".concat(PUBLIC_KEY_BYTES, \" bytes but received \").concat(publicKey.length, \" bytes\"));\n\n      try {\n        return Buffer.from(sha3.keccak_256.update(toBuffer(publicKey)).digest()).slice(-ETHEREUM_ADDRESS_BYTES);\n      } catch (error) {\n        throw new Error(\"Error constructing Ethereum address: \".concat(error));\n      }\n    }\n    /**\n     * Create an secp256k1 instruction with a public key. The public key\n     * must be a buffer that is 64 bytes long.\n     */\n\n  }, {\n    key: \"createInstructionWithPublicKey\",\n    value: function createInstructionWithPublicKey(params) {\n      var publicKey = params.publicKey,\n          message = params.message,\n          signature = params.signature,\n          recoveryId = params.recoveryId,\n          instructionIndex = params.instructionIndex;\n      return Secp256k1Program.createInstructionWithEthAddress({\n        ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n        message: message,\n        signature: signature,\n        recoveryId: recoveryId,\n        instructionIndex: instructionIndex\n      });\n    }\n    /**\n     * Create an secp256k1 instruction with an Ethereum address. The address\n     * must be a hex string or a buffer that is 20 bytes long.\n     */\n\n  }, {\n    key: \"createInstructionWithEthAddress\",\n    value: function createInstructionWithEthAddress(params) {\n      var rawAddress = params.ethAddress,\n          message = params.message,\n          signature = params.signature,\n          recoveryId = params.recoveryId,\n          _params$instructionIn = params.instructionIndex,\n          instructionIndex = _params$instructionIn === void 0 ? 0 : _params$instructionIn;\n      var ethAddress;\n\n      if (typeof rawAddress === 'string') {\n        if (rawAddress.startsWith('0x')) {\n          ethAddress = Buffer.from(rawAddress.substr(2), 'hex');\n        } else {\n          ethAddress = Buffer.from(rawAddress, 'hex');\n        }\n      } else {\n        ethAddress = rawAddress;\n      }\n\n      assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, \"Address must be \".concat(ETHEREUM_ADDRESS_BYTES, \" bytes but received \").concat(ethAddress.length, \" bytes\"));\n      var dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n      var ethAddressOffset = dataStart;\n      var signatureOffset = dataStart + ethAddress.length;\n      var messageDataOffset = signatureOffset + signature.length + 1;\n      var numSignatures = 1;\n      var instructionData = Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n      SECP256K1_INSTRUCTION_LAYOUT.encode({\n        numSignatures: numSignatures,\n        signatureOffset: signatureOffset,\n        signatureInstructionIndex: instructionIndex,\n        ethAddressOffset: ethAddressOffset,\n        ethAddressInstructionIndex: instructionIndex,\n        messageDataOffset: messageDataOffset,\n        messageDataSize: message.length,\n        messageInstructionIndex: instructionIndex,\n        signature: toBuffer(signature),\n        ethAddress: toBuffer(ethAddress),\n        recoveryId: recoveryId\n      }, instructionData);\n      instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n      return new TransactionInstruction({\n        keys: [],\n        programId: Secp256k1Program.programId,\n        data: instructionData\n      });\n    }\n    /**\n     * Create an secp256k1 instruction with a private key. The private key\n     * must be a buffer that is 32 bytes long.\n     */\n\n  }, {\n    key: \"createInstructionWithPrivateKey\",\n    value: function createInstructionWithPrivateKey(params) {\n      var pkey = params.privateKey,\n          message = params.message,\n          instructionIndex = params.instructionIndex;\n      assert(pkey.length === PRIVATE_KEY_BYTES, \"Private key must be \".concat(PRIVATE_KEY_BYTES, \" bytes but received \").concat(pkey.length, \" bytes\"));\n\n      try {\n        var privateKey = toBuffer(pkey);\n\n        var _publicKey3 = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte\n\n\n        var messageHash = Buffer.from(sha3.keccak_256.update(toBuffer(message)).digest());\n\n        var _ecdsaSign = ecdsaSign(messageHash, privateKey),\n            signature = _ecdsaSign.signature,\n            recoveryId = _ecdsaSign.recid;\n\n        return this.createInstructionWithPublicKey({\n          publicKey: _publicKey3,\n          message: message,\n          signature: signature,\n          recoveryId: recoveryId,\n          instructionIndex: instructionIndex\n        });\n      } catch (error) {\n        throw new Error(\"Error creating instruction; \".concat(error));\n      }\n    }\n  }]);\n\n  return Secp256k1Program;\n}();\n\nSecp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');\nvar VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');\n/**\n * @internal\n */\n\nvar InfoString = type({\n  name: string(),\n  website: optional(string()),\n  details: optional(string()),\n  keybaseUsername: optional(string())\n});\n/**\n * ValidatorInfo class\n */\n\nvar ValidatorInfo = /*#__PURE__*/function () {\n  /**\n   * validator public key\n   */\n\n  /**\n   * validator information\n   */\n\n  /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */\n  function ValidatorInfo(key, info) {\n    _classCallCheck(this, ValidatorInfo);\n\n    this.key = void 0;\n    this.info = void 0;\n    this.key = key;\n    this.info = info;\n  }\n  /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */\n\n\n  _createClass(ValidatorInfo, null, [{\n    key: \"fromConfigData\",\n    value: function fromConfigData(buffer) {\n      var PUBKEY_LENGTH = 32;\n\n      var byteArray = _toConsumableArray(buffer);\n\n      var configKeyCount = decodeLength(byteArray);\n      if (configKeyCount !== 2) return null;\n      var configKeys = [];\n\n      for (var i = 0; i < 2; i++) {\n        var _publicKey4 = new PublicKey(byteArray.slice(0, PUBKEY_LENGTH));\n\n        byteArray = byteArray.slice(PUBKEY_LENGTH);\n        var isSigner = byteArray.slice(0, 1)[0] === 1;\n        byteArray = byteArray.slice(1);\n        configKeys.push({\n          publicKey: _publicKey4,\n          isSigner: isSigner\n        });\n      }\n\n      if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n        if (configKeys[1].isSigner) {\n          var rawInfo = rustString().decode(Buffer.from(byteArray));\n          var info = JSON.parse(rawInfo);\n          assert$7(info, InfoString);\n          return new ValidatorInfo(configKeys[1].publicKey, info);\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return ValidatorInfo;\n}();\n\nvar VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');\n/**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */\n\nvar VoteAccountLayout = BufferLayout.struct([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), BufferLayout.u8('commission'), BufferLayout.nu64(), // votes.length\nBufferLayout.seq(BufferLayout.struct([BufferLayout.nu64('slot'), BufferLayout.u32('confirmationCount')]), BufferLayout.offset(BufferLayout.u32(), -8), 'votes'), BufferLayout.u8('rootSlotValid'), BufferLayout.nu64('rootSlot'), BufferLayout.nu64(), // authorizedVoters.length\nBufferLayout.seq(BufferLayout.struct([BufferLayout.nu64('epoch'), publicKey('authorizedVoter')]), BufferLayout.offset(BufferLayout.u32(), -8), 'authorizedVoters'), BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey('authorizedPubkey'), BufferLayout.nu64('epochOfLastAuthorizedSwitch'), BufferLayout.nu64('targetEpoch')]), 32, 'buf'), BufferLayout.nu64('idx'), BufferLayout.u8('isEmpty')], 'priorVoters'), BufferLayout.nu64(), // epochCredits.length\nBufferLayout.seq(BufferLayout.struct([BufferLayout.nu64('epoch'), BufferLayout.nu64('credits'), BufferLayout.nu64('prevCredits')]), BufferLayout.offset(BufferLayout.u32(), -8), 'epochCredits'), BufferLayout.struct([BufferLayout.nu64('slot'), BufferLayout.nu64('timestamp')], 'lastTimestamp')]);\n/**\n * VoteAccount class\n */\n\nvar VoteAccount = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function VoteAccount(args) {\n    _classCallCheck(this, VoteAccount);\n\n    this.nodePubkey = void 0;\n    this.authorizedWithdrawer = void 0;\n    this.commission = void 0;\n    this.rootSlot = void 0;\n    this.votes = void 0;\n    this.authorizedVoters = void 0;\n    this.priorVoters = void 0;\n    this.epochCredits = void 0;\n    this.lastTimestamp = void 0;\n    this.nodePubkey = args.nodePubkey;\n    this.authorizedWithdrawer = args.authorizedWithdrawer;\n    this.commission = args.commission;\n    this.rootSlot = args.rootSlot;\n    this.votes = args.votes;\n    this.authorizedVoters = args.authorizedVoters;\n    this.priorVoters = args.priorVoters;\n    this.epochCredits = args.epochCredits;\n    this.lastTimestamp = args.lastTimestamp;\n  }\n  /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */\n\n\n  _createClass(VoteAccount, null, [{\n    key: \"fromAccountData\",\n    value: function fromAccountData(buffer) {\n      var versionOffset = 4;\n      var va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n      var rootSlot = va.rootSlot;\n\n      if (!va.rootSlotValid) {\n        rootSlot = null;\n      }\n\n      return new VoteAccount({\n        nodePubkey: new PublicKey(va.nodePubkey),\n        authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n        commission: va.commission,\n        votes: va.votes,\n        rootSlot: rootSlot,\n        authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n        priorVoters: getPriorVoters(va.priorVoters),\n        epochCredits: va.epochCredits,\n        lastTimestamp: va.lastTimestamp\n      });\n    }\n  }]);\n\n  return VoteAccount;\n}();\n\nfunction parseAuthorizedVoter(_ref19) {\n  var authorizedVoter = _ref19.authorizedVoter,\n      epoch = _ref19.epoch;\n  return {\n    epoch: epoch,\n    authorizedVoter: new PublicKey(authorizedVoter)\n  };\n}\n\nfunction parsePriorVoters(_ref20) {\n  var authorizedPubkey = _ref20.authorizedPubkey,\n      epochOfLastAuthorizedSwitch = _ref20.epochOfLastAuthorizedSwitch,\n      targetEpoch = _ref20.targetEpoch;\n  return {\n    authorizedPubkey: new PublicKey(authorizedPubkey),\n    epochOfLastAuthorizedSwitch: epochOfLastAuthorizedSwitch,\n    targetEpoch: targetEpoch\n  };\n}\n\nfunction getPriorVoters(_ref21) {\n  var buf = _ref21.buf,\n      idx = _ref21.idx,\n      isEmpty = _ref21.isEmpty;\n\n  if (isEmpty) {\n    return [];\n  }\n\n  return [].concat(_toConsumableArray(buf.slice(idx + 1).map(parsePriorVoters)), _toConsumableArray(buf.slice(0, idx).map(parsePriorVoters)));\n}\n/**\n * Vote account info\n */\n\n\nvar VoteInit =\n/** [0, 100] */\nfunction VoteInit(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {\n  _classCallCheck(this, VoteInit);\n\n  this.nodePubkey = void 0;\n  this.authorizedVoter = void 0;\n  this.authorizedWithdrawer = void 0;\n  this.commission = void 0;\n  this.nodePubkey = nodePubkey;\n  this.authorizedVoter = authorizedVoter;\n  this.authorizedWithdrawer = authorizedWithdrawer;\n  this.commission = commission;\n};\n/**\n * Create vote account transaction params\n */\n\n/**\n * Vote Instruction class\n */\n\n\nvar VoteInstruction = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function VoteInstruction() {\n    _classCallCheck(this, VoteInstruction);\n  }\n  /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */\n\n\n  _createClass(VoteInstruction, null, [{\n    key: \"decodeInstructionType\",\n    value: function decodeInstructionType(instruction) {\n      this.checkProgramId(instruction.programId);\n      var instructionTypeLayout = BufferLayout.u32('instruction');\n      var typeIndex = instructionTypeLayout.decode(instruction.data);\n      var type;\n\n      for (var _i7 = 0, _Object$entries4 = Object.entries(VOTE_INSTRUCTION_LAYOUTS); _i7 < _Object$entries4.length; _i7++) {\n        var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i7], 2),\n            ixType = _Object$entries4$_i[0],\n            layout = _Object$entries4$_i[1];\n\n        if (layout.index == typeIndex) {\n          type = ixType;\n          break;\n        }\n      }\n\n      if (!type) {\n        throw new Error('Instruction type incorrect; not a VoteInstruction');\n      }\n\n      return type;\n    }\n    /**\n     * Decode an initialize vote instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeInitializeAccount\",\n    value: function decodeInitializeAccount(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 4);\n\n      var _decodeData21 = decodeData(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data),\n          voteInit = _decodeData21.voteInit;\n\n      return {\n        votePubkey: instruction.keys[0].pubkey,\n        nodePubkey: instruction.keys[3].pubkey,\n        voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n      };\n    }\n    /**\n     * Decode an authorize instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeAuthorize\",\n    value: function decodeAuthorize(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n\n      var _decodeData22 = decodeData(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),\n          newAuthorized = _decodeData22.newAuthorized,\n          voteAuthorizationType = _decodeData22.voteAuthorizationType;\n\n      return {\n        votePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: instruction.keys[2].pubkey,\n        newAuthorizedPubkey: new PublicKey(newAuthorized),\n        voteAuthorizationType: {\n          index: voteAuthorizationType\n        }\n      };\n    }\n    /**\n     * Decode a withdraw instruction and retrieve the instruction params.\n     */\n\n  }, {\n    key: \"decodeWithdraw\",\n    value: function decodeWithdraw(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n\n      var _decodeData23 = decodeData(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),\n          lamports = _decodeData23.lamports;\n\n      return {\n        votePubkey: instruction.keys[0].pubkey,\n        authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n        lamports: lamports,\n        toPubkey: instruction.keys[1].pubkey\n      };\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"checkProgramId\",\n    value: function checkProgramId(programId) {\n      if (!programId.equals(VoteProgram.programId)) {\n        throw new Error('invalid instruction; programId is not VoteProgram');\n      }\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"checkKeyLength\",\n    value: function checkKeyLength(keys, expectedLength) {\n      if (keys.length < expectedLength) {\n        throw new Error(\"invalid instruction; found \".concat(keys.length, \" keys, expected at least \").concat(expectedLength));\n      }\n    }\n  }]);\n\n  return VoteInstruction;\n}();\n/**\n * An enumeration of valid VoteInstructionType's\n */\n\n\nvar VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n  InitializeAccount: {\n    index: 0,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), voteInit()])\n  },\n  Authorize: {\n    index: 1,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), publicKey('newAuthorized'), BufferLayout.u32('voteAuthorizationType')])\n  },\n  Withdraw: {\n    index: 3,\n    layout: BufferLayout.struct([BufferLayout.u32('instruction'), BufferLayout.ns64('lamports')])\n  }\n});\n/**\n * VoteAuthorize type\n */\n\n/**\n * An enumeration of valid VoteAuthorization layouts.\n */\n\nvar VoteAuthorizationLayout = Object.freeze({\n  Voter: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n/**\n * Factory class for transactions to interact with the Vote program\n */\n\nvar VoteProgram = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function VoteProgram() {\n    _classCallCheck(this, VoteProgram);\n  }\n  /**\n   * Public key that identifies the Vote program\n   */\n\n  /**\n   * Generate an Initialize instruction.\n   */\n\n\n  _createClass(VoteProgram, null, [{\n    key: \"initializeAccount\",\n    value: function initializeAccount(params) {\n      var votePubkey = params.votePubkey,\n          nodePubkey = params.nodePubkey,\n          voteInit = params.voteInit;\n      var type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n      var data = encodeData(type, {\n        voteInit: {\n          nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n          authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n          authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n          commission: voteInit.commission\n        }\n      });\n      var instructionData = {\n        keys: [{\n          pubkey: votePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: nodePubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n    /**\n     * Generate a transaction that creates a new Vote account.\n     */\n\n  }, {\n    key: \"createAccount\",\n    value: function createAccount(params) {\n      var transaction = new Transaction();\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.votePubkey,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId\n      }));\n      return transaction.add(this.initializeAccount({\n        votePubkey: params.votePubkey,\n        nodePubkey: params.voteInit.nodePubkey,\n        voteInit: params.voteInit\n      }));\n    }\n    /**\n     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n     */\n\n  }, {\n    key: \"authorize\",\n    value: function authorize(params) {\n      var votePubkey = params.votePubkey,\n          authorizedPubkey = params.authorizedPubkey,\n          newAuthorizedPubkey = params.newAuthorizedPubkey,\n          voteAuthorizationType = params.voteAuthorizationType;\n      var type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n      var data = encodeData(type, {\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        voteAuthorizationType: voteAuthorizationType.index\n      });\n      var keys = [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n    /**\n     * Generate a transaction to withdraw from a Vote account.\n     */\n\n  }, {\n    key: \"withdraw\",\n    value: function withdraw(params) {\n      var votePubkey = params.votePubkey,\n          authorizedWithdrawerPubkey = params.authorizedWithdrawerPubkey,\n          lamports = params.lamports,\n          toPubkey = params.toPubkey;\n      var type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n      var data = encodeData(type, {\n        lamports: lamports\n      });\n      var keys = [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: toPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorizedWithdrawerPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n  }]);\n\n  return VoteProgram;\n}();\n\nVoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');\nVoteProgram.space = 3731;\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {BlockheightBasedTransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\n\n/**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */\n// eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\n\nfunction sendAndConfirmRawTransaction(_x150, _x151, _x152, _x153) {\n  return _sendAndConfirmRawTransaction.apply(this, arguments);\n}\n\nfunction _sendAndConfirmRawTransaction() {\n  _sendAndConfirmRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee95(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    var confirmationStrategy, options, sendOptions, signature, commitment, confirmationPromise, status;\n    return _regeneratorRuntime().wrap(function _callee95$(_context95) {\n      while (1) {\n        switch (_context95.prev = _context95.next) {\n          case 0:\n            if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {\n              confirmationStrategy = confirmationStrategyOrConfirmOptions;\n              options = maybeConfirmOptions;\n            } else {\n              options = confirmationStrategyOrConfirmOptions;\n            }\n\n            sendOptions = options && {\n              skipPreflight: options.skipPreflight,\n              preflightCommitment: options.preflightCommitment || options.commitment,\n              minContextSlot: options.minContextSlot\n            };\n            _context95.next = 4;\n            return connection.sendRawTransaction(rawTransaction, sendOptions);\n\n          case 4:\n            signature = _context95.sent;\n            commitment = options && options.commitment;\n            confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n            _context95.next = 9;\n            return confirmationPromise;\n\n          case 9:\n            status = _context95.sent.value;\n\n            if (!status.err) {\n              _context95.next = 12;\n              break;\n            }\n\n            throw new Error(\"Raw transaction \".concat(signature, \" failed (\").concat(JSON.stringify(status), \")\"));\n\n          case 12:\n            return _context95.abrupt(\"return\", signature);\n\n          case 13:\n          case \"end\":\n            return _context95.stop();\n        }\n      }\n    }, _callee95);\n  }));\n  return _sendAndConfirmRawTransaction.apply(this, arguments);\n}\n\nvar endpoint = {\n  http: {\n    devnet: 'http://api.devnet.solana.com',\n    testnet: 'http://api.testnet.solana.com',\n    'mainnet-beta': 'http://api.mainnet-beta.solana.com/'\n  },\n  https: {\n    devnet: 'https://api.devnet.solana.com',\n    testnet: 'https://api.testnet.solana.com',\n    'mainnet-beta': 'https://api.mainnet-beta.solana.com/'\n  }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n */\n\nfunction clusterApiUrl(cluster, tls) {\n  var key = tls === false ? 'http' : 'https';\n\n  if (!cluster) {\n    return endpoint[key]['devnet'];\n  }\n\n  var url = endpoint[key][cluster];\n\n  if (!url) {\n    throw new Error(\"Unknown \".concat(key, \" cluster: \").concat(cluster));\n  }\n\n  return url;\n}\n/**\n * There are 1-billion lamports in one SOL\n */\n\n\nvar LAMPORTS_PER_SOL = 1000000000;\nexport { Account, Authorized, BLOCKHASH_CACHE_TIMEOUT_MS, BPF_LOADER_DEPRECATED_PROGRAM_ID, BPF_LOADER_PROGRAM_ID, BpfLoader, COMPUTE_BUDGET_INSTRUCTION_LAYOUTS, ComputeBudgetInstruction, ComputeBudgetProgram, Connection, Ed25519Program, Enum, EpochSchedule, FeeCalculatorLayout, Keypair, LAMPORTS_PER_SOL, Loader, Lockup, MAX_SEED_LENGTH, Message, NONCE_ACCOUNT_LENGTH, NonceAccount, PACKET_DATA_SIZE, PublicKey, SIGNATURE_LENGTH_IN_BYTES, SOLANA_SCHEMA, STAKE_CONFIG_ID, STAKE_INSTRUCTION_LAYOUTS, SYSTEM_INSTRUCTION_LAYOUTS, SYSVAR_CLOCK_PUBKEY, SYSVAR_EPOCH_SCHEDULE_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY, SYSVAR_RECENT_BLOCKHASHES_PUBKEY, SYSVAR_RENT_PUBKEY, SYSVAR_REWARDS_PUBKEY, SYSVAR_SLOT_HASHES_PUBKEY, SYSVAR_SLOT_HISTORY_PUBKEY, SYSVAR_STAKE_HISTORY_PUBKEY, Secp256k1Program, SendTransactionError, StakeAuthorizationLayout, StakeInstruction, StakeProgram, Struct, SystemInstruction, SystemProgram, Transaction, TransactionExpiredBlockheightExceededError, TransactionExpiredTimeoutError, TransactionInstruction, TransactionStatus, VALIDATOR_INFO_KEY, VOTE_PROGRAM_ID, ValidatorInfo, VoteAccount, VoteAuthorizationLayout, VoteInit, VoteInstruction, VoteProgram, clusterApiUrl, sendAndConfirmRawTransaction, sendAndConfirmTransaction };","map":null,"metadata":{},"sourceType":"module"}